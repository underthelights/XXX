<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-31T17:40:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Kyuhwan Shim</title><subtitle>Kyuhwan Shim is a senior undergraduate in CS at Sogang University.
</subtitle><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><entry><title type="html">회고와 대회</title><link href="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C" rel="alternate" type="text/html" title="회고와 대회" /><published>2023-11-16T00:00:00+09:00</published><updated>2023-11-16T00:00:00+09:00</updated><id>http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C</id><content type="html" xml:base="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C"><![CDATA[<h1 id="블로그">블로그</h1>

<ul>
  <li>리디자인</li>
</ul>

<h1 id="대회">대회</h1>

<ul>
  <li>2022
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2022 빅콘테스트</li>
    </ul>
  </li>
  <li>2023
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />강서구 데이터 공모전</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />LG Aimers</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Samsung AI Challenge</li>
    </ul>
  </li>
</ul>

<h1 id="일">일</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Nota ITS ML Engineer 인턴 후기
    <ul>
      <li>들어가야 하는 내용
        <ul>
          <li>지원 계기
            <ul>
              <li>타 기업에 대비하여 가질 수 있었던 이점</li>
            </ul>
          </li>
          <li>가서 주로 맡은 업무</li>
          <li>가서 배운 일</li>
          <li>앞으로의 할 일</li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />앞으로 할 일에 대한 정리
    <ul>
      <li>대학원과 취업 사이의 기로</li>
      <li>전공</li>
      <li>ML</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="경험" /><category term="일상기록" /><summary type="html"><![CDATA[블로그]]></summary></entry><entry><title type="html">[ALG] 4.3. Misc.</title><link href="http://localhost:4000/ALG-4.3.-Misc" rel="alternate" type="text/html" title="[ALG] 4.3. Misc." /><published>2022-09-30T00:00:00+09:00</published><updated>2022-09-30T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.3.-Misc</id><content type="html" xml:base="http://localhost:4000/ALG-4.3.-Misc"><![CDATA[<h1 id="alg-huffman-1">[ALG] Huffman (1)</h1>

<p>Huffman Correctness Proof</p>

<p>Proof by Induction</p>

<p>if the set of trees obtained in the ith step are branches in a binary tree corresponding to an optimal code, then the set of trees obtained i+1 th step</p>

<h1 id="alg-intractable-problem-and-approximation-alg-1">[ALG] Intractable Problem and Approximation Alg (1)</h1>

<p>Millenium problems</p>

<p>NP Hard</p>

<ul>
  <li>0-1 knapsack
    <ul>
      <li>문제 size n에 대해서 솔루션 찾지도, 증명도 못하였지만 상수시간에 못 푸리라 생각한 NP</li>
      <li>1,2, …, n번 물건 중 몇 개만 훔칠건데, 훔친 것들 무게의 합이 가방 용량보다는 같거나 작으면서 내가 훔쳤을 때 얻을 수 있는 이득의 총합</li>
    </ul>
  </li>
  <li>subset sum
    <ul>
      <li>양의 정수 n개가 있는데, n개 중 몇 개를 뽑을 건데 해당 조건을 만족하면서 뽑은 것들의 총 합이 주어진 조건보다 작거나 같으면서 뽑은 것들의 무게를 최대화하는것</li>
      <li>뽑은 것들의 무게의 합을 최대화 : $\Sigma_{i \in A} w_i$</li>
    </ul>
  </li>
  <li>뭐가 더 어려울까?
    <ul>
      <li>둘 다 아무도 n에 대해서 효율적인 알고리즘 (polynomial time)을 찾지 못했고 없다고 증명도 못했고 단지 없을 것이라고 생각함.</li>
    </ul>
  </li>
</ul>

<h1 id="polynomial-and-exponential-time-function">Polynomial and Exponential Time Function</h1>

<ul>
  <li>$n^k$까지가 Polynomial time - $2^n$ 은 exponential time</li>
  <li>polynomial solution이 존재하면 효율적인 알고리즘이 존재한다.</li>
</ul>

<p>intractable problem = hard problem</p>

<ul>
  <li>무궁무진하게 많으나 아무런 솔루션을 찾지 못했음</li>
</ul>

<p>polynomial</p>

<p>없다고 증명할 수 있으면 해라</p>

<p>효율적인 알고리즘을 못 찾았는데 - 내가 못해서 그런가보다</p>

<p>효율적인 알고리즘을 못 찾았는데 - 실제로 가능하지도 않다</p>

<p>효율적인 알고리즘을 못 찾았는데 - 그런데 알고 봤더니 이것이 np complete이다.</p>

<ul>
  <li>→ 그 많은 알고리즘 하는 사람이 못 찾았고 나도 못 찾았다.</li>
</ul>

<p>np complete, hard일 가능성이 큼</p>

<ul>
  <li>→ Approximation alg, Heuristic alg를 통해
    <ul>
      <li>최대화, 극대화해주지는 못하지만 그에 대한 근사치를 찾아주는, 그렇지만 효율적으로 polynomial time 안에 돌아가는 solution을 찾아주는 알고리즘</li>
    </ul>
  </li>
</ul>

<h1 id="다양한-문제들">다양한 문제들</h1>

<h2 id="hamiltonian-path">Hamiltonian Path</h2>

<ul>
  <li>가급적 지나간 곳은 지나가지 않는다.</li>
</ul>

<h2 id="longest-path">Longest path</h2>

<h1 id="how-do-you-bp">How do you BP~~</h1>

<p>&lt; 시험 무조건 나옴&gt;</p>

<h1 id="0-1-knapsack-problem">0-1 Knapsack Problem</h1>

<ul>
  <li>optimization 문제 : 0-1 knapsack, subset sum
    <ul>
      <li>무언가를 최대로 최적화하는 문제</li>
      <li>Ex. 훔친 물건의 무게, 가격, 가방의 용량 → 내 가방에 담을 수 있는 선에서 해당 profit을 maximize해주는 selection을 찾아라.</li>
    </ul>
  </li>
  <li>이에 대응되는 ‘Decision problem’
    <ul>
      <li>Ex. 훔친 물건의 무게, 가격, 가방의 용량, ‘T’</li>
      <li>T : decision problem이니까 답이 Yes or No로 나뉘어 나옴 : 이런 무게와 profit, W가 주어졌을 때 허용된 용량 안에서 물건을 훔치며 관련 주어진 T보다 큰 것이 가능한가가 문제
        <ul>
          <li>가방에 담으려하는데, 담은 가격의 합이 주어진 값 T보다 많을 수 있느냐 (Ex. 5000원보다 더 훔쳐올 수 있느냐)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>→ optimization이 어려움</li>
</ul>

<h1 id="subset-sum-problem">Subset Sum Problem</h1>

<ul>
  <li>Decision Problem
    <ul>
      <li>Given a set of positive integers ${s_1, s_2, … s_n}$ of size n and a positive integer T, does there exist a suset A of {1,2,…,n} such that $S_i = \Sigma_{i \in A} s_i$?</li>
      <li>훔칠 것들의 무게 s,</li>
      <li>이중에 몇 개를 뽑는다. 뽑은 것들의 합이 주어진 s와 같게 해줄 수 있느냐?
        <ul>
          <li>S라는 집합이 있고 T가 주어졌을 때, 몇 개를 뽑아 T값이 나오도록 하는 선택이 가능하냐 (T보다 더 많이 훔쳐낼 수 있냐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>knapsack이 조금 더 어렵다
    <ul>
      <li>$subset sum \leq_p 0-1 knapsack$ (polynomial time에 transform이 가능하다)</li>
      <li>Polynomial Reduction: from suset sum to 0-1 knapsack
        <ul>
          <li>0-1 knapsack만  polynomial time에 풀 수 있으면 subset sum도 풀 수 있다.</li>
        </ul>
      </li>
      <li>둘 다 정답 Yes or No</li>
    </ul>
  </li>
</ul>

<p>언제 n, s_1, s_2, ..n에서 합이 정답이 S가 나올까? 넘으면 Yes, 아니면 No</p>

<p>문제의 답이 No면 정답도 No를 출력해 줌.</p>

<p>해당 답을 가지고 transform을 통해 parameter를 만들어 냄 : n은 그대로 n으로 가고, w1..wn과 p1,,, pn을 만들어냄. 어떻게 하면 될까? →</p>

<p>n은 그대로 집어넣고,  s1_… sn은 w1…wn에 그대로 넣고 T값을 W, T에도 넣어줌</p>

<ul>
  <li>0-1 knapsack에서 w1, w2, .. wn - p1, p2, … pn → 뽑은 것들의 $\Sigma s_i \geq T, \Sigma s_i \leq T \rightarrow \Sigma s_i = T$</li>
  <li>이 중에 몇개를 뽑아서 합이 T가 되도록 하는 것이 가능하냐
    <ul>
      <li>문제를 transform : 언제 Yes를 출력할까? 우리가 이 문제에서 (가방 용량 허용하는 선에서 물건을 훔치는데 훔친 가격의 합이 T보다 크면 Yes.) (profit, 무게를 subset sum에서의 값으로 바꾸었으니까 $\Sigma s_i \geq T, \Sigma s_i \leq T \rightarrow \Sigma s_i = T$가 가능한가.</li>
    </ul>
  </li>
  <li>Transform
    <ul>
      <li>집어넣는 과정 : linear time에 가능</li>
    </ul>
  </li>
  <li>0-1 knapsack
    <ul>
      <li>Polynomial time</li>
    </ul>
  </li>
  <li>subset sum
    <ul>
      <li>0-1 knapsack으로 polynomial reduction으로 전환</li>
      <li>np hard라고 증명 = polynomial에 찾는 게 사실 말이 안됨
        <ul>
          <li>찾지도 못했고 없다고 증명도 못했고</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Fact 2읽어보기</p>

<ul>
  <li>knapsack을 polynomial에 대해 풀수 있으면 subset problem도 polynomial 시간안에
    <ul>
      <li>np complete : very hard</li>
      <li>polynomial solution을 찾아오던지, 없다고 증명하던지</li>
    </ul>
  </li>
</ul>

<p>$B,C  \in NP-Comlete$ 이면 $C \leq_p B \leq_p A$</p>

<p>Polynomial reduction을 해서 C도 NP Complete임을 증명 … 줄줄이 증명</p>

<ul>
  <li>→ 원조 문제 $X \leq_p … \leq_p B \leq_p A$
    <ul>
      <li>이미 알고 있던 np complete문제를 가지고 reduction : 태초에 문제가 하나 있어야 Polynomial reduction하여 np-complete</li>
      <li>Subset sum가지고 0-1 knapsack, …</li>
      <li>원조 문제는 무엇일까:
        <ul>
          <li>Proof by Cook</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CNF Conjunctive normal form
    <ul>
      <li>formula
        <ul>
          <li>$(p \lor q \lor s) \land (\bar q \lor r ) \land () \land () \land (\bar p \lor \bar s \lor \bar q)$</li>
          <li>or들의 and로 되어 있음</li>
          <li>신호니까 0 or 1이 input으로 들어감</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>SAT Satisfiability Problem
    <ul>
      <li>각각의 input에다가 0 or 1을 assign해서 CNF formula 결과가 true가 나오는 truth assignment가 존재하는가?</li>
      <li>실제 회로를 설계햇을 때 True로</li>
    </ul>
  </li>
  <li>3- SAT
    <ul>
      <li>CNF Formula에서 식을 3개로 제한하여 놓음 → polynomial 시간에 불가능</li>
      <li>모든 경우를 따져보면 $2^n, n!$ solution은 쉽게 나온다.</li>
    </ul>
  </li>
  <li>Cook’s Theorem
    <ul>
      <li>SAT 문제를 가지고 Clique \leq_p vertex cover \leq_p …  → NP Complete</li>
      <li>어려운 정도가 동등함 (증명되어 있음)</li>
      <li></li>
    </ul>
  </li>
  <li>NP Complete
    <ul>
      <li>이들을 모아둔 것이 ‘NP Complete’</li>
      <li>P : polynomial time algorithm 문제를 모두 모아둔 것</li>
      <li>NP Complete = $NP \cap NP Hard$
        <ul>
          <li>polynomial solution을 찾아오던지 or 없다고 증명하던지</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>BP</p>

<ul>
  <li>동영상에 넣어 출력하자</li>
</ul>

<p>Independent Set</p>

<ul>
  <li>알고 봤더니 1,2번이 싸웠더라 - 3,6,7은 3각관계라서 서로 마주치면 안된다 - 내일 파티를 하는데 싸운 애들은 나타나지 않게 한다. 모든 구성원과 서로의 관계를 줄 때, 최대로 인원을 뽑은 경우</li>
  <li>Ex.
    <ul>
      <li>1,4,5,6 → 싸우지 않은 괜찮은 사람들의 조합</li>
    </ul>
  </li>
  <li>sol : Exponential time algorithm</li>
</ul>

<p>→ 이런 문제들에 대해서 어덯게 대처할 것인가</p>

<ul>
  <li>Approximation Algorithm for BP : FFD Approach</li>
  <li>최대 solution은 못 찾지만 어느정도의 범위는 보장되는 알고리즘
    <ul>
      <li>애매한 89% 정도까지는 최적의 솔루션이 보장되는 polynomial time solution</li>
      <li>heuristic algorithm은 페이던스?케이던스라는 미국 회사에서 제공해주는 알고리즘 사용 (실제 반도체 회로에서의 유효성을 검증하기 위한 heuristic)</li>
    </ul>
  </li>
</ul>

<h1 id="bin-packing">Bin Packing</h1>

<p>Examples</p>

<ul>
  <li>제한된 용량의 CD에다 파일을 저장하는데, CD에다 굽고싶은 경우.</li>
  <li>2^n 알고리즘으로 쉽게 생각할 수 있음 → 그러나 np-hard로서 없을 것이라고 추정만 하는 상태</li>
</ul>

<h2 id="why-bp-is-a-hard-problem">why bp is a hard problem?</h2>

<ul>
  <li>
    <partition prob="">
</partition>
    <ul>
      <li>A의 부분집합인 A’과 A에서 A’ 뺀 차집합이 가능하냐 가능하지 않느냐.</li>
    </ul>
  </li>
  <li>if we have a polynomial time algorithm for the bin packing problem,
    <ul>
      <li>집합이 있을 때 이를 두 부분으로 나누어 각자 맞</li>
    </ul>
  </li>
  <li>$PARTITION \leq_p BP$
    <ul>
      <li>문제들 간 어떻게 연결이 되어있느냐 이해하기</li>
    </ul>
  </li>
</ul>

<h2 id="3-sat">3 SAT</h2>

<h2 id="vertex-cover-vc">Vertex Cover (VC)</h2>

<ul>
  <li>Vertex 와 Edge로 구성된 graph가 있을 때, 꼭짓점 중 몇 개를 뽑을 것인가 : 해당 graph의 어떤 edge를 가지고 와도 빨간 애가 항상 연결되어 있는 - 어떤 애를 가져와도 최소한 빨간 애가 항상 연결되어 있는 경우</li>
  <li>간단해 보이나 쉽지 않다 :
    <ul>
      <li>exponential alg르 푸는건 쉽지 않을 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="set-cover">Set Cover</h2>

<p>S라는 집합이 있는데, 그들의 부분집합이 존재한다. 그 m개의 부분집합에서 많아야 k개를 뽑아서 그들의 합집합이 S가 되게 함이 가능한가? → Yes or No</p>

<p>많아야 최대 k개까지 뽑아서 그들의 합집합이 S가 되게 하는 것이 가능한가?</p>

<ul>
  <li>Example</li>
  <li>$VC \leq_p SC$
undefined
$S = {S_1, S_2, … S_n}$</li>
</ul>

<p>NP, NP Complete</p>

<h1 id="alg-lps-1">[ALG] LPS (1)</h1>

<details>
  <summary>17</summary>


![0](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/0.png)



  </details>
<details>
  <summary>21</summary>


![1](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/1.png)


![2](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/2.png)


![3](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/3.png)


![4](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/4.png)



  </details>
<ol>
  <li>다음과 같은 문제를 고려하자.</li>
</ol>

<h1 id="17">17</h1>

<p>“NURSESRUN” 처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열을 회문 (palindrome)이라고 한다. 어떤 문자열의 부분 문자열은 원래의 문자열에서 일부 문자만 뽑아 순서를 유지하면서 나열한 문자열으로서, “ABDGI”는 “ABCDEFGHIJ”의 부분 문자열이다. 한 문자열의 부분 문자열 중 회문이면서 길이가 가장 긴 것을 Longest Palindromic Subsequence (LPS)라 한다 (예를 들어, “BBABCBCAB”의 LPS는 “BABCBAB” 임). 이제 주어진 문자열의 LPS를 찾는 문제를 생각하자.</p>

<p>입력 문자열 X[1],X[2], XOX1X2…X-1의 각 문자들이 배열 X[0], x[n-1] 에 저장되어 있다고 하자.조건0 ≤i≤j≤n-1을 만족하는 모든 i, j에 대해 L[i][j]를 X[i]에서 X[j]까지의 연속한 문자열, 즉 XiXi1Xi-2…Xj의 부분 문자열 중 가장 길이가 긴 회문의 길이를 나타낸다고 하자.</p>

<p>가. L[i][i] 값은 무엇인가?</p>

<p>→ L[i][i] = 1</p>

<p>나, i&lt;j인 모든 i, j에 대해 L[i][j] 값은 dynamicprogramming 기법의 원리를 고려하여 다음과 같이 구할 수 있다. 이때 빈칸에 들어갈 내용을 정확히 기술하라. (힌트: 주어진 문자열에 대해 가급적 앞에서나 뒤에서 문자를 한 개씩 제거하여 문제의 크기를 줄일 것)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
<span class="c1">//      L[i][j] = max(L[i+1][j], L[i][j-1]);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// X[i] == X[j]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">//          L[i][j] = L[i+1][j-1] + 2;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h1 id="21">21</h1>

<p>다음과 같은 Longest Palindromic Subsequence 문제를 고려하자.</p>

<p>“NURSESRUN” 처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열을 회문 (palindrome)이라고 한다. 어’떤 문자열의 부분 문자열은 원래의 문자열에서 일부 문자만 뽑아 순서를 유지하면서 나열한 문자열으로서, “ABDGI”는 “ABCDEFGHIJ”의 부분 문자열이다. 한 문자열의 부분 문자열 중 회문이면서 길이가 가장 긴 것을 Longest Palindromic Subsequence (LPS)라 한다(예를 들어, “BBABCBCAB” 의 LPS는 “BABCBAB” 임). 이제 주어진 문자열의 LPS를 찾는 문제를 생각하자.</p>

<p>입력 문자열 X0X1X2…X-1의 각 문자들이 배열 X[0], X[1], X[2], …, x[n-1] 에 저장되어 있다고 하자. 조건 0≤i≤j≤n-1 을 만족하는 모든 i, j에 대해 L[i][j]를X[i]에서 X[j]까지의 연속한 문자열, 즉 XiXi+1Xi+2…X의 부분 문자열 중 가장 길이가 긴 회문의 길이를 나타낸다고 하자. 이제 다음과 같은 코드에 대하여 dynamic programming 기법에 기반을 두어 위 문제를 해결해주는 두 함수 Fillup_L_M_Tables()와 Print_LPS()를 구현하려고 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="cp">#define L(i, j) *(T_L+ (j)-(i))*n - ((j)-(i)-1)*((j)-(i))/2+i)
#define M(i, j) *(T_M+ (j)-(i))*n - ((j)-(i)-1)*((j)-(i))/2+i)
</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">T_L</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">lps</span><span class="p">,</span> <span class="o">*</span><span class="n">T_M</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Find_LPS</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T_L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">T_M</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">lps</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">Fillup_L_M_Tables</span><span class="p">();</span>
    <span class="n">Print_LPS</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input_O.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)))</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error in reading the file %s. Wn"</span><span class="p">,</span> <span class="s">"input_0.txt"</span><span class="p">);</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">WO</span><span class="err">'</span><span class="p">;</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"^^^Input size is %d.Wn"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"^^^Input sequence is %s. WnWn"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">Find_LPS</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>먼저 함수 Fillup_L_M_Tables()의 구현을 보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'L': remove left end, 'R': remove right</span>
<span class="c1">// 'B': remove both ends, 'U': use it</span>
<span class="kt">void</span> <span class="nf">Fillup_L_M_Tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">가</span><span class="p">);</span>
        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'U'</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>

                <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">나</span><span class="p">);</span>
                <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'B'</span><span class="p">;</span>

                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'R'</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">dist</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="n">dist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dist</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">다</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">라</span><span class="p">);</span>
                        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'R'</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">마</span><span class="p">);</span>
                        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'L'</span><span class="o">:</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>가. (6점)이 코드의 Li,i)는 L[i][i]를 나타내는데, (가)에 부분에 들어갈 값은 무엇인지 그 이유는 무엇인지 설명하라.</p>

<p>나. (6점)다음 (나)에 부분에 들어갈 값을 기술하라.</p>

<p>다. (8점)이 코드의 문맥을 볼 때 (다)에 부분에 들어갈 문자는 무엇인지 기술하라.</p>

<p>라. (12점)이 코드의 문맥을 볼 때 (라)와 (마)에 부분에 들어갈 내용을 C/C++ 문법에 맞게 정확히 기술하라.</p>

<p>다음 함수 Print_LPS()의 구현을 보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Print_LPS</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"The length of a LCS is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
            <span class="p">(</span><span class="err">바</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'L'</span><span class="p">:</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'U'</span><span class="p">:</span>
            <span class="n">lps</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="err">사</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">kk</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">kk</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">kk</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">kk</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">lps</span><span class="p">[</span><span class="mi">2</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"***The found LPS is %s.WnWn"</span><span class="p">,</span> <span class="n">lps</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>마. (8점)이 코드의 문맥상 (바)에 부분에 들어갈 내용을 C/C++ 언어 문법에 맞게 정확히 기술하라.</p>

<p>바. (8점)이 코드의 문맥상 (사)에 부분에 들어갈 내용을 C/C++ 언어 문법에 맞게 정확히 기술하라.</p>

<p>사. (8점) 다음과 같은 내용의 입력 파일에 대하여.</p>

<p>9</p>

<p>BBABCBCAB</p>

<p>이 프로그램 수행 결과 구한 L 테이블의 내용은 다음과 같다.</p>

<p><img src="/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/5.png" alt="5" /></p>

<p>이때 L[1][8] 값을 구하는데 필요했던 L 테이블의 원소 L[x][y]의 인덱스를 기술하라.</p>

<p>(주의: 답은 (1, 8)-&gt; (2, 4)와 같이 기술하며, 두 개 이상의 원소가 필요하였다면 각 원소의 인덱스를 기술할 것)</p>

<p>아. (8점) (위 문제에 이어서) 이때 L[1][7] 값을 구하는데 필요했던 L 테이블의 원소 L[x][y]의 인덱스를 기술하라. (주의: 답은 (1, 7) -&gt; (2, 4)와 같이 기술하며, 두 개 이상의 원소가 필요하였다면 각 원소의 인덱스를 기술할 것)</p>

<p>자. (15점) 동일한 내용의 입력 파일에 대하여, 이 프로그램 수행 결과 구한 M 테이블의 내용은 아래와 같다.</p>

<p><img src="/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/6.png" alt="6" /></p>

<p>이때 Print_LPS() 함수의 while 문장에서 Ips[] 배열을 구축하는 과정에서 방문한 이 테이블의 인덱스는 다음과 같은데 아래의 빈칸을 메꾸어라.</p>

<p>(0, 8)-&gt; (?, ?) -&gt; (?, ?)-&gt; (?, ?)-&gt; (?, ?) -&gt; (4,4)</p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] Huffman (1)]]></summary></entry><entry><title type="html">[ALG] 4.2. DP Application</title><link href="http://localhost:4000/ALG-4.2.-DP-Application" rel="alternate" type="text/html" title="[ALG] 4.2. DP Application" /><published>2022-09-29T00:00:00+09:00</published><updated>2022-09-29T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.2.-DP-Application</id><content type="html" xml:base="http://localhost:4000/ALG-4.2.-DP-Application"><![CDATA[<h1 id="alg-45-응용1-longest-common-subsequence-lcs-1">[ALG] 4.5. [응용1] Longest Common Subsequence (LCS) (1)</h1>

<h1 id="longest-common-subsequences-lcs">Longest Common Subsequences LCS</h1>

<blockquote>
  <p>💡 공동으로 갖는 common subsequence의 길이가 얼마나 긴가</p>
</blockquote>

<ul>
  <li><strong>[T. Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009. 16.3]</strong></li>
  <li>Definitions
    <ul>
      <li>Given a sequence $X = &lt;x_1, x_2, …, xm &gt;$ another sequence $Z = &lt;z_1, z_2, …, zk &gt;$ is a <strong>subsequence</strong> of X if there exists a strictly increasing sequence $&lt;i_1, i_2, …, i_k &gt;$ of indices of <em>X</em> such that $\forall j = 1, 2, …, k$, we have $x_{ij} = z_j$
        <ul>
          <li>A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out.</li>
          <li>sequence : 나열한 것 / subsequence : 해당 sequence에서 순서를 유지하며 뽑아낸 형태
            <ul>
              <li>Ex. ABCDEFGHI → ABD, AEFGH, AFI, … 등이 있다.
                <ul>
                  <li>(단, 앞에서부터가 아니라 순서가 뒤바뀐 IHE, BIDEHF 와 같은 문자열은 부분 문자열이 될 수 없다)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>empty sequence : 0개의 element로 구성된 것</li>
          <li>Ex: $\ X=&lt;A,B,C,B,D,A,B&gt;, \ Z=&lt;B,C,D,B&gt;(&lt;2,3,5,7&gt;)$
undefined	- Given two sequences <em>X</em> and <em>Y</em>, we say that a sequence <em>Z</em> is a <strong>common subsequence</strong> of <em>X</em> and <em>Y</em> if <em>Z</em> is a subsequence of both <em>X</em> and <em>Y</em>.</li>
          <li>
            <p>Ex:</p>

            <p>$X = &lt;A, B, C, B, D, A, B&gt;, \ Y = &lt;B, D, C, A, B, A&gt;,\ Z_1 = &lt;B, C, A&gt;,\ Z_2 = &lt;B, C, B, A&gt;,\ Z_3 = &lt;B, D, A, B&gt;$</p>
          </li>
        </ul>
      </li>
      <li>Given a sequence $X = &lt;x_1, x_2, …, x_m &gt;, X_i = &lt;x_1, x_2, …, x_i &gt;$ is the ith <strong>prefix</strong> of <em>X</em>, for $i = 0, 1, …, m$
        <ul>
          <li>prefix 접두사 :
            <ul>
              <li>sequence가 있을 때 앞에서 네개 뽑은 X4가 prefix of sequence</li>
            </ul>
          </li>
          <li>Ex: $X = &lt;A, B, C, B, D, A, B&gt;, \ X_4 = &lt;A, B, C, B&gt;,\ X_0 =$null sequence</li>
          <li>empty vs null : 두 용어 모두 같은 맥락으로 활용됨
undefined- Problem</li>
        </ul>
      </li>
      <li>생물 DNA 염기서열 : 얼마나 둘이 유사한가 비교한다
        <ul>
          <li>metric 정의 : 문제에 따라서, 상황에 따라서 어떻게 결정하느냐에 따라서 알고리즘을 만들어 문제를 해결한다.</li>
          <li>Longest common subsequence를 찾아서, 얼마나 긴가 확인하는 문제</li>
        </ul>
      </li>
      <li>Given two sequences $X = &lt;x_1, x_2, …, x_m &gt;$ and $Y = &lt;y_1, y_2, …, y_n &gt;$
        <ul>
          <li>m, n만큼의 두 개 sequence가 주어졌을 때 가장 긴 common sequence를 찾아서 얼마나 긴가를 가지고 판단할 것이다.</li>
        </ul>
      </li>
      <li>
        <p>find a <strong>longest common subsequence</strong> of <em>X</em> and <em>Y</em>.</p>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/0.png" alt="0" /></p>

        <ul>
          <li>optimal substructure : 어떻게든지 문제 하나 사이즈를 조금씩 줄여서, optimal solution을 찾는다. 가장 긴 것 - maximization problem와 일맥 상통</li>
          <li>problem input size : $(m,n)$
            <ul>
              <li>m : X sequence의 길이, n : Y Sequence의 길이</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Naïve approach
    <ul>
      <li>x의 모든 Subsequence에 대하여 y의 subsequence인지 확인</li>
      <li>Enumerate all subsequences of X and check each subsequence to see if it is also a subsequence of Y, keeping track of the longest subsequence found.
        <ul>
          <li>→ Exponential algorithm!
            <ul>
              <li>$\Theta(n \cdot 2^m)$ :  x의 원소개수 m, y 원소개수 n
                <ul>
                  <li>$2^m$ : x의 모든 Subsequence 개수</li>
                  <li>$\Theta(n)$ : n개의 Element check time</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>The LCS problem can be solved efficiently using dynamic programming.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 중요한 내용 !!</p>
</blockquote>

<ul>
  <li><strong>Optimal substructure of the LCS</strong>
    <ul>
      <li>Let $X = &lt;x_1, x_2, …, x_m &gt;$ and $Y = &lt;y_1, y_2, …, y_n &gt;$ be sequences, and let $Z = &lt;z_1, z_2, …, z_k &gt;$ be any LCS of <em>X</em> and <em>Y</em>.
        <ol>
          <li>If $x_m = y_n$, then $z_k = x_m = y_n$, and $Z_{k-1}$ is an LCS of $X_{m-1}, Y_{n-1}$</li>
          <li>If $x_m \neq y_n$, then an LCS of <em>X</em> and <em>Y</em> is
            <ol>
              <li>either an LCS of $X_{m-1}$ and <em>Y</em></li>
              <li>or an LCS of <em>X</em> and $Y_{n-1}$
       - → pink the longer sequence!</li>
            </ol>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>앞의 것을 하나 빼던지, 뒤에서 하나 빼던지, 앞 뒤에서 각각 하나 빼던지</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![1](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/1.png)
</code></pre></div></div>

<ul>
  <li>Let <em>c</em>[<em>i</em>,<em>j</em>] be the length of an LCS of the sequences <em>Xi</em> and <em>Yj</em></li>
  <li>Optimal substructure for computing $c[i, j]$
    <ul>
      <li>base case : 0 (empty sequence)</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/2.png" alt="2" /></p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">==</span><span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">else</span> 
    <span class="n">retrun</span> <span class="nf">max</span><span class="p">(</span><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="451omnalgorithm">4.5.1. $O(mn)$ Algorithm</h2>

<ul>
  <li>Filling the table
    <ul>
      <li>b, c table 계산 : $\Theta(mn)$</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/3.png" alt="3" /></p>
  </li>
  <li>Printing the LCS
    <ul>
      <li>$\Theta(m+n)$</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/4.png" alt="4" /></p>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/5.png" alt="5" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/6.png" alt="6" /></p>

<h2 id="452-c-implementation">4.5.2. C Implementation</h2>

<ul>
  <li>
    <p>Courtesy of <a href="http://www.bioalgorithms.info/downloads/code/">link</a></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/** Copyright (C) 2005 Neil Jones. **/</span>
  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="kt">char</span> <span class="o">*</span><span class="nf">LCS</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
  <span class="cp">#define NEITHER 0
</span>  <span class="cp">#define UP 1
</span>  <span class="cp">#define LEFT 2
</span>  <span class="cp">#define UP_AND_LEFT 3
</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
  <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">LCS</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
  <span class="p">}</span>
	
  <span class="kt">char</span> <span class="o">*</span><span class="nf">LCS</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
      <span class="kt">int</span> <span class="o">**</span><span class="n">S</span><span class="p">;</span>
      <span class="kt">int</span> <span class="o">**</span><span class="n">R</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">lcs</span><span class="p">;</span>
	
      <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
      <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
          <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">jj</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">jj</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP_AND_LEFT</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span>
              <span class="p">{</span>
	
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">NEITHER</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span><span class="p">];</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>
              <span class="p">}</span>
	
              <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
	
      <span class="n">ii</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">jj</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">];</span>
      <span class="n">lcs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
      <span class="n">lcs</span><span class="p">[</span><span class="n">pos</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
	
      <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">jj</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">UP_AND_LEFT</span><span class="p">)</span>
          <span class="p">{</span>
	
              <span class="n">ii</span><span class="o">--</span><span class="p">;</span>
              <span class="n">jj</span><span class="o">--</span><span class="p">;</span>
	
              <span class="n">lcs</span><span class="p">[</span><span class="n">pos</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">UP</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ii</span><span class="o">--</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">LEFT</span><span class="p">)</span>
          <span class="p">{</span>
	
              <span class="n">jj</span><span class="o">--</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">]);</span>
          <span class="n">free</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]);</span>
      <span class="p">}</span>
	
      <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">lcs</span><span class="p">;</span>
  <span class="p">}</span>
	
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-46-응용2-the-gapped-alignment-problem-1">[ALG] 4.6. [응용2] The Gapped Alignment Problem (1)</h1>

<h1 id="gapped-alignment-problem">Gapped Alignment Problem</h1>

<ul>
  <li>Problem
    <ul>
      <li>Given two sequences, find a gapped alignment that maximize the score!</li>
      <li>Compare two sequences if they are similar (related).</li>
      <li>Gapped alignment
        <ul>
          <li>Example:
            <ul>
              <li>실험을 하다보면 불완전하기 때문에 Gap을 넣는 것을 허용하고 align하자.</li>
              <li>수치적으로 얼마나 유사한지 밝히기 : mismatch가 일어나면 안되니까</li>
              <li>
                <p>Gap에 대해서는 penalty를 크게 준다</p>

                <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/7.png" alt="7" /></p>
              </li>
            </ul>
          </li>
          <li>A possible alignment scoring scheme
            <ul>
              <li>Ex: match score = 2, mismatch penalty = -1, gap penalty = -2</li>
              <li>이러한 점수 기준으 들어갔을 때, 점수를 최대화해주는 Gap Alignment를 찾아라
                <ul>
                  <li>Ex. 각각 Gap을 집어넣으면 1점, 7점인데 이러한 점수를 최대화해주는 Gap 정렬방법 찾기</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/8.png" alt="8" /></p>
      </li>
      <li>
        <p>case : 위치를 일치시키고 / A에다 Gap을 집어넣어 정렬/ B에다 Gap을 집어넣어 정렬</p>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/9.png" alt="9" /></p>
      </li>
    </ul>
  </li>
  <li>경우에 따라 문제 사이즈 줄이기
    <ul>
      <li>$A = a_1 a_2 a_3 … a_m$, $B = b_1 b_2 b_3 … b_m$</li>
      <li>recursive한 구조 구축 : 제일 끝 부분의 character가 $a_i b_j$</li>
      <li>두 sequence의 가장 끈 부분을 어떻게 처리할 것인가</li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/10.png" alt="10" /></p>
      </li>
      <li>$S(i, j)$ : maximize했을 때의 score</li>
      <li>basis :
        <ul>
          <li>$i=0$ → b의 길이에다가 -2배</li>
          <li>$j=0 $ → a의 길이에다가 -2배</li>
        </ul>
      </li>
      <li>a쪽에다가 gap을 집어넣을 수밖에 없다.</li>
      <li>$S(i,j-1)-2 $
        <ul>
          <li>Gap을 넣어 - 이점 받고 b i-1로 maximize하자</li>
        </ul>
      </li>
      <li>$S(i-1,j)-2$
        <ul>
          <li>Gap을 넣어 - 이점 받고 a i-1로 maximize하자</li>
        </ul>
      </li>
      <li>$s(a_i, b_j) $
        <ul>
          <li>a_i, b_j 넣었을 때 나오는 score</li>
          <li>같으면 2점, mismatch하면 -1점, gap penalty -2점</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DP
    <ul>
      <li>recursive top down이면 답을 못보고 문제 작은 것부터 차근차근 풀어내면 얻어낼 수 있음</li>
      <li>table 구성, 초기화, table fill 을 통해 큰 문제의 정답 찾기,
        <ul>
          <li>어디에다가 Gap을 넣어 정보를 정렬할 것인지 : 점수 table이 필요하고, maximum 구했을 때 max(S, S,S)에서 정보를 취했는지 저장하고 어디에 몇번째에 gap을 저장했는지 출력하기</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="alg-47-응용3-longest-increasing-subsequence-lis-1">[ALG] 4.7. [응용3] Longest Increasing Subsequence (LIS) (1)</h1>

<h1 id="problem">Problem</h1>

<ul>
  <li>Given a sequence $A=(a[0], a[1],…,a[n-1])$, find the length of the longest subsequence such that all elements of the subsequence are sorted increasing order.
    <ul>
      <li>순서를 유지한 subsequence : 값이 증가하는 속성을 가진</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>$(10, 22, 9, 33, 21, 50, 41, 60, 80)→(10, 22, 33, 50, 60, 80)$
        <ul>
          <li>(22, 9, 50, 41)은 increasing subsequence가 아님</li>
          <li>80으로 끝나는 LIS</li>
          <li>→ 직전으로 끝나는게 60이었고, 다시 60으로 끝나는 LIS</li>
          <li>→ ..</li>
        </ul>
      </li>
      <li>$(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)\→(0, 2, 6, 9, 11, 15), \(0, 4, 6, 9, 11, 15) …$</li>
    </ul>
  </li>
  <li>Algorithm
    <ul>
      <li>Let $d[i]$ be the length of the LIS that ends in the element at index <em>i</em>. Then, the answer to the LIS problem is the maximum value of $d[i], i=0,1,…,n-1$
        <ul>
          <li>(a[1], a[2] … a[i]) 까지만 생각했을 때 a[i]로 끝나는 LIS 를 생각해보자</li>
        </ul>
      </li>
      <li>increasing subsequence중 가장 길이가 긴 것을 찾아라</li>
    </ul>
  </li>
</ul>

<h1 id="optimal-substructure">Optimal substructure</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$$
d[i] = \max(1, \max_{j=0,...,n-1/ a[j]&lt;a[i]}{(d[j]+1)})
$$


$i=0,1,..., n-1$

- 가장 큰 것 : 그 길이가 가장 긴 것이 좋음
- d[i] : 5로 끝나는 longest increasing subsequence의 길이로 정의 → 각각의 위치에서 해당하는 d[i]의 길이를 정의한 다음 maximum을 취한다. 모든 d[i]를 구해 maximum을 구하는데 그 lis 길이 구하기
- $(0, 8, 4, 12, 2, 10, 6, 14, 1, 9)$
	- a[i]로 끝나는 lis의 바로 전에 오는 애가 되려면 1은 9보다 값이 작아야 함.
	- 나보다 앞에있는 애들 중에 나보다 작은 애들만 고려해야 함 : 9로 끝나는 LIS가 있을 때 바로 앞에 있는 애는
	- 거기에 있는 애들 중에 나보다 값이 작은 애들이 그 앞에 올 대상이 되어야 함
		- 9보다 작은 0, 8, 4, 2, 6, 1
		- ~~~ 4, 9 / ~~~~ 0, 9 / ~~~ 1, 9
		- 복잡해 보이지만 경우의 수를 찾다보면 자연스럽게 나오는 과정
	- recursive하게 1로 끝나는 LIS를 계산한 다음, 1을 더해 위치를 옮기면 9로 끝나는 위치가 됨. - base step : 1
- d[i]를 i=0~n-1에서 계산하는데 max(d[j]+1)을 계산하기 위한 for loop - table 구성
- 2dim table을 많이 봤지만 이 문제에서는 1dim table로 정의
- 1 dim table 원소 n개 : d[0] - d[1] - … d[n-1] - 알고리즘의 시간복잡도 추정
- 각각의 d[i]에 대해서 값을 계산할 것인데, table을 채울 time complexity는 input size n
- $O(n^2)$
- 나보다 작은 아이들가지고 훑기 : a[i]보다 작은 애들을 가지고 훑음. 그럼 해당 element의 비용은 나보다 앞에 잇는 애들이고 모든 element에 대해서 계산하는 것이므로 - code

```c
int LIS(int *a, int N)
{

    int *best, *prev, i, j, max = 0;

    best = (int *)malloc(sizeof(int) * N);
    prev = (int *)malloc(sizeof(int) * N);
    for (i = 0; i &lt; N; i++)
        best[i] = 1, prev[i] = i;

    for (i = 1; i &lt; N; i++)
        for (j = 0; j &lt; i; j++)
            if (a[i] &gt; a[j] &amp;&amp; best[i] &lt; best[j] + 1)
                best[i] = best[j] + 1, prev[i] = j;
    for (i = 0; i &lt; N; i++)
        if (max &lt; best[i])
            max = best[i];

		// Print the LIS using prev[] here. 
		free( best ); 
		free( prev );
		return max;
}
```
</code></pre></div></div>

<ul>
  <li>best array
    <ul>
      <li>= d table</li>
    </ul>
  </li>
  <li>prev array
    <ul>
      <li>= e table : 같은 size</li>
      <li>찾아가는 table</li>
      <li>LIS의 길이가 얼마인가 출력</li>
    </ul>
  </li>
  <li>주어진 input sequence가 있을 때, 길이가 같은데 서로 다른게 있을 수 있음
    <ul>
      <li>같은 길이인데 서로 다른 increasing sequence</li>
      <li>→ unique하진 않더라도, 분명히 최소 하나는 존재한다.</li>
    </ul>
  </li>
</ul>

<p>LIS의 직전의 element를 찾아가면 해당 나머지 subsequence에서 optimal substructure를 찾아라. 지금까지 한 거랑은 약간 달라서 확 와닿지 않겠지만 반복적으로 이해해보자</p>

<h1 id="minimal-triangulation">Minimal Triangulation</h1>

<ul>
  <li><strong>[A. Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983. 10.2]</strong></li>
  <li>Problem
    <ul>
      <li>Given a set of <em>n</em> vertices for <strong>convex</strong> polygon, find a triangulation such that no two chords cross each other, and the total length of the chords selected is a minimum.</li>
    </ul>
  </li>
  <li>
    <p>Counting all possible selections of chords in an inefficient way results in an exponential algorithm.</p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/11.png" alt="11" /></p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/12.png" alt="12" /></p>
  </li>
</ul>

<h1 id="alg-48-응용4-the-0-1-knapsack-problem-1">[ALG] 4.8. [응용4] The 0-1 Knapsack Problem (1)</h1>

<ul>
  <li>Problem
    <ul>
      <li>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \leq W$
        <ul>
          <li>이러한 index 집합의 부분집합을 선택하라, 이 중에 몇 개를 뽑아라</li>
          <li>$\Sigma_{i \in A} p_i$ 을 최대화하면서,  $\Sigma_{i \in A} w_i \leq W$의 조건 만족
            <ul>
              <li>훔친 물건들의 무게를 가방이 허용해야 하고, 조건 하에 물건을 훔쳐서 벌 수 있는 물건들의 가격들을 maximize</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>${w_1, w_2, …, w_n}$ - 0-1 : binary - 훔치지 않을 것인지, 훔칠 것인지</li>
      <li>${p_1, p_2, …, p_n}$ - 선택할 것인지, 말 것인지</li>
      <li>fractional : 물건을 훔칠 것인지 안 훔칠 것인지</li>
    </ul>
  </li>
  <li></li>
</ul>

<p>문제가 이해가 되지 않는다면 이해한 후 다시 들어볼 것을 추천.</p>

<ul>
  <li>Example
    <ul>
      <li>${w_1, w_2, …, w_5} = {6,5,10,3,4}$
        <ul>
          <li>1, 2, 5 weight의 합은 15</li>
        </ul>
      </li>
      <li>${p_1, p_2, …, p_5} = {9,7,11,6,8}, W=15$</li>
      <li>$\rightarrow {1,2,5}$
        <ul>
          <li>각각 1번, 2번, .. , 5번 부분집합을 선택하면 1,2,5 뽑힌것의 w합은</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>An intuitive interpretation
    <ul>
      <li>There are <em>n</em> items in a store. 가 게에 N개의 물건이 있는데</li>
      <li>The <em>i</em> th item weighs <em>wi</em> kilograms and is worth <em>pi</em> wons, where <em>wi</em> and <em>pi</em> are positive integers.
        <ul>
          <li>i번째 물건은 Wi kg이고 Pi원이다.</li>
        </ul>
      </li>
      <li>A thief has a knapsack that can carry at most <em>W</em> kilograms, where <em>W</em> is a positive integer.
        <ul>
          <li>도둑이 W까지만 담을 수 있는 배낭을 가지고 왔다.</li>
        </ul>
      </li>
      <li>What items should the thief take to maximize his “profit”?
        <ul>
          <li>최대한 이윤을 얻을 수 있게 물건을 훔치는 방법</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="0-a-0-1-knapsack-problem-in-real-life">0. A 0-1 Knapsack Problem in Real Life</h1>

<p><a href="http://standardwisdom.com/softwarejournal/2010/03/bang-for-the-buck-knapsacks-in-real-life/">ref</a></p>

<ul>
  <li>Problem
    <ul>
      <li>
        <p>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \leq W$</p>

        <p>각각의 다른 value, weight를 갖는 item 여러 개기 있다. knapsack은 W kg까지 수용 가능할때, knapsack에 담을 최대 value는 얼마인가</p>
      </li>
      <li>You have a marketing budget of 5 million dollars. (500만 불이라는 홍보비)</li>
      <li>You have the following marketing options and their paybacks in new potential customers:</li>
    </ul>
  </li>
  <li>Which marketing campaigns would you choose to <strong>maximize the total expected reach</strong> under the condition that, for each of these marketing campaigns, you either select it or you don’t?
    <ul>
      <li>많은 사람들에게 노출</li>
      <li>내가 지불한 비용의 합이 500만보다 작거나 같게 : 1,2,3, …, N번</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/13.png" alt="13" /></p>

<ul>
  <li>cost (dollar) - expected reach (people)
    <ul>
      <li>노출되는 사람들의 수</li>
    </ul>
  </li>
</ul>

<h1 id="1-how-to-solve-the-0-1-knapsack-problem">1. How to Solve the 0-1 Knapsack Problem</h1>

<ul>
  <li>Naïve approach
    <ul>
      <li>There are $2^n$ subsets of ${1, 2, …, n}!$</li>
      <li>아이템중에 선택할 수 있는 모든 경우의 수는 2^n : 각 경우에 대해서 profit들의 합이 제일 큰 것 선택</li>
      <li>모든 경우를 따져보는 경우 - 순서대로 넣을지 말지를 결정하기 때문에</li>
    </ul>
  </li>
  <li>Dynamic programming approach
    <ul>
      <li>Let $P(i,w)$ be the <strong>maximized profit</strong> obtained when choosing items *<em>only from the first ii</em> items under the restriction that <strong>the total weight cannot exceed w</strong><em><strong>w</strong></em>.
        <ul>
          <li>parameter 2개 :
            <ul>
              <li>i : 1번부터 2번, 3번, … i번까지만 앞의 i개 item중에 선택</li>
              <li>w : 현재 남은 가방의 허용하는 무게 - 나한테 남은 가방의 용량이 w만큼 남았다.</li>
            </ul>
          </li>
          <li>1번부터 i번까지 선택한 것들 중 weight 합이 W보다 같거나 작게 하는 조건에서 최대 profit의 값</li>
        </ul>
      </li>
      <li>If we let <em>A</em>∗ be an optimal subset of ${1, 2, …, n}$
        <ol>
          <li>$n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$
            <ol>
              <li>dynamic programming 내용 집어넣기 : 인자 두개를 집어넣어서 문제 사이즈를 줄여야 함</li>
              <li>이 값을 계산해야하는데, 값을 선택했을 때 profit들의 합을 maximize
                <ul>
                  <li>선택 각각가장 미지막 i번 의 무게
      - 분명히 값을 maximize하는 최적의 선택이 있는데, 가장 마지막의 n번 Item을 선택하던지 안하던지
      - $P(n,W)$ : n번 물체를 선택했다면</li>
                  <li>$p_n $ : n번 item의 Profit이 더해지고</li>
                  <li>$P(n-1, W-w_n)$ :
                    <ul>
                      <li>나머지 상황에서 maximize : 고려할 Item은 n-1개, 최대 W까지 담을 수 있는데 wn을 뺀 남은 용량</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ol>
          </li>
          <li>$n \notin A* : P(n,W) = P(n-1, W)$
            <ol>
              <li>n번 물체는 선택하면 안 되니까 P(n-1,W)</li>
              <li>recursion : 같은 형태로 표현하는데 문제 사이즈가 작아짐
                <ol>
                  <li>n번 item을 선택하든지, 말든지 + 한 물체에 대해서 나머지 item을 고려</li>
                  <li>(작아진 문제 사이즈) recursive formulation</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Optimal substructure
        <ul>
          <li>$P(i,w)=$
            <ul>
              <li>임의의 i : 0부터 n까지 간다
                <ul>
                  <li>0 : 내가 선택할 수 있는 item이 하나도 없을 때</li>
                  <li>i : 내가 선택할 수 있는 item이 1번부터 i번까지 앞의 i개
                    <ul>
                      <li>i=3 →1,2,3중에 선택할 수 있다.</li>
                      <li>i=0 → 선택할 아이템이 없다</li>
                    </ul>
                  </li>
                  <li>w: 남은 용량 - 0부터 대문자 W까지, 대문자 W는 아직 아무것도 안들어갔을 때</li>
                </ul>
              </li>
              <li>
                <table>
                  <tbody>
                    <tr>
                      <td>0 if $i=0</td>
                      <td> </td>
                      <td>w = 0$</td>
                    </tr>
                  </tbody>
                </table>
                <ul>
                  <li>선택할 아이템이 없다</li>
                  <li>or 가방에 담을 수 없다 (용량이 0)</li>
                </ul>
              </li>
              <li>$P(i−1,w)$
                <ul>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>if $i&gt;0</td>
                          <td> </td>
                          <td>w_i &gt;w$</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                  <li>가장 마지막 물건의 무게인 w_i가 w보다 무거운 경우 자격 미달 (담을 수 없음)</li>
                  <li>i개 물체까지 선택하는 것에 대해서 마지막 것을 선택할것인지
                    <ul>
                      <li>남아있는 가방 무게에 대해서 : I번째 물체는 선택할 요건이 안된다</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>$\max {(P(i-1,w), p_i+P(i-1,w-w_i))}$
                <ul>
                  <li>I&gt;0 : 1,2,…i번 item 중에 선택
                    <ul>
                      <li>i번째 item을 담지 않을 경우 i-1개중에 잘 선택한 ,</li>
                      <li>p_i를 얻고 나머지 i-1개에 대해서 맨 마지막 item을 제외한 무게</li>
                    </ul>
                  </li>
                  <li>담을 수 있는데, 안 담을건지 vs 담을 것인지에 대한 차이
                    <ul>
                      <li>요건은 되는데 i번째 물품을 선택하지 않는게 좋다</li>
                      <li>i번 Item을 선택하는 게 이윤 극대화에 더 좋다.</li>
                    </ul>
                  </li>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>$i&gt;0</td>
                          <td> </td>
                          <td>w_i \geq w$</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>i : 0~4</li>
      <li>w : 0~W(6)</li>
      <li>${w_1, w_2, …, w_4} = {4,3,2,3}$</li>
      <li>${p_1, p_2, …, p_4} = {3,2,4,4}, W=6$</li>
      <li>어떤 순으로 방문해서 채울 것인가
        <ul>
          <li>값을 계산하는데 필요한 게 얼마나 많은지</li>
          <li>i가 하나 빠지고, 하나를 계산하기 위해서는 위에 것이 계산되면 됨
            <ul>
              <li>i-1의 식이 핵심적으로 작용하니까</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/14.png" alt="14" /></p>

<ul>
  <li>0부터 N까지 : 첫 번째 행과 열은 다 0으로 setting하고 좌에서 우로 가면서 setting</li>
  <li>Ex.
    <ul>
      <li>$P(2,4) = \max{(P(1,4), p_2 + P(1, 4-w_2))} = \max{(P(1,4), 2+P(1,1))}=3$
        <ul>
          <li>2 : 1,2중에 선택함, 2번을 담을 자격이 되는지, 안 되는지</li>
          <li>w2=3이니까 가방 용량에는 4니까 담을 수 있음 → (iii)</li>
          <li>P(1,4) : 2번 물체를 담지 않으면 값이 더 커질 것이다
            <ul>
              <li>P(2,4) 위의 줄 : 3</li>
            </ul>
          </li>
          <li>p2+ : 2번을 담겠다 + 2번을 담을 경우 1번을 선택하는 상황에서 w2를 제외한 것 = P(1,1)
            <ul>
              <li>P(1,1) = 3</li>
              <li>P_2 = 2</li>
            </ul>
          </li>
          <li>2번을 담지 않겠다.</li>
        </ul>
      </li>
      <li>$P(4,2) = P(3,2) = 4$
        <ul>
          <li>1,2,3,4중에 선택하는 것인데 4번은 선택할지말지 optimal substructure 중 선택</li>
          <li>남아있는 용량 2 : 4번은 고려 대상도 아님 → 4번은 빼버리고 1,2,3중에 선택하자</li>
        </ul>
      </li>
      <li>$P(3,5) = \max{(P(2,5), p_3 + P(2,5-w_3))} = 6$
        <ul>
          <li>3번 Item의 Weight가 2이니까 담을 수는 있는데 진짜 담을 것인지, 안 담을건지</li>
          <li>p3 =4, P(2, 5-w3) = P(2,3) = 2이므로 6</li>
          <li>두 개중에 뒤에 것이 크다 : 3번을 선택할 것이다라는 의미</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="3-how-to-reconstruct-the-solution">3. How to Reconstruct the Solution</h1>

<ul>
  <li>${w_1, w_2, …, w_4} = {4,3,2,3}$</li>
  <li>${p_1, p_2, …, p_4} = {3,2,4,4}, W=6$</li>
</ul>

<p>i번째 item을 선택할 자격도 안됨 : Weight가 더 큰 경우</p>

<p>i번째 item을 선택할 자격은 되지만: 비교</p>

<ul>
  <li>$P(4,6) = \max{(P(3,6), p_4 + P(3, 6-w_4))} = 8$
    <ul>
      <li>4번의 weight가 3이기 때문에 선택할 자격은 됨 → 4번 선택</li>
      <li>이러한 계산을 통해서 8이 나옴</li>
    </ul>
  </li>
  <li>$P(3,3) = \max{(P(2,3), p_3 + P(2, 3-w_3))} = 4$
    <ul>
      <li>3번의 item은 Weight=2라서 선택할수 있음</li>
      <li>P(2,3-2) = P(2,1) = P(1,1) = P(0,1) = 0 → i는 한 칸씩 올라가면서 선택했는지 아닌지에 대한 번호를 출력함</li>
    </ul>
  </li>
  <li>$P(2,1) = P(1,1) = 0$
    <ul>
      <li>2 X</li>
    </ul>
  </li>
  <li>$P(1,1) = P(0,1) = 0$
    <ul>
      <li>1 X</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/15.png" alt="15" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/16.png" alt="16" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/17.png" alt="17" /></p>

<h1 id="4-implementation-and-time-complexity">4. Implementation and Time Complexity</h1>

<ul>
  <li>
    <p>$O(nW)$ Time</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">zero_one_knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ww</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ww</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">ww</span><span class="o">++</span><span class="p">)</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">ww</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ww</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">ww</span><span class="o">++</span><span class="p">)</span> <span class="c1">//bottleneck - W번 수행</span>
          <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ww</span><span class="p">)</span>
              <span class="p">{</span>
                  <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
   <span class="o">&gt;</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">])</span>
                      <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                  <span class="k">else</span>
                      <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">W</span><span class="p">];</span>
  <span class="p">}</span>
	
	
</code></pre></div>    </div>

    <ul>
      <li>어떤 값이 상수인지 아닌지의 판단 근거는 N이 커지건 작아지건 고정되는게 상수</li>
      <li>지금 time complexity가 nW가 됨은 명확한데 이는 linear time인가?
        <ul>
          <li>table 하나당 $\Theta (1)$씩 계산</li>
          <li>$(n+1) (w+1)$ table : $\Theta(nw)$</li>
          <li>최종 solution은 table 맨 밑 행부터 하나씩 탐색 : $\Theta (n)$</li>
          <li>→ Theta(nw)</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5-0-1-knapsack-ex-1n--6-w--10n6w10">5. 0-1 Knapsack Ex. 1: n = 6, W = 10<em>n</em>=6,<em>W</em>=10</h1>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/18.png" alt="18" /></p>

<ul>
  <li>쫓아가는 방법 생각해보기</li>
  <li>Selected items: i = 2, 3, 4, 6</li>
  <li>Obtained profit: 19</li>
  <li>Is the time-complexity $O(nW)$ an efficient one?
    <ul>
      <li>efficient : polynomial 시간에 bound 될 때 효율적.
        <ul>
          <li>inefficient : exponential, factorial, // n^4, n^3은 비효율적 practical하게</li>
        </ul>
      </li>
      <li>This is not a linear-time algorithm!
        <ul>
          <li>variable :
            <ul>
              <li>n : 도둑이 물건을 훔칠 때 훔칠 수 있는 물건 개수</li>
              <li>W: 도둑의 가방이 허용하는 가방의 총 용량</li>
            </ul>
          </li>
          <li>→ N에 대해서 상수라면,w를 제거하면 이 알고리즘은 linear time - polynomial이므로 효율적
            <ul>
              <li>n의 크기가 얼마든지 커져도 w가 불변?</li>
              <li>n과 w는 독립적 : w가 n에 대해서 bound가 되어야 하는데, 여기서는 독립적이라고 볼 수 있다. N도 w도 문제 상황에 따라 지정된다.</li>
            </ul>
          </li>
          <li>A problem is that <em>W</em> is not bounded with respect to <em>n</em>.
            <ul>
              <li>Ex. What if <em>n</em>=20 and <em>W</em>=20!? → $O(n∗n!)$
                <ul>
                  <li>factorial time algorithm : 더 비효율적으로 만들 수 있음.</li>
                </ul>
              </li>
              <li>When <em>W</em> is extremely large in comparison with <em>n</em>, this algorithm is worse than the brute-force algorithm that simply considers all subsets.
                <ul>
                  <li>n에 대해서도 linear, w에 대해서도 linear. n에 대해서 Polynomial하지 않다.</li>
                </ul>
              </li>
              <li>This algorithm can be improved so that the worst-case number of entries computed is $O(2^n)$</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>No one has ever found an algorithm for the 0-1 Knapsack problem whose worst-case time complexity is better than exponential, yet no one has proven that such an algorithm is not possible!
        <ul>
          <li>polynomial time alg 는 얻지도 못했고, 증명도 못함</li>
          <li>문제 size n에 대해서 증명도 찾지도 못함 — 아마 Polynomial solution이 없을 것이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>np complete, np hard, …
    <ul>
      <li>아무도 증명하지 못한 문제</li>
      <li>n의 몇승이라는 poly sol도 못 찾았고,</li>
    </ul>
  </li>
</ul>

<h1 id="6-a-variation-of-the-0-1-knapsack-problem">6. A Variation of the 0-1 Knapsack Problem</h1>

<ul>
  <li>Problem
    <ul>
      <li>Decision Problem</li>
      <li>Given <em>n</em> items of length $l_1, l_2, …, l_n$, is there a subset of these items with total length exactly <em>L</em>?
undefined- Example</li>
      <li>${ 1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993 }, \ L = 138457{1,2,7,14,49,98,343,686,2409,2793,16808,17206,117705,117993},L=138457 → {1, 2, 7, 98, 343, 686, 2409, 17206, 117705}{1,2,7,98,343,686,2409,17206,117705}$</li>
    </ul>
  </li>
  <li>Dynamic programming approach
    <ul>
      <li>Let $P(i,w)$ be the <strong>maximized profit</strong> obtained when choosing items *<em>only from the first ii</em> items under the restriction that <strong>the total weight cannot exceed w</strong><em><strong>w</strong></em>.
undefined	- If we let <em>A</em>∗ be an optimal subset of ${1, 2, …, n}$
        <ol>
          <li>$n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$</li>
          <li>$n \notin A* : P(n,W) = P(n-1, W)$
            <ul>
              <li>$\rightarrow fill (i, j)$</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h1 id="7-a-divide-and-conquer-approach">7. A Divide-and-Conquer Approach</h1>

<ul>
  <li>
    <p>Let <code class="language-plaintext highlighter-rouge">fill(i,j)</code> return TRUE ⟺ ∃ subset of the first <em>i</em> items that has total length <em>j</em>.</p>

    <p>When <code class="language-plaintext highlighter-rouge">fill(i,j)</code> returns TRUE,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1. If the ith item is used, `fill(i - 1, j -` _`li`_`)` must return TRUE.
  2. If the ith item is not used, `fill(i - 1, j)` must return TRUE.
</code></pre></div>    </div>
  </li>
  <li>
    <p>To solve <code class="language-plaintext highlighter-rouge">fill(int n, int L)</code>,</p>
    <ul>
      <li>$T(n)≥c $if $n=0$</li>
      <li>$T(n) \geq 2T(n-1) +d$ if $n&gt;0$</li>
      <li>$\rightarrow T(n) = \Theta(2^n)$</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fill</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// l[i]: global variable </span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-dynamic-programming-approach">A Dynamic Programming Approach</h2>

<ul>
  <li>The optimal substructure :
    <ul>
      <li>F(i,j)=<em>F</em>(<em>i</em>,<em>j</em>)= <code class="language-plaintext highlighter-rouge">FALSE</code> if <em>i</em>=0,<em>j</em>!=0</li>
      <li>F(i,j)=<em>F</em>(<em>i</em>,<em>j</em>)= <code class="language-plaintext highlighter-rouge">TRUE</code> if <em>i</em>=0,<em>j</em>=0</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$F(i,j)= F(i-1,j)</td>
              <td> </td>
              <td>((l_i \geq j)</td>
              <td> </td>
              <td>F(i-1, j-l_i))$ if <em>i</em>&gt;0</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>O(nL) time implementation</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ll</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ll</span><span class="o">++</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ll</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ll</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ll</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="err">–</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">||</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ll</span><span class="o">-</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">L</span><span class="p">]);</span>
	
	
</code></pre></div>    </div>
  </li>
  <li>
    <p>Example</p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/19.png" alt="19" /></p>
  </li>
</ul>

<h1 id="8-subset-sum">8. Subset Sum</h1>

<p>n에 대해서 polynomial sol도 찾지 못함</p>

<ul>
  <li>Problem
    <ul>
      <li>Given a set of positive integers ${w_1, w_2, …, w_n}$ of size <em>n</em> and a postivie integer <em>W</em>, Find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i\in A}{w_i}$ subject to $\Sigma_{i\in A}{w_i} \leq W$</li>
      <li>양의 정수 n개, 어떤 양의 정수 W가 주어졌을 때 몇 개를 뽑을 것이다. a라는 집합이 뽑은 애들의 index 집합이다. 뽑은 애들의 합을 maximize하라.</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>${w_1, …, w_9} = {20,30,14,70,40,50,15,25,80,60,10,95}, W=99 \\rightarrow {20,14,40,25}$</li>
    </ul>
  </li>
  <li>Application
    <ul>
      <li>There are <em>n</em> jobs, each of which takes <em>wi</em> time.</li>
      <li>Now we have a CPU with <em>W</em> free cycles, and want to choose the set of jobs that minimizes the number of idle cycles.
        <ul>
          <li>w cycle동안에 내가 scheduling해 주어 CPU를 잘 활용해야 한다.</li>
          <li>여러 user들이 들어왔을 때, w1 cycle만큼 소요되고, 2번 user에서 들어오면 w2만큼의 cycle이 필요하고 … n번 user에서 job을 scheduling하면 wn cycle이 필요함</li>
          <li>system을 가장 최적으로 활용하기 위해, w1,, wn 중 몇 개를 뽑아서 scheduling 진행할 것</li>
          <li>뽑은 애들의 합이 W보다 작으면서 maximize : 몇번, 몇번, 몇번 해서 끝에 무수리가 남을 것인데 이 곳에서는 CPU가 idle하는 cycle 발생 : minimize가 목표</li>
        </ul>
      </li>
      <li>→ CPU Cycle이라는 귀한 resource를 낭비하지 않도록 minimize하자</li>
      <li>논외) exact algorithm는 아무도 풀지 못했다. → approximation algorithm, heuristic algorithm</li>
    </ul>
  </li>
  <li>Relation to the 0-1 Knapsack problem
    <ul>
      <li>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \geq W$</li>
      <li>⟺
        <ul>
          <li>Given a set of positive integers ${w_1, w_2, …, w_n}$ of size <em>n</em> and a postivie integer <em>W</em>, Find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i\in A}{w_i}$ subject to $\Sigma_{i\in A}{w_i} \geq W$</li>
        </ul>
      </li>
      <li>0-1 knapsack을 polynomial time에 풀 수 있으면, subset sum도 풀 수 있다</li>
    </ul>
  </li>
  <li>참고
    <ul>
      <li>If it is possible to solve the <strong>0-1 knapsack</strong> problem in <strong>polynomial time</strong>, the <strong>subset sum</strong> problem can be solved in <strong>polynomial time</strong> too.</li>
      <li>Somebody has already proven that the subset sum problem is very hard.</li>
      <li>In other words, the subset sum problem is <strong>NP</strong>complete. → Hence, the 0-1 knapsack problem is also a very hard problem. In other words, the 0-1 knapsack problem is also <strong>NP</strong>complete.
undefined</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] 4.5. [응용1] Longest Common Subsequence (LCS) (1)]]></summary></entry><entry><title type="html">[ALG] 4.1. DP - Concepts</title><link href="http://localhost:4000/ALG-4.1.-DP-Concepts" rel="alternate" type="text/html" title="[ALG] 4.1. DP - Concepts" /><published>2022-09-28T00:00:00+09:00</published><updated>2022-09-28T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.1.-DP---Concepts</id><content type="html" xml:base="http://localhost:4000/ALG-4.1.-DP-Concepts"><![CDATA[<ul>
  <li>divide and conquer: top - down
    <ul>
      <li>효율적이기도 하나 매우 비효율적이 되기도 함</li>
      <li>splitted된 사례들이 서로 관련 없는 문제를 풀때 잘 통함</li>
    </ul>
  </li>
  <li>dynamic programming : bottom -up
    <ul>
      <li>아래에서 위로 올라가며 효율을 추구하자는 방식</li>
    </ul>
  </li>
  <li>NOW
    <ul>
      <li>Divide-and-Conquer Method</li>
      <li><strong>Dynamic Programming Method</strong></li>
      <li>Greedy Method</li>
      <li>Backtracking Method</li>
      <li>Local Search Method</li>
      <li>Branch-and-Bound Method</li>
      <li>Etc.</li>
    </ul>
  </li>
  <li>From <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Wikipedia</a>: Dynamic programming is both a
    <ul>
      <li><u>mathematical optimization method and a computer programming method.</u></li>
    </ul>
  </li>
  <li>A complicated problem is <strong>broken down into simpler sub-problems in a recursive manner</strong>.</li>
  <li>Overlapping subproblems
    <ul>
      <li>A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.</li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.</li>
    </ul>
  </li>
  <li>When applicable, the method <u>**takes far less time than other methods**</u> that don’t take advantage of the subproblem overlap <strong>like the divide- and-conquer technique</strong>.</li>
</ul>

<p>→ 문제 몇개 풀어보고, 이 고상한 말들이 별 것 아닌 자연스러운 원리임을 체득하자!</p>

<h1 id="alg-42-approaches-for-recursive-formulation-1">[ALG] 4.2. Approaches for Recursive Formulation (1)</h1>

<p>Two Approaches for Recursive Formulation</p>

<ul>
  <li>Top Down Approach</li>
  <li>Bototm up Approach</li>
</ul>

<h2 id="421-top-down-approach">4.2.1. Top Down Approach</h2>

<ul>
  <li>$T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j \geq 1$</li>
  <li>$T(i,0) = T(0,j) = 1$ for $i,j≥0$</li>
  <li>recursive하게 똑같이 문제 두개를 푼다 : 빨간 것 하나, 녹색 하나. 그리고 그 결과를 combine하여 원래 문제를 푼다. 문제가 겹치는게 보인다.
    <ul>
      <li>divide and conquer : 상당히 많이 overlap됨을 확인할 수 있다.</li>
      <li>undefined- Easily becomes exponential!</li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/0.png" alt="0" /></p>
  </li>
</ul>

<p>recursive function call : 내려갔다 올라갔다 depth first search하다가 하염없이 돌아오는 것을 의미한다.</p>

<h2 id="422-bottom-up-approach">4.2.2. Bottom Up Approach</h2>

<ul>
  <li>$T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j≥1$</li>
  <li>$T(i,0) = T(0,j) = 1$ for $i,j \geq 0$</li>
  <li>
    <p>Often much more efficient!</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/1.png" alt="1" /></p>
  </li>
  <li>그러나 bottom up은 Top Down과 대비하여 쭉 쭉 쭉 한 줄로 내려가며 잘 풀리게 된다.
    <ul>
      <li>bottom up으로 올라오면서, 그리고 모든 경우에 divide n conquer에 비효율적이고 dp가 효율적인건 아니다.</li>
    </ul>
  </li>
  <li>Bottom up vs. Top down 공통: 둘다 어떤 문제가 재귀적인, recursive한 형태로 문제가 풀리게 된다.
    <ul>
      <li>작게 똑같이 풀어서 합치자 : recursion 한 solution이 나타나게 된다</li>
      <li>solution을 만드는데 재귀적으로 나타난다.</li>
    </ul>
  </li>
  <li>몇 개 안 되는 것을 풀면 되는데, 똑같은것을 반복적으로 보나?
    <ul>
      <li>이를 계산하는 프로그램: 이를 풀기 위해서 필요한 것은 왼쪽 하부, 오른쪽 하부</li>
      <li>거꾸로 생각해보면 : 왼쪽 아래 + 오른쪽 아래 활용해서 그 위 가운데 노드를 구할 수 있다. (아래에서 위로)</li>
    </ul>
  </li>
  <li>아무리 부정하려고 하더라도 인정할 수밖에 없는 원리.</li>
</ul>

<h2 id="423-examples">4.2.3. Examples</h2>

<h3 id="4231-ex1-world-series-odds">4.2.3.1. [ex1] World Series Odds</h3>

<ul>
  <li>Problem
    <ul>
      <li>Dodgers and Yankees are playing the World Series in which either team needs to win <em>n</em> games first.</li>
      <li>Suppose that each team has a $50%$ % chance of winning any game.</li>
      <li>Let <em>P</em>(<em>i</em>,<em>j</em>) be the probability that if Dodgers needs <em>i</em> games to win, and Yankees needs <em>j</em> games, Dodgers will eventually win the Series.
        <ul>
          <li>i번을 더 이겨야 다저스는 우승할 수 있구 양키스는 세번 이기는데 이 때 다져스기 우승할 확률은
  ?</li>
        </ul>
      </li>
      <li>Ex: $P(2, 3) = \frac {11}{16}$야
        <ul>
          <li>키스는 두번, 다저스는 3번</li>
        </ul>
      </li>
      <li>
        <p>Compute $P(i,j) 0≤i,j≤n ∀n$</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/2.png" alt="2" /></p>

        <ul>
          <li>임의의 n에 대해서 확률을 계산하라 : 그림을 보고, recursion 구조가 떠오르는가?
            <ul>
              <li>문제 사이즈 $( i,j) = (i-1,j) + (i, j-1)$</li>
              <li>0.5, 0.5 : dodgers이거나 yankees인데 dodgers가 이기면 $(i-1,j)$</li>
              <li>조건부 확률 : $P(i,j) = 0.5 P(i-1,j) + 0.5P(i, j-1)$ rl기본적인수식</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/3.png" alt="3" /></p>

<h3 id="4232-worse-a-divide-and-conquer-approach">4.2.3.2. [Worse] A Divide-and-Conquer Approach</h3>

<ul>
  <li>Recursive formulation
    <ul>
      <li>$P(i,j) =1 if i=0,j&gt;0$</li>
      <li>$P(i,j) =0 if i=0,j=0$</li>
      <li>
        <p>$P(i,j)= \frac{P(i-1,j)+P(i,j-1)}{2}=2P(i−1,j)+P(i,j−1)$</p>

        <p>if $i&gt;0, j&gt;0$</p>
      </li>
    </ul>
  </li>
  <li>overlap subproblem : overlapping하지 않으면서 size가 줄었던 dnc와 달리 overlapping된다. 굉장히 안 좋은 상황. 그래서 이를 recursive fn call 함수를 짜서 $P(100,100), P(50,50)$짜보라
    <ul>
      <li>→ 사실 돌려지지도 않는다. 시간이 너무 걸려 컴퓨터가 죽어버린다.</li>
    </ul>
  </li>
  <li>If we solve this recurrence relation in the divide-and-conquer way,
    <ul>
      <li>Let <em>T</em>(<em>n</em>) be the maximum time taken by a call to <em>P</em>(<em>i</em>),where <em>i</em>+<em>j</em> =<em>n</em>.</li>
      <li>Then we can prove that <em>T</em>(<em>n</em>) is exponential!</li>
      <li>$T(1)=1, T(n) = 2T(n-1) + c \rightarrow O(2^n)$</li>
    </ul>
  </li>
  <li>What is the problem of this approach?</li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/4.png" alt="4" /></p>

<h3 id="4323-better-a-dynamic-programming-approach">4.3.2.3. [Better] A Dynamic Programming Approach</h3>

<ul>
  <li>핵심 개념 Table
    <ul>
      <li>1D, 2D, 3D</li>
    </ul>
  </li>
  <li>$T(4,4) $: table setup 후 이를 채워나가서 (fill)
    <ul>
      <li>단ㄷ순하게 생각하면 2 중 for loop 활용하여 진행한다.</li>
      <li>0,0은 양쪽 다 우승한 것이기에 고려할 필요 없다.</li>
    </ul>
  </li>
  <li>한칸 여펴 왼쪽에 있는 애와, 한칸 아래 밑쪽에 잇는 애를 통해 계싼할 수 있다.</li>
  <li>$P(i,j) = 1 $ if $i=0, j&gt;0$</li>
  <li>$P(i,j) = 0$ if $i&gt;0, j=0$</li>
  <li>$P(i,j) = \frac{P(i-1,j) + P(i, j-1)}{2}$ if $i&gt;0, j&gt;0$</li>
  <li>fill 하는 방식
    <ul>
      <li>좌→우 (밑에서 위로): 가능</li>
      <li>밑→위 (좌에서 위로) : 가능</li>
      <li>기존의 플로우는 대각선 우상향이기때문에 가능!</li>
      <li>기교를 부리고 싶으면 ㄹor loop을 복잡하게 해서 구현할 순 있다.
        <ul>
          <li>그러나 단순하면서 잘 작동하는것이 더 중요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$T(n,n) = O(n^2)$d임을 바로 확인해야한다.
    <ul>
      <li>table 원소가 가로 n, 세로 n일 때</li>
      <li>n+1, n+1개가 있고</li>
      <li>상수시간이므로 시간 복잡도는 n자승이 된다. → 시간복잡도는</li>
    </ul>
  </li>
  <li>Instead of computing the same repeatedly, fill in a table as suggested below:
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/5.png" alt="5" /></p>
      </li>
    </ul>
  </li>
  <li>Time Complexity
    <ul>
      <li>For input size $(m, n)$, computing $P(m, n)$ takes $O(mn)$-time.</li>
      <li>
        <p>By far better than the Divide-and-Conquer approach.</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/6.png" alt="6" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>undefined
<img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/7.png" alt="7" /></p>

<ul>
  <li>DP 문제를 푸는데 이러한 recursive structure가 존재하고, 이를 divide and conquer 로 top down으로 풀어야 한다면 overlapping subproblem의 문제가발생한다.
    <ul>
      <li>상당한 양의 문제가 있다 : divide and conquer로 가지 말고 dp로 가는건 어떨까?</li>
      <li>어떤 문제를 subproblem을 통해 recursive하게 풀려 하는데 문제가 어떻게 풀리더라: dnc가 아니라 bottom up 방식으로 풀도록 생각하고</li>
      <li>table을 1차-3ㅏ차원으로 구성하고, 초기화하고, 일반화된 공식으로부터 fill 하느 방식을 알아 원소를 채워 나간다</li>
    </ul>
  </li>
  <li>각각의 subproblem
    <ul>
      <li>문제를 각각 한 번씩만 푼다 : bottom up 방식으로 table을 채워나가서 목적을 달성하는 것 : DP의 시작과 끝이다</li>
      <li>overlapping substructure 등 복잡한 거 생각할 필요 없이, 이것이 전부!</li>
    </ul>
  </li>
</ul>

<h1 id="alg-43-concepts-of-dynamic-programming-1">[ALG] 4.3. Concepts of Dynamic Programming (1)</h1>

<h1 id="dynamic-programming">Dynamic Programming</h1>

<blockquote>
  <p>Top-down → Bottom-up</p>
</blockquote>

<ul>
  <li>When the <strong>divide-and-conquer</strong> approach produces an <strong>exponential algorithm</strong> where <strong>the same sub-problems are solved iteratively</strong>,
    <ul>
      <li>Take the recursive relation from the divide-and-conquer algorithm, and</li>
      <li>replace <strong>the recursive calls with table lookups</strong> by recording a value in a table entry instead of returning it.</li>
    </ul>
  </li>
  <li>master theorem과도 연계
    <ul>
      <li>overlapping 나쁜거 (a&gt;c)</li>
    </ul>
  </li>
  <li>Three elements to consider in designing a dynamic programming algorithm
    <ul>
      <li>Recursive relation
        <ul>
          <li>Optimal substructure</li>
        </ul>
      </li>
      <li>Table setup</li>
      <li>Table fill order</li>
      <li>$B(i,j)=B(i-1,j-1) + B(i-1,j)$ if $0&lt;j&lt;i$</li>
      <li>$B(i,j)=1$ if $j=0$ or $j=i$</li>
    </ul>
  </li>
  <li>[Neapolitan] DP Procedure
    <ul>
      <li>input case에 대해 solution을 계산하는 recursive property 세우기</li>
      <li>작은 input case부터 먼저 해결하는 bottom up을 통한 전체 Input에 대해 Solution 구축</li>
    </ul>
  </li>
</ul>

<h1 id="application-of-dp">Application of DP</h1>

<h1 id="431-the-manhattan-tourist-problem">4.3.1. The Manhattan Tourist Problem</h1>

<ul>
  <li>
    <p>Courtesy of [Jones &amp; Pevzner 6.3]</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Problem:</p>
    <ul>
      <li>Given two street corners in the borough of Manhattan in New York City, find the path between them with the maximum number of attractions, that is, a path of maximum overall weight.</li>
      <li>Assume that a tourist may <u>**move either to east or to south only**</u></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>🏝️ 어떻게 하면 많은 관광지를을 최대로 방문할 수 있겠는가?</p>
</blockquote>

<ul>
  <li>(1) A <u>brute force</u> approach
    <ul>
      <li>모든 경로 다 따져보기 : 몇개 나올까? 각각 n, m칸이라고 할때(세로, 가로)
        <ul>
          <li>이를 따져보면 : $2^n, 2^m, n!, m!$이 나온다 → 모든 경우를 따지면 exponential, factorial time이 나오기에 풀 수 없다.</li>
        </ul>
      </li>
      <li>Search among all paths in the grid for the longest path!</li>
      <li>n이 조금 커도 알 수 있다.</li>
    </ul>
  </li>
  <li>(2) A greedy approach
    <ul>
      <li>다음 강의 주제</li>
    </ul>
  </li>
  <li><u>A formal description of this problem</u>
    <ul>
      <li>Given a weighted graph (grid) <em>G</em> of size (<em>n</em>,<em>m</em>) with two distinguished vertices, a source (0,0) and a sink (<em>n</em>,<em>m</em>), <u>**find a longest path between them**</u> in its weighted graph. (0,0)
        <ul>
          <li>find ‘a’ : 하나만 찾기</li>
        </ul>
      </li>
      <li>graph : vertex-vertex 간 관계를 나타내주는 edge로 edge는 directional/nondirectional일 수 있다
        <ul>
          <li>undirected / directed edge : arc
            <ul>
              <li>directed graph : digraph</li>
              <li>edge에 방향성이 있는가 없는가는 vertex 관계를 나타낸다.</li>
              <li>directed : ex. a는 b를 좋아하고, b는 c를 좋아하고,, : 방향성 존재</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>weighted : 각 edge에 값이 잇는경우</li>
      <li>→ weighted digraph</li>
    </ul>
  </li>
  <li>
    <p>원래 문제에 대해서 두 개의 subproblem 으로 푸는 것</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/9.png" alt="9" /></p>
  </li>
  <li>경로는 달라도 길이는 같은 longest path는 존재할 수 있다.
    <ul>
      <li>둘중에 하나로 출발하거나 도착함
        <ul>
          <li>1) 아래로 출발하거나</li>
          <li>2) 오른쪽으로 출발하거나</li>
        </ul>
      </li>
      <li>알고리즘을 어떻게 생각해냈을까에 대하여 접근해보자!</li>
      <li>둘 중에 하나인데, 오른쪽에서 오는 것이 최종 longest path라면
        <ul>
          <li>(4,4) 까지 이르는 방법에는 (4,3) - (3,4)이므로 각각에 대한 ㅣongest path를 구해보면 된다</li>
          <li>→ divide and conquer로 풀이</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>생각의 흐름
    <ul>
      <li>divide and conquer를 썼을 때, overlapping subproblem을 활용햇기에 worse 됨</li>
      <li>recursive top-down 이면 똑같은 식으로 (4,2) 혹은 (3,3)의 형태의 longest path를 찾아야 한다</li>
      <li>→ 심각해지는 overlapping problem</li>
    </ul>
  </li>
  <li>solution : DP (bottom up)
    <ul>
      <li>0,0 에서 4,3 에 이르기까지의 문제를 한 번씩만 풀고 밑에서부터 위로 올라가자.</li>
    </ul>
  </li>
  <li>divide and conquer의 overlapping subproblem으로 상당히 매칭
    <ul>
      <li>top down: overlapping subproblem → 상당히 많이 겹치는 포인트</li>
      <li>bottom up : 서로 서로를 계싼하며 결괏값 산출</li>
    </ul>
  </li>
  <li>An example grid of size (4,4)
    <ul>
      <li>
        <p>GRID : 특수한 형태의 격자처럼 생긴 graph</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/10.png" alt="10" /></p>
      </li>
    </ul>
  </li>
  <li>shortest path가 아닌 longest path 문제
    <ul>
      <li>DP 문제와 어떤 관계가 있을까?</li>
      <li>recursive solution이 보이는가?</li>
    </ul>
  </li>
  <li>A possible selection determined by a greedy approach</li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/11.png" alt="11" /></p>

<ul>
  <li><u>**Basic idea**</u>
    <ul>
      <li>How can you use the solutions of smaller problems to build a solution of a problem?
        <ul>
          <li>

            <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/12.png" alt="12" /></p>
          </li>
        </ul>
      </li>
      <li>$s_{i,j} = \max{s_{i-1,j}+ w_{i,j} , }$</li>
      <li>directed edge = arc</li>
      <li>위에서 i,j로 내려올 때의 weight,</li>
      <li>왼쪽에서 i,j로 올 때의 weight</li>
      <li>A given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
        <ul>
          <li>최적화 문제
            <ul>
              <li>리턴값을 최대로 해 주는 solution을 찾아라,</li>
              <li>solution을 극대화해주는/극소화해주는 solution을 찾아라</li>
            </ul>
          </li>
          <li>최적화가 아니나 DP를 활용
            <ul>
              <li>다저스 문제 : 최적화 문제가 아니지만 DP를 사용함</li>
            </ul>
          </li>
          <li>최적의 solution을 얻기 위해 문제를 풀어감</li>
          <li>→ optimal substructure</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/13.png" alt="13" /></p>

<ul>
  <li>Optimal substructure : $S_{n,m} =?$
    <ol>
      <li>$i,j \geq 1$
        <ul>
          <li>$S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$</li>
        </ul>
      </li>
      <li>$i=0, j=1,2,…,n$
        <ul>
          <li>$S_{0,j} = S_{0,j-1}+W({(0,j-1)},{(0,j)})$</li>
        </ul>
      </li>
      <li>$j=0, i=1,2,…,m$
        <ul>
          <li>$S_{i,0} = S_{i-1,0}+W({(i-1,0)},{(i,0)})$</li>
        </ul>
      </li>
      <li>$i=j=0$
        <ul>
          <li>$S_{0,0} = 0$</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>💡 Induction, Base step에 관한 것들도 정확하게 기술해주어야 함.</p>
</blockquote>

<ul>
  <li>Table setup and fill
    <ul>
      <li>맨 위, 맨 옆 line에서는 unique한 path cost가 나옴</li>
      <li>divide and conquer = top down → 큰 문제부터 작은 문제로 (merge sort : 큰 것을 반으로 반으로 쪼개가며 merge) ↔ DP</li>
      <li>정보의 흐름 : 내 값을 계산하기 위해서 j 인덱스가 작은 것, i 인덱스가 작은 것을 계산해두면 됨</li>
      <li>각각의 Node가 subproblem을 나타낸다.</li>
      <li>어떻게 각각의 원소를 채울 것인가: 한 원소 값을 계산하기 위해서는 나보다 왼쪽에 있는 애와 위쪽에 잇는 애의 값을 알고 있어야 함.</li>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/14.png" alt="14" /></p>
      </li>
    </ul>
  </li>
  <li>Pseudocode
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/15.png" alt="15" /></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">MANHATTANTOURIST</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
		
		
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Given a (<em>n</em>,<em>m</em>) grid, what is the time complexity T(n, m)?
undefined- So far, we have found the <strong>cost of the longest path</strong> from source to each vertex in the grid.</li>
  <li>길이가 34인 longest path는 어떻게 출력할 수 있을까?
    <ul>
      <li>조금만 더 노력하면 longest path 길이 + 대각선 까지의 거리를 출력할 수 있는 정보를 추출해낼수 있음</li>
      <li>알고리즘에서 정보를 더 끄집어 낼 수 있는 부분 :
        <ul>
          <li>$S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$
            <ul>
              <li>둘 중에 큰 것을 선택하는 statement</li>
              <li>왼쩍 것이 더 크다면 → 위에서부터 내려온 것</li>
              <li>오른쪽 것이 더 크다면 → 왼쪽에서 내려온 것</li>
            </ul>
          </li>
          <li>optimal substructure와 연관
            <ul>
              <li>나의 optimal solution은 나보다 작은 subproblem들의 optimal solution을 통해 출력</li>
              <li>거기서로부터 수식이 나타난다:이를 program화하여 각 table 원소를 계산할 때 선택됨에 따라서 각 또 다른 table 하나를 기록해두면 +1, -1 등을 줄줄 쫓아가면 됨</li>
            </ul>
          </li>
          <li>recursion : 굉장히 compact하게 표현해주는 좋은 방식
            <ul>
              <li>물론 overlapping subproblem의 경우 개념을 compact하게 햐해주지만 조심하면서 써야지 안 복잡해짐</li>
            </ul>
          </li>
          <li>최종 것까지 가는 길 : (-1→ 1) + (이전 노드까지의 최단거리)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time complexity
    <ul>
      <li>Input size (m,n)</li>
      <li>Time Complexity : O(mn)
        <ul>
          <li>각 노드마다 계산하는데 걸리는 상수시간</li>
          <li>node의 복잡도가 시간 복잡도</li>
        </ul>
      </li>
      <li>Space Complexity : O(mn)
        <ul>
          <li>50.50으로 divide and conquer하면, 과연 실행의 끝을 볼 수 있을가 모르겠다!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Then, how can you print out the <strong>actual optimal path</strong> from source to sink?
undefined
      <img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/16.png" alt="16" /></li>
</ul>

<h1 id="432-chained-matrix-multiplication">4.3.2. Chained Matrix Multiplication</h1>

<p>[Neapolitan 3.4] dp의 대표적인 문제</p>

<ul>
  <li>In general, to multiply an <em>a</em> x <em>b</em> matrix with a <em>b</em> x <em>c</em> matrix using the standard method, it is necessary to do <em>abc</em> elementary multiplications.
    <ul>
      <li>a<em>b, b</em>c 행렬을 곱하면 a<em>c 행렬이 나오는데 가장 단순하게 연산하면 a</em>b*c만큼의 곱셈이 수행</li>
      <li>matrix multplication
        <ul>
          <li>$A_1 \times A_2 \times … \times A_n$
            <ul>
              <li>1번, 2번 곱셈, … n-1번 곱 : 누구를 제일 마지막에 연산할것인가?</li>
              <li>최소비용으로 곱한 다음 곱하는 데 활용된 비용을 더하면 결과 비용
                <ul>
                  <li>3번 이전 + 3번 이후</li>
                </ul>
              </li>
              <li>이 중에 제일 작은 것을 선택한다.</li>
              <li>matrix multiplication에는 결합법칙 성립 : 어떤 것을 먼저 곱해도 상관 없으나 비용이 달라짐</li>
            </ul>
          </li>
          <li>$A_i = d_{i-1} \times d_i$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/17.png" alt="17" /></p>

<ul>
  <li>Problem
    <ul>
      <li>Determine the minimum number of elementary multiplications, needed to multiply $n$ matrices where $A_i \in R^{d_{i-1} \times d_i}$</li>
      <li>optimal substructure를 통해 최적의 solution을 도출</li>
    </ul>
  </li>
  <li>Examples:  $A_1 (20 \times 2) \cdot A_2 (2 \times 30) \cdot A_3 (30 \times 12) \cdot A_4 (12 \times 8)$해
    <ul>
      <li>행렬의 곱셈에서는 결합법칙이 성립한다
        <ul>
          <li>$(a+b)+c = a+(b+c) $: a+b+c</li>
          <li>binary operation (이진 연산 : 두 피연산자에 대해 연산하면 한 연ㅅ나)</li>
          <li>빼기는 결합법칙 성립 x → 어떤 빼기를 먼저 하느냐에 따라 결과 달라짐</li>
          <li>행렬의 곱셈의 교환법칙 성립 X, 결합법칙은 성립 O</li>
        </ul>
      </li>
      <li>제일 먼저 곱하는 게 몇 번이냐고 생각할 수 있고,</li>
      <li>최소 횟수를 구하는 것이니 minimization problem : 최소 횟수의 곱셈 → 최적화 문제로 대입</li>
      <li>어떤 친구를 제일 먼저 곱할 것인가 생각할 수 있다.</li>
      <li>곱셈을 곱하는 순서 : 곱셈을 순서대로 나열한 것과 동일
        <ul>
          <li>최적의 해 : 곱셈의 개수가 작은 것으로 선택할 것이다.</li>
        </ul>
      </li>
      <li>$A_1: 20 \times 2, A_2: 2 \times 30$</li>
      <li>$A_1(A_2(A_3 A_4)) : 30 \times 12 \times 8 + 2 \times 30 \times 8 + 20 \times 2 \times 8 = 3,680$ multiplications
        <ul>
          <li>3, 2, 1</li>
        </ul>
      </li>
      <li>$(A_1 A_2)(A_3 A_4) : = 8,880$ multiplications</li>
      <li>$A_1((A_2 A_3 )A_4) : = 1,232$ <u>multiplications</u>
        <ul>
          <li>2, 3, 1</li>
        </ul>
      </li>
      <li>$((A_1 A_2)A_3 )A_4 := 10,320$ multiplications</li>
      <li>$(A_1(A_2 A_3 ))A_4 := 3,120$ multiplications</li>
      <li>The order of multiplication is very important!
        <ul>
          <li>$(a \times b) \times c = a \times (b \times c)$</li>
        </ul>
      </li>
      <li>$O((n-1)!)=O(n!)$ : 프로그램 열심히 설계하는 데에는 얼마 안 걸릴지 모르지만 n factorial만큼 기다려야 결과가 나온다
        <ul>
          <li>곱셈을 할 수 있는게 $(n-1)!$의 경우의 수인데 이들을 어떻게 분류해서 exponential보다 무시무시한 factorial을 polynomial time으로 변환하여 어떻게 잘 분리해 판단할것인가?</li>
          <li>분류 방법 : Ex. $A_1 \cdot A_2 \cdot A_3 \cdot A_4 \cdot A_5 \cdot A_6 \cdot A_7$
            <ul>
              <li>(1) 어떤 애를 가장 먼저 나눌 것인가
                <ul>
                  <li></li>
                </ul>
              </li>
              <li>(2) 어떤 애를 가장 나중에 나누어 곱할 것인가
                <ul>
                  <li>최소 곱셈을 하고자 하는데, 만일 제일 마지막에 곱하는 것이라면 앞의 것을 다 곱하고 뒤의 것을 나중에 곱해야 하는데 우리의 목적이 최소 곱셉을 원하는 것이므로 각각의 partition에 대해서 최소 횟수로 곱하게 됨
                    <ul>
                      <li>→ 자연스로운 recursive 사고방식</li>
                    </ul>
                  </li>
                  <li>$(A_1 \cdot A_2 \cdot A_3) \cdot (A_4 \cdot A_5 \cdot A_6 \cdot A_7) = A_{13} \cdot A_{37}$</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/18.png" alt="18" /></p>
  </li>
  <li>Divide and Conquer, Dynamic Programmping
    <ul>
      <li>problem → <u>**recursive structure**</u> → optimal substructure → dynamic programming</li>
      <li>~를 최대로 해 주는 최적화 문제에 많이 쓰이는 DP</li>
      <li>최적의 구조 이런 것들이 있을 경우, 경우에 따라서는 divide and conquer가 유리할 수 있다</li>
      <li>exponential alg이 나오기 때문에 dp를 한 번 써보자.</li>
    </ul>
  </li>
  <li>Divide and Conquer → Top-down</li>
  <li>Dynamic Programming → Bottom-up</li>
  <li>Recursive : 나랑 같이 생겼는데, 나보다 사이즉 작은 문제를 해결한다.
    <ul>
      <li>작은 문제부터 풀 것인가 (Bottom Up), 큰 문제부터 내려올 것인가 (Top Down)</li>
    </ul>
  </li>
  <li>directed graph라고 봤을 때, 최소 횟수로 건너가는 문제
    <ul>
      <li>n에서 1까지의 shortest path 찾는 문제</li>
      <li>분명 shortest path는 존재하는데, 6→ 5,3,2</li>
      <li>$P_n = \min{ P_{n-1}, P_{\frac n 2}, P_{\frac n 3}}+1$
        <ul>
          <li>if $n\%2 ==0$ → $P_{\frac n 2}$</li>
          <li>if $n\%3 ==0$ → $P_{\frac n 3}$</li>
        </ul>
      </li>
      <li>나보다 사이즈 작은 것들의 최적의 solution을 찾느다 : optimal substructure</li>
      <li>문제 사이자 즉은 거부터 값을 계산해본다. 이러한 P_n의 식을 통해서 계산
        <ul>
          <li>n을 k로 대치하여 생각</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/19.png" alt="19" /></p>
  </li>
</ul>

<h1 id="433-dynamic-programming-approach">4.3.3. Dynamic programming approach</h1>

<ul>
  <li>Definition
    <ul>
      <li>$M(i, j)$
        <ul>
          <li>the minimum number of multiplications needed to multiply $A_i$ through $A_j (i \leq j )$</li>
          <li>랑 같이 행렬 i부터 j까지 최소 횟수를 곱할 때, 그 때 필요한 곱셈의 홋수를 M(i,j)로 정의</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Optimal subtructure
    <ul>
      <li>지금까지 본 것이랑 조금 다른 형태의 substructure가 나오더라</li>
      <li>최적화 문제의 경우 dp 느낑인데 그렇지 않을수도 있더라 : 경우의 수를 따지고 recursive한 개념이 들어가는 경우
        <ul>
          <li>i, j가 같으면 곱셈이 필요 없다.</li>
          <li>i&lt;j이면
            <ul>
              <li>i에서 k까지 최소횟수 → $M(i,k) = d_{i-1} \cdot d_k $</li>
              <li>k에서 j까지 최소횟수 → $M(k+1, j) = d_k \cdot d_j$</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>→ $M(1,n) = ?$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/20.png" alt="20" /></p>

<ul>
  <li>Example: $M(2, 7)$
    <ul>
      <li>
        <p>$M(2,7) = \min_{2\leq k \leq 6}{{ M(2,k) + M(k+1,7)+d_1 d_k d_7}}$</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/21.png" alt="21" /></p>
      </li>
      <li>dp : 작은 문제부터 풀어감</li>
      <li>table을 만들어서 동일한 subproblem을 딱 한 번만 푸는 것: table을 어떻게 만들 것인가?</li>
      <li>우리가 필요한 것 : 세로 i, 가로 j → 필요한 subproblem을 다 모아두면, M(i,j)이다. $M(i,j) i\leq j$
        <ul>
          <li>대각선 우하향으로 내려갈수록 작은 문제이다</li>
          <li>table을 어떻게 훑으며 작은 문제에서 큰 문제로 변환할 것인가?</li>
          <li>optimal substructure의 구조가 어떻게 table을 쫓아갈 것인가 고민해보는 문제</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>M(2,7)
    <ul>
      <li>가로로 시작하면 안 됨 : 가로의 M(2,2,) M(2,3) .. 은 다 되지만 세로의 것들은 한번에 못 채우기 때문</li>
      <li>세로로 시작하면 될까? : 세로로 순서대로 이 식을 활용해 계싼할 것인데 왼쪽의 것들과 밑의 쪽의 것들이 계산될 것 같다.</li>
    </ul>
  </li>
  <li>
    <p>Table fill order</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/22.png" alt="22" /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">g</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">g</span><span class="o">++</span><span class="p">){</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">g</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                          <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">g</span><span class="p">;</span>
                          <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">BIG_NUM</span><span class="p">;</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
          		        <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
              				        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                      				<span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                          <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Time complexity
    <ul>
      <li>$n + (n-1) \cdot 1 + (n-2) \cdot 2 + … + (n-(n-1))\cdot (n-1)n+(n−1)⋅1+(n−2)⋅2+…+(n−(n−1))⋅(n−1)\= n + \Sigma_{g=1}^{n-1}{(n-g)g} \= O(n^3)$
undefined- Chained matrix multiplication problem</li>
      <li>$O(n^3)$ by Godbole (1973)</li>
      <li>$O(n^2)$ by Yao (1972)</li>
      <li>$O(n \log n)$ by Hu and Shing (1982, 1984)</li>
    </ul>
  </li>
  <li>Printing optimal order
    <ul>
      <li>$M(2,7) = \min_{2\leq k \leq 6}{{ M(2,k) + M(k+1,7)+d_1 d_k d_7}}$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">order</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">A_</span> <span class="o">%</span> <span class="n">d</span><span class="err">”</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="k">else</span>
      <span class="p">{</span>
          <span class="n">k</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"("</span><span class="p">);</span>
          <span class="n">order</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
          <span class="n">order</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">")"</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/23.png" alt="23" /></p>
  </li>
</ul>

<p>→ $O(n)$ time</p>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/24.png" alt="24" /></p>

<h1 id="alg-44-principles-of-dynamic-programming-1">[ALG] 4.4. Principles of Dynamic Programming (1)</h1>

<h1 id="44-principles-of-dynamic-programming">4.4. Principles of Dynamic Programming</h1>

<ul>
  <li>$C_{ij}$ = the cost of the shortest path from (0,0) to (<em>i</em>,<em>j</em>)
    <ul>
      <li>각 directed edge에서 shortest path를 찾아라</li>
      <li>
        <p>Then $C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$rkr</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/25.png" alt="25" /></p>
      </li>
    </ul>
  </li>
  <li>Recursive formulation</li>
  <li>Optimal substructure
    <ul>
      <li>나의 최적의 해를 구하기 위해서 나보다 크기가 작은 subproblem들의 optimal solution을 통해서 최적의 해를 구하는 과정을 가능케해주는 구조</li>
    </ul>
  </li>
  <li>Overlapping subproblems
    <ul>
      <li>굉장히 안 좋은 형태로 풀이될수 있음(무한 loop)</li>
      <li>subproblem의 개수는 각 node만큼 있으니가</li>
    </ul>
  </li>
  <li>Bottom-up approach
    <ul>
      <li>작은 문제부터 풀자</li>
    </ul>
  </li>
  <li>Table Fill-up
    <ul>
      <li>각 node에 대한 최단 거리를 table에 계산해두고 기록되어 있는 것들에 대해 채워가며 수행하자</li>
    </ul>
  </li>
</ul>

<h2 id="441-optimal-substructurewiki">4.4.1. Optimal Substructure <a href="https://en.wikipedia.org/wiki/Optimal_substructure">(wiki)</a></h2>

<p>쭉 읽고 아는척 해봐자 !! (dynamic programming)</p>

<ul>
  <li>문제에 대해서 DP를 적용하기 위해서는 optimal substructure를 찾아내야 한다
    <ul>
      <li>나의 optimal solution을 찾는 구조 : recursion이 들어가 있음</li>
      <li>recursion을 divide and conquer로 top-down으로 하던가, bottom-up으로 올라가던가</li>
    </ul>
  </li>
  <li>Dynamic programming algorithms are often <strong>used for optimization</strong>.
    <ul>
      <li>~를 최대로 해 주는 optimal problem을 푸는 데에 주로 쓰인다</li>
    </ul>
  </li>
  <li>A problem is said to have <strong>optimal substructure</strong>
    <ul>
      <li>if a solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.</li>
    </ul>
  </li>
  <li>Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.
    <ul>
      <li>Such optimal substructures are <strong>usually described by means of recursion</strong>.</li>
      <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
    </ul>
  </li>
</ul>

<h2 id="442-overlapping-subproblemswiki">4.4.2. Overlapping Subproblems <a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">(wiki)</a></h2>

<blockquote>
  <p>💡 큰 문제를 푸는데, recursive하게 작은 문제를 계속해서 top down식으로 풀 때 같은 식으로 반복적으로 나오는 경우 : overlapping problem 문제가 심각할 때</p>
</blockquote>

<ul>
  <li>To solve a problem, we often need to <strong>solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution</strong>.</li>
  <li>A problem is said to have <u>**overlapping subproblems**</u> if
    <ul>
      <li>the problem can be broken down into subproblems which are reused several times or</li>
      <li>a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.</li>
      <li>한 번만 풀고 이를 table에 집어넣어 점차 size를 키워 문제 원래 것을 푸는 방식</li>
      <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
    </ul>
  </li>
  <li>The dynamic programming approach seeks to <strong>solve each subproblem only once</strong>, thus reducing the number of computations:
    <ul>
      <li>(i) once the solution to a given subproblem has been computed, it is stored or “<strong>memoized</strong>”:</li>
      <li>(ii) the next time the same solution is needed, it is simply <strong>looked up</strong>.</li>
    </ul>
  </li>
  <li>This approach is <strong>especially useful when the number of repeating subproblems grows exponentially</strong> as a function of the size of the input.</li>
  <li><strong>If a problem can be solved by combining optimal solutions to non-overlapping sub-problems</strong>, the strategy is called “divide-and- conquer” instead. This is why merge sort and quick sort are not classified as dynamic programming problems.
    <ul>
      <li>overlapping subproblem이 거의 발생하지 않음 : merge sort, selection
        <ul>
          <li>merge sort : 큰 문제를 반으로 반으로 나누고 해당 subproblem들이 overlap되지 않음</li>
          <li>selection : 큰 부분들에 대해서 부분을 선택하고 한 부분은 다른 것과 겹치지 않음</li>
          <li>quick sort : pivot을 제외한 나머지 부분들은 overlap하지 않음
            <ul>
              <li>굳이 DP로도 갈 필요 없이 divide and conquer로 쉬이 풀리게 됨</li>
              <li>이분법적 사고 지양 :
                <ul>
                  <li><u>위에서 아래로 내려가는데 subproblem이 반복적으로 나타나는 경우 exponentially 한 시간 복잡도가 걸릴 수 있기에 이럴 때는 dp를 써라</u></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
</ul>

<h2 id="443-the-checkerboard-problem">4.4.3. The Checkerboard Problem</h2>

<p>[Courtesy of Wikipedia]</p>

<ul>
  <li>체스판</li>
  <li>Restrictions
    <ul>
      <li>A checker can start at any square on the first row (i= 1).</li>
      <li>It can move only diagonally left forward, diagonally right forward, or straight forward.
        <ul>
          <li>내려가는 방법 제한 : 남서쪽으로만 내려가던가, 남쪽으로 내려가던가, 남동쪽으로 내려가던가</li>
        </ul>
      </li>
      <li>It must pay the cost <em>c</em>[i] when visiting the (i, j)-position.</li>
    </ul>
  </li>
  <li>
    <p>Cost table $c [i] [j]$</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/26.png" alt="26" /></p>
  </li>
  <li>Problem
    <ul>
      <li>Given a checkerboard with $n \times n$ squares, and a cost function <code class="language-plaintext highlighter-rouge">c[i][j]</code>, <strong>find the minimum-cost path from the first row to the last row</strong>.</li>
      <li>내가 어떤 지점을 방문했을 때에는 화살표가 지나간 cost를 summation한 것
        <ul>
          <li>가장 길이가 짧은 적은 비용의 path 찾는것이 목표</li>
        </ul>
      </li>
      <li>recursive 구조, optimal substructure을 찾아보자
        <ul>
          <li>가장 작게 해주는 minimization problem</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Ex. 1 까지의 최소비용 [4][4]
    <ul>
      <li>최소 비용의 path는 셋 중 하나 : 남쪽으로 오거나, 남서쪽에서 오거나, 남동쪽에서 오거나</li>
      <li>내가 최소 비용을 찾고자 하는 것이니 각각에 이르기까지의 최소 비용 path의 총 비용의 계산
        <ul>
          <li>각각 상황에 대한 총 비용을 안다면, ㅐptimal substructure로 어떻게 나타낼까?</li>
          <li>minimum cost path에 대한 총 비용은 올 수 있는건 세 가지 경로인데 가장 작은 것에다가 이를 선택해서</li>
          <li>나를 방문할 때 1을 더하면 되더라</li>
        </ul>
      </li>
      <li></li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>$q(i,j) = \min { q(i-1, j-1), q(i-1,j), q(i-1, j+1)} + c(i,j)$
        <ul>
          <li>$c(i,j)$ :</li>
          <li>table size는 어떻게 할 것인가 : 각 subproblem마다 원소에 대응되게 table을 잡으면 됨</li>
          <li>총 비용에 해당하는 q(i,j) : (i,j) 까지 위치 까지의 총 비용 계산
            <ul>
              <li>min (남쪽으로 내려오는, 남동쪽, 남서쪽)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>$q(i,j) = c(i,j)$
        <ul>
          <li>i=1일 때 : 자기 자신 - 맨 윗줄
            <ul>
              <li>그 지점까지 오는 최소 비용은 자기 자신 cost만 지불하면 됨</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>dummy
        <ul>
          <li>수학적으로 무한대 값을 설정해 둠</li>
          <li>이런식으로 설정하고 programming하면 각 끝에 값들에 선택되지 않음</li>
          <li>사실 수학적으로 쓸 때 필요는 없지만, dummy값을 넣어주는 게 편리
            <ul>
              <li>boundary 체크해도 상관은 없지만 각 왼쪽, 오른쪽 끝에서 boundary로부터 오는 값들을 계산하기 곤란함</li>
            </ul>
          </li>
          <li>각 cost table 위치마다 subproblem이 하나 생성됨</li>
        </ul>
      </li>
      <li>table setup &amp; table fill
        <ul>
          <li>어떤식으로 loop을 돌면서 할까</li>
        </ul>
      </li>
      <li>(if) 수직으로 for loop를 돌겠다고 하면
        <ul>
          <li>남동, 남서로 내려오는 것들에 대해서는 고려하지 못하므로 안됨</li>
        </ul>
      </li>
      <li>(if) 수평으로 for loop를 돌겠다고 하면
        <ul>
          <li>특정 원소를 계산하고자 할 때, 나에게 필요한 정보가 미리 준비되어 있음</li>
          <li>q table이 계산되더라</li>
        </ul>
      </li>
      <li>q table이 계산된 후 할일 : 아무데서나 시작해도 상관없으니 위에서 내려와서 최소비용으로 가게하자
        <ul>
          <li>아무데서나 시작해서 가는 minimum cost path</li>
          <li>→ 8</li>
        </ul>
      </li>
      <li>q table을 계싼함과 동시에 p table 계산
        <ul>
          <li>어느 방향에서 왔는지
            <ul>
              <li>가장 작은 것을 선택하는 경우</li>
            </ul>
          </li>
          <li>-1 : 북서에서 내려온거다 / 0 : 북에서 내려온거다 / 1 : 북동에서 내려온거다</li>
        </ul>
      </li>
      <li>optimal substructure를 찾은 다음 table을 setup하고 base step 정보를 가지고 initialize하고 table을 적당한 순서로 정리한 다음 적정한 최단 optimal path를 찾는다.</li>
      <li>이후 table fill을 할 때 table을 하나 잡아서 어떤 node를 선택해서 내려왔음을 표기함 (p table)</li>
      <li>→ shortest path를 알게 된다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/27.png" alt="27" /></p>

    <ul>
      <li>나보다 사이즈가 작은 최적의 솔루션들로 표현하는 것</li>
      <li>code
        <ul>
          <li>c/c++는 recursion이 좋은 tool이지만 보편적으로 굉장히 개념을 compact하게 잘 표현해준다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#define N 5
</span>  <span class="cp">#define INFTY 100000
</span>  <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	
  <span class="kt">int</span> <span class="nf">min3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="nf">ComputeCBCosts</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFTY</span><span class="p">;</span>
          <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFTY</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                      <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
              <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">else</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">PrintShortestPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">imin</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">" (%d, %d) &lt;-"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">" (%d, %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imin</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
      <span class="k">else</span>
          <span class="n">PrintShortestPath</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imin</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">ComputeCBShortestPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
      <span class="n">ComputeCBCosts</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="n">imin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">imin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"*** The cost of the shortest path is %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
      <span class="n">PrintShortestPath</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
      <span class="n">ComputeCBShortestPath</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[divide and conquer: top - down 효율적이기도 하나 매우 비효율적이 되기도 함 splitted된 사례들이 서로 관련 없는 문제를 풀때 잘 통함 dynamic programming : bottom -up 아래에서 위로 올라가며 효율을 추구하자는 방식 NOW Divide-and-Conquer Method Dynamic Programming Method Greedy Method Backtracking Method Local Search Method Branch-and-Bound Method Etc. From Wikipedia: Dynamic programming is both a mathematical optimization method and a computer programming method. A complicated problem is broken down into simpler sub-problems in a recursive manner. Overlapping subproblems A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems. Optimal substructure A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems. When applicable, the method **takes far less time than other methods** that don’t take advantage of the subproblem overlap like the divide- and-conquer technique.]]></summary></entry><entry><title type="html">[ALG] 3.3. Master Theorem</title><link href="http://localhost:4000/ALG-3.3.-Master-Theorem" rel="alternate" type="text/html" title="[ALG] 3.3. Master Theorem" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-09-26T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.3.-Master-Theorem-</id><content type="html" xml:base="http://localhost:4000/ALG-3.3.-Master-Theorem"><![CDATA[<h1 id="master-theorem-1">Master Theorem 1</h1>

<p>[Neapolitan 2.8]</p>

<ul>
  <li>Let a, b, and c be nonnegative constants.</li>
  <li>The solution to the recurrence $T (1)=1$, and $T(n)=aT(\frac n c)+bn$, for <em>n</em>&gt;1 for <em>n</em> a power of <em>c</em> is
    <ul>
      <li>$T(n)=O(n)$, if $a&lt;c$
        <ul>
          <li>a=3, b=4 → n ⇒ $\frac n 3, \frac n 3$</li>
        </ul>
      </li>
      <li>$T(n)=O(n \log n)$ if $a=c$
        <ul>
          <li></li>
        </ul>
      </li>
      <li>$T(n) = O(n \log_c a)$ if a &gt; c
        <ul>
          <li>$a=4, c=2$면? → $O(n^{\log_2 4})$</li>
          <li>a&gt;c이면 log_c a &gt; 1이게 됨
            <ul>
              <li>$O(n \log n)$ vs $O(n^{1.00000000001})$</li>
              <li>$\lim_{n\rightarrow \infty}{\frac {f(n)}{g(n)}} = \infty, c, 0$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>o(n) &lt; O(n \log n) &lt; O(n \log_c a)</p>

<p>$T(n) = T(\frac n 5) + T(\frac 3 4 n) + bn$</p>

<p>Prove this by induction!</p>

<ul>
  <li>Avoid divided-and-conquer if, for example–
    <ul>
      <li>An instance of size n is divided into two or more instances each almost of size <em>n</em>.</li>
      <li>An instance of size n is divided into almost <em>n</em> instance of size $\frac n c$, where <em>c</em> is a constant.</li>
    </ul>
  </li>
  <li>The divide-and-conquer strategy often leads to efficient algorithms, although not always!</li>
</ul>

<h1 id="master-theorem-2">Master Theorem 2</h1>

<p>212p</p>

<p>Theorem</p>

<p>if $T(n) \leq a \cdot T(\frac n b) + O(n^d) $ for $a \geq 1, b&gt;1$ and $d \geq 0$</p>

<p>→ then</p>

<p>$T(n) = O(n^d \log n) $ if $a = b^d$</p>

<p>$T(n) = O(n^d) $ if $a &lt; b^d$</p>

<p>$T(n) = O(n^d \log n) $ if $a &gt; b^d$</p>

<p>divide and conquer : linear time이라는 보장은 없다.</p>

<p>스스로 한번 이해해보고, 이해가 안 됐을 때 또 다시 생각해보기 (숙제!)</p>

<ul>
  <li>직관적으로, 논리적으로 맞느지 스스로 이해를 해보라,</li>
</ul>

<h1 id="alg-34-miscellaneous-1">[ALG] 3.4. Miscellaneous (1)</h1>

<h1 id="finding-the-closest-pair-of-2d-points">Finding the Closest Pair of 2D Points</h1>

<h2 id="1-내용">1. 내용</h2>

<p><strong>[J. Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005. 5.4]</strong></p>

<ul>
  <li>Problem
    <ul>
      <li>
        <p>Given <em>n</em> points in the plane, find the pair that is closest together.</p>

        <p>n</p>
      </li>
    </ul>
  </li>
  <li>Notation</li>
  <li>Naïve algorithm
    <ul>
      <li>Compute the distance between each pair of points</li>
      <li>take the minimum → $O(n^2)$ time
undefined
        <h2 id="2-applying-the-divide-and-conquer-strategy">2. Applying the Divide-and-Conquer Strategy</h2>
      </li>
    </ul>
  </li>
  <li>[Shamos and Hoey]</li>
  <li>Simple assumption for an easy explanation
    <ul>
      <li>No two points in <em>P</em> have the same _x_coordinate or the same _y_coordinate.</li>
    </ul>
  </li>
  <li>General idea
    <ul>
      <li>[Preprocessing]
        <ul>
          <li>Build a list <em>Px</em> in which all the points in <em>P</em> have been sorted by increasing _x_coordinate→ $O(n \log n)$</li>
          <li>Build another list <em>Py</em> in which all the points in <em>P</em> have been sorted by increasing _y_coordinate→ $O(n \log n)$</li>
        </ul>
      </li>
      <li>[Recursion for <em>P</em> with $∣P∣=n$]
        <ul>
          <li>[Divide] Partition <em>P</em> into two subsets <em>Q</em> and <em>R</em> → <em>O</em>(<em>n</em>)</li>
          <li>[Conquer] Find the closest pairs in <em>Q</em> and <em>R</em>, respectively→ $2T(\frac n 2)$</li>
          <li>[Combine] Use this information to get the closest pair in P→ <em>O</em>(<em>n</em>)</li>
          <li>Time-complexity
            <ul>
              <li>$O(n \log n) + T(n)$ where $T(n) = cn +2T(n/2) → O(n \log n)$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The stage [Divide]: Partition <em>P</em> into two subsets <em>Q</em> and <em>R</em>.
    <ul>
      <li>Create <em>Q</em> and <em>R</em>, where
        <ul>
          <li>Q: the set of points in the first  $\lceil(\frac n 2)\rceil$positions of the list $P_x$ (the “left half”),</li>
          <li>R_R_: the set of points in the final $\lfloor(\frac n 2) \rfloor$positions of the list $P_x$ (the “right half”).</li>
        </ul>
      </li>
      <li>Furthermore, create $Q_x, Q_y, R_x$, and $R_y$, where
        <ul>
          <li>$Q_x$ consisting of the points in <em>Q</em> sorted by increasing _x_coordinate,</li>
          <li>$Q_y$ consisting of the points in <em>Q</em> sorted by increasing _y_coordinate,</li>
          <li>$R_x$ consisting of the points in <em>R</em> sorted by increasing _x_coordinate,</li>
          <li>$R_y$ consisting of the points in <em>R</em> sorted by increasing _y_coordinate.</li>
        </ul>
      </li>
      <li>✓ Can be done in $O(n)$</li>
    </ul>
  </li>
  <li>The stage [Conquer]: Find the closest pairs in <em>Q</em> and <em>R</em>, respectively.
    <ul>
      <li>Recursively determine a closest pair $(q_0, q_1)$ of points in <em>Q</em></li>
      <li>Recursively determine a closest pair $(r_0, r_1)$ of points in <em>R</em>.
        <ul>
          <li>Can be done in $2T(\frac n 2)$.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The stage [Combine]: Use the obtained info. to get the closest pair in <em>P</em>.
    <ul>
      <li>Question : are there points $q \in Q, r \in R$ for which $d(q,r)&lt;\delta$?
        <ul>
          <li>How can we answer this question in linear time?</li>
        </ul>
      </li>
      <li>[Fact 1] (Why?)
        <ul>
          <li>if there $∃q∈Q,r∈R $for which $d(q,r)&lt;\delta$</li>
          <li>then each of <em>q</em>,<em>r</em> lies within a distance $\delta$ of $L$</li>
        </ul>
      </li>
      <li>[Fact 2]
        <ul>
          <li>$∃q∈Q,r∈R$ for which $d(q,r)&lt;\delta⟺ ∃s,s′∈S$ for which $ d(s,s′)&lt;δ$</li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/0.png" alt="0" /></p>
          </li>
          <li>$x^*$: the x-coordinate of the rightmost point in <em>Q</em></li>
          <li>$\delta=min(d(q_0^<em>,q_1^</em>),d(r_0^<em>,r_1^</em>))$</li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/1.png" alt="1" /></p>
          </li>
        </ul>
      </li>
      <li>[Fact 3]
        <ul>
          <li>if $s, s^{‘ } \in S$ have the property that $d(s, s^{‘})&lt;\delta$, then $s, s^{‘}$ re within 15 positions of each other in the sorted list $S_y$
            <ul>
              <li>$S_y$ : the list consisting of the points in <em>S</em> sorted by increasing _y_coordinate.</li>
              <li>Each box contains at most one point of <em>S</em>. (Why?)</li>
              <li>If two points in <em>S</em> are at least 16 positions apart in $S_y$ , …</li>
            </ul>
          </li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/2.png" alt="2" /></p>
          </li>
        </ul>
      </li>
      <li>
        <p>[merge] : <em>O</em>(<em>n</em>)</p>

        <p>O(n)</p>

        <ol>
          <li>For each $s \in S_y$ , compute its distance to each of the next 15 pts in $S_y$</li>
          <li>Let $s, s^{‘}$ be the pair achieving the minimum of these distances</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>Compare $d(s, s^{‘})$ with $δ$</p>

<p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/3.png" alt="3" /></p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[Master Theorem 1]]></summary></entry><entry><title type="html">[ALG] 3.2. Selection Algorithm</title><link href="http://localhost:4000/ALG-3.2.-Selection-Algorithm" rel="alternate" type="text/html" title="[ALG] 3.2. Selection Algorithm" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-09-26T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.2.-Selection-Algorithm</id><content type="html" xml:base="http://localhost:4000/ALG-3.2.-Selection-Algorithm"><![CDATA[<h1 id="1-selection-of-both-maximum-and-minimum-elements">1. Selection of Both Maximum and Minimum Elements</h1>

<ul>
  <li><strong>Problem</strong>
    <ul>
      <li>Find both the maximum and the minimum elements of a set containing n elements (assume $n = 2m$ for some integer $m$).</li>
    </ul>
  </li>
  <li>
    <p>[Aho 2.6]</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">begin</span>
      <span class="n">MAX</span> <span class="o">&lt;-</span> <span class="n">any</span> <span class="n">element</span> <span class="n">in</span> <span class="n">S</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">all</span> <span class="n">other</span> <span class="n">elements</span> <span class="n">x</span> <span class="n">in</span> <span class="n">S</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">MAX</span> <span class="n">then</span> <span class="n">MAX</span><span class="o">&lt;-</span> <span class="n">x</span>
    <span class="n">end</span>
</code></pre></div>    </div>

    <ul>
      <li>$T(n) = (n-1) + (n-2) = 2n-3$ comparisons</li>
    </ul>

    <p>$T(n) = 2T(n/2) + 2$ for $n &gt; 2$, $T(n) = 1$ for $n=2$</p>

    <p>$→ T(n) = (3/2)n - 2$ comparisons</p>

    <ul>
      <li>This is the minimum!</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">MAXMIN</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span>
	<span class="k">if</span> <span class="o">|</span><span class="n">S</span><span class="o">|</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">then</span>	
		<span class="n">begin</span>	
			<span class="n">let</span> <span class="n">S</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">};</span>	
			<span class="k">return</span> <span class="p">(</span><span class="n">MAX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>	
		<span class="n">end</span>
	<span class="k">else</span>	
		<span class="n">begin</span>	
			<span class="n">divide</span> <span class="n">S</span> <span class="n">into</span> <span class="n">two</span> <span class="n">subset</span> <span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span> <span class="n">each</span> <span class="n">with</span> <span class="n">the</span> <span class="n">half</span> <span class="n">of</span> <span class="nf">elements</span>	
			<span class="p">(</span><span class="n">max1</span><span class="p">,</span> <span class="n">min1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">MAXMIN</span><span class="p">(</span><span class="n">S1</span><span class="p">);</span>	<span class="p">(</span><span class="n">max2</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">MAXMIN</span><span class="p">(</span><span class="n">S2</span><span class="p">);</span>	
			<span class="k">return</span><span class="p">(</span><span class="n">MAX</span><span class="p">(</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="p">),</span> <span class="n">MIN</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">))</span>	
		<span class="n">end</span>
</code></pre></div></div>

<h1 id="2-multiplication-of-two-n-bit-numbers">2. Multiplication of Two n-bit Numbers</h1>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/0.png" alt="0" /></p>

<ul>
  <li>The traditional method requires $O(n^2)$ bit operations.</li>
  <li>A divide-and-conquer approach</li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/1.png" alt="1" /></p>

<ul>
  <li>$n=2m$
    <ul>
      <li>$xy = (a2^{\frac n 2} + b)(c2^{\frac n 2} + d) = ac2^n + (ad+bc)2^\frac n 2 + bd$</li>
      <li>divide하면 여기까지는 자연스럽게 감</li>
    </ul>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u = (a+b)*(c+d);
  v = a*c, w = b*d;
  z = v * pow(2,n) + (u-v-w) * pow(2, n/2) + w;
</code></pre></div>    </div>
  </li>
  <li>[Aho 2.6]
    <ul>
      <li>$T(n) = 1$ for $n=1$</li>
      <li>$T(n) = 3T( \frac n 2) + cnT(n)=3T(\frac n 2)+cn$for $n&gt;1 → T(n)=O(n\log3)$</li>
      <li>$O(n^2) → O(n^{1.59})$</li>
    </ul>
  </li>
  <li>Read [Neapolitan 2.6].</li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/2.png" alt="2" /></p>

<h1 id="alg-322-selection-of-the-k-th-smallest-element-1">[ALG] 3.2.2. Selection of the k-th Smallest Element (1)</h1>

<h1 id="selection-of-the-k-th-smallest-element">Selection of the k-th Smallest Element</h1>

<ul>
  <li><em>ref</em>. [A. Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974. 3.6]</li>
  <li>Problem
    <ul>
      <li>Given a <u>sequence of</u> <u>_S_</u> of <em>n</em> elements and an integer $k (1 &lt;= k &lt;= n)$, find the $k^{th}$ smallest element of <em>S</em>.</li>
    </ul>
  </li>
</ul>

<p>당장 해결하라고 하면 어떻게 해결하려고 할까?</p>

<ul>
  <li><strong>Solution 1:</strong>
    <ul>
      <li>Choose the smallest element repeatedly k times.
  반복적으로 1, 2, … k번째로 작은 수를 찾는다.
        <ul>
          <li>효율성을 떠나서 가장 빠르게 생각나는 풀이 방법</li>
          <li>$C = c(n-1)+c(n-2)+c(n-3)+…+c(n-k) = c \cdot k \cdot n - c \cdot \frac {k(k+1)} 2$
            <ul>
              <li>1번째 작은것 뽑는 시간, 2번째, …, k번째 작은 것 뽑는 시간의 합 → Linear Time Algorithm</li>
              <li>$O(n) ?$ : 아님
                <ul>
                  <li>input size : n, k</li>
                  <li>k : 어떤 값이느냐에 따라서 천차만별인 time complexity
                    <ul>
                      <li>k = 1 → linear time (n-1번 비교)</li>
                      <li>n = 100, k = 100</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>if $k= \frac n 2$ then $C = c \cdot \frac {n^2} 2 - c \cdot \frac {n^2 + 2n} 8 = O(n^2)$
            <ul>
              <li>시간 복잡도가 k=1에서 n까지 가는데 $O(c) \rightarrow O(n) \rightarrow O(n^2)$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/3.png" alt="3" /></p>

<ul>
  <li><strong>Solution 2:</strong>
    <ul>
      <li>Build a min-heap, and then extract the smallest element repeatedly <em>k</em> times.
        <ul>
          <li>임의의 데이터 n개의 sequence로부터 min(max) heap을 구성할 때 Linear Time 소요</li>
          <li>$C = c \cdot n + d \cdot k \cdot log n $</li>
          <li>if $k= \frac n 2$ then $C = c \cdot n + d \cdot \frac n 2 \cdot \log n = O(n \log n)$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/4.png" alt="4" /></p>

<ul>
  <li><strong>Can we design an</strong> $O(n)$<strong>-time algorithm?</strong></li>
</ul>

<p>어떻게 linear time algorithm을 만들기 위해서 노력했을까?</p>

<ul>
  <li>생각의 흐름에 따른 추적</li>
</ul>

<h1 id="1-observation">1. Observation</h1>

<p>divide and conquer : 지금까지 배운 것</p>

<ul>
  <li>At least $O(n)$ time is necessary.</li>
  <li>If we use a divide-and-conquer scheme like the merge sort,</li>
  <li>$T(n) = 2T(\frac n 2) + cn =&gt; O( n\log n)$
    <ul>
      <li>n개 짜리의 문제를 2개로 나누고 linear time의 bound가 되는 그런 상황</li>
      <li>n개 짜리 문제가 $\frac n 2$개 두 개로 나누어지고 이것이 또 $\frac n 4$로 나누어짐</li>
      <li>두 개를 쪼개서, 알아서 conquer해서 찾아와라</li>
      <li>→ level마다 $cn$ 개의 stage, binary tree의 height $cn \cdot \log n$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/5.png" alt="5" /></p>

<ul>
  <li>What about $T(n) = 3T(\frac n 3) + cn$?
    <ul>
      <li>$n \rightarrow \frac n 3+\frac n 3+\frac n 3$</li>
      <li>subproblem들의 합</li>
    </ul>
  </li>
  <li>What about $T(n) = 100T(\frac n {100}) + cn$?
    <ul>
      <li>$n \rightarrow \frac n {100} \cdot  100$</li>
      <li>subproblem들의 합</li>
    </ul>
  </li>
  <li>$T(n) = T(0.4n) + T(0.6n) + cn \rightarrow T(n) = O (n \log n)$
    <ul>
      <li>subproblem 합이 원래 문제</li>
      <li>cn이 linear time일 때 총 시간복잡도는 $O (n \log n)$</li>
    </ul>
  </li>
  <li>$T(n) = T(0.39n) + T(0.6n) + cn \rightarrow T(n) = O (n)$
    <ul>
      <li>$n &gt; (0.39 + 0.6)n$</li>
      <li>$n = 2^{20} = 1048576$ 의 경우 유의미한 차이가 존재함</li>
    </ul>
  </li>
  <li>Can we design an O(n)-time algorithm for this selection problem?
    <ul>
      <li>
        <p>What about $T(n) = T(an) + T(bn) + cn$ with $a + b &lt; 1$?</p>

        <p>n개짜리 문제를 두 개로 푸는데</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 그 때 subproblem의 합이 원래 것보다 작고
  - 나머지 부가비용은 $cn$
</code></pre></div>        </div>
      </li>
      <li>
        <p>ex. $a = 0.43, b=0.37 \rightarrow?$ㅉ
undefined	- Pascal’s Triangle</p>
        <ul>
          <li>무한등비수열</li>
        </ul>

        <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/6.png" alt="6" /></p>

        <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/7.png" alt="7" /></p>
      </li>
    </ul>
  </li>
  <li>cost : $cn{1+(a+b)+(a+b)^2+…} \leq cn \frac 1 {1-a+b}$
    <ul>
      <li>so $O(n)$</li>
    </ul>
  </li>
</ul>

<h1 id="2-algorithm">2. Algorithm</h1>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Step 1: Divide S into $\lfloor \frac {</td>
          <td>S</td>
          <td>} 5 \rfloor$ sequence of 5 elements each with up to four leftover elements.</td>
        </tr>
      </tbody>
    </table>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/8.png" alt="8" /></p>

    <ul>
      <li>정렬이 안 된 임의의 데이터들을 5개씩 묶음</li>
    </ul>
  </li>
  <li>Step 2: Sort each 5-element sequence.
    <ul>
      <li>다섯개 묶음까지만 하는것 같은데 나머지 세개에 대해서는 어떻게 할까?
        <ul>
          <li>ex. T(43) : 43개가 쭉 있는데 거기에 두 개 집어넣음. 무한대 두개 넣어도 똑같음</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/9.png" alt="9" /></p>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/10.png" alt="10" /></p>
  </li>
  <li>Step 3: Let M be the sequence of medians of the 5-element sets. Then, let m be the median of the elements in <em>M</em>.
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>M</td>
              <td>= \frac n 5$</td>
            </tr>
          </tbody>
        </table>

        <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/11.png" alt="11" /></p>
      </li>
    </ul>
  </li>
  <li>Step 4: Let _S_1,_S_2, and _S_3 be the sequences of elements in S less than, equal to, and greater than m, respectively.
S를 세 부분집합으로 나눈 후 : 작거나 / 같거나 / 크거나
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>If $</td>
              <td>S1</td>
              <td>&gt;= k$, then find the k-th smallest element of S1.</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>else if $(</td>
              <td>S1</td>
              <td>+</td>
              <td>S2</td>
              <td>&gt;= k)$, then m is the $k^{th}$ smallest element of S.</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>else find the $(k –</td>
              <td>S1</td>
              <td>-</td>
              <td>S2</td>
              <td>)^{th}$ smallest element of _S_3.</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/12.png" alt="12" /></p>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/13.png" alt="13" /></p>
  </li>
</ul>

<blockquote>
  <p>💡 - size n인 배열에서 몇 번째로 작은 element인지 찾아라 :</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- size n인 배열에서 몇 번째로 작은 element인지 찾아라 :
	- step 3에서 m집합을 구성한 다음 median을 찾아라
	- $|M| = \frac n 5$ : divide and conquer - 27개보다 더 작은 것을 찾으니까 s1에서 작은 것을 찾으면 됨
- 어떤 m보다 작은 애들 다 구해논 것, 같은 것, 더 큰 것을 구해둔 것
- if) s1 = 100, s2 = 5, s3 = 200일 때
	- 27번째 작은 것을 찾고자 한다면, S1에 존재
	- 103번을 찾고자 한다면, S2에 존재
		- 103 - 100 = 3 →
	- 120번째 작은 것을 찾는다면, S3에 존재
		- 120 - 100 - 5 = 15번째로 작은 원소 선택 - 각 subproblem에서 똑같은 방식으로 풀어보려고 한다. 정말 절실하게 subproblem의 tc가 원래 문제 사이즈 n보다 작게 하려고 하는데, 어떤 문제를 푸는가
- 내가 풀고자 하는 문제와 똑같은 방식으로 풀고자 함
- $T(n) \rightarrow T(\frac n 5)$ : - 왜 $T(\frac 3 4 n)$로 bound가 되는가 생각해보자 : m을 잘 선택해서 → size가 적당
- 앞서 정렬한 다음 가운데 것을 모아서 m을 찾아냄
- m보다 작은 애들, 같은 애들, 큰 애들을 묶음 → m을 잘 선택했기 때문에 S1, S2, S3 각각에 어느 정도 원소가 존재하도록 쪼갠 것
- $T(|S_1|) $ or $T(|S_3|) $
	- $|S_1| \leq \frac 3 4 n$
	- 도대체 어떻게 했길래 각각 작거나 같은 것이 적당히 뽑힌 것인가 : m을 적당히 잘 선택했기에!
</code></pre></div></div>

<h2 id="pseudocode">pseudocode</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">SELECT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="o">:</span>
<span class="k">if</span> <span class="o">|</span><span class="n">S</span><span class="o">|&lt;</span><span class="mi">50</span> <span class="n">then</span>
	<span class="n">begin</span>
		<span class="n">sort</span> <span class="n">S</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">kth</span> <span class="n">smallest</span> <span class="n">element</span> <span class="n">in</span> <span class="n">S</span>
	<span class="n">end</span>
<span class="k">else</span>
	<span class="n">begin</span>
		<span class="n">divide</span> <span class="n">S</span> <span class="n">into</span> <span class="o">|</span><span class="n">S</span><span class="o">|/</span><span class="mi">5</span> <span class="n">sequences</span> <span class="n">of</span> <span class="mi">5</span> <span class="n">elements</span> <span class="n">each</span> <span class="n">with</span> <span class="n">up</span> <span class="n">to</span> <span class="n">four</span> <span class="n">leftover</span> <span class="n">elements</span><span class="p">;</span>
		<span class="n">sort</span> <span class="n">each</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sequence</span><span class="p">;</span>
		<span class="n">let</span> <span class="n">M</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">medians</span> <span class="n">of</span> <span class="n">the</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sets</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">&lt;-</span> <span class="n">SELECt</span> <span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
		<span class="n">let</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="n">and</span> <span class="n">s3</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequences</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">in</span> <span class="n">S</span> <span class="n">less</span> <span class="n">than</span><span class="p">,</span> <span class="n">equal</span> <span class="n">to</span><span class="p">,</span> <span class="n">and</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">m</span><span class="p">,</span> <span class="n">respectively</span><span class="p">;</span>
		<span class="k">if</span> <span class="o">|</span><span class="n">s1</span><span class="o">|&gt;=</span> <span class="n">k</span>
			<span class="n">then</span> <span class="k">return</span> <span class="n">m</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">SELECT</span> <span class="p">(</span><span class="n">k</span><span class="o">-|</span><span class="n">s1</span><span class="o">|-|</span><span class="n">s2</span><span class="o">|</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span>
	<span class="n">end</span>


</code></pre></div></div>

<ul>
  <li>
    <p>Pseudocode Analysis</p>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/14.png" alt="14" /></p>
  </li>
  <li>
    <p>A divide-and-conquer strategy</p>
  </li>
</ul>

<h2 id="facts">Facts</h2>

<ul>
  <li>(A) At least one-fourth of the elements of S are less than or equal to <em>m</em>.</li>
  <li>(B) At least one-fourth of the elements of S are <u>greater than or equal to</u> <u>_m_</u><u>.</u>
    <ul>
      <li>m보다 같거나 큰 애들</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>S_1</td>
              <td>&lt;= \frac {3n} 4$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>S_3</td>
              <td>&lt;= \frac {3n} 4$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>S1: the set of all elements less than m</li>
  <li>S2: the set of all elements equal to m</li>
  <li>S3: the set of all elements greater than m</li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/15.png" alt="15" /></p>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/16.png" alt="16" /></p>

<h1 id="33-time-complexity">3.3. Time Complexity</h1>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Input size $n =</td>
          <td>S</td>
          <td>$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>M</td>
          <td>&lt;= \lceil( \frac n 5)\rceil$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>S_1</td>
          <td>&lt;= \frac {3n} 4$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>S_3</td>
          <td>&lt;= \frac {3n} 4$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>for $n \leq 49$</li>
  <li>7이 아니라 5, 7, 9, 100001</li>
  <li>n보다 더 작아지니까 더 좋을 것 같은데, 이 값이 커지다 보면, 대략 n/100이 된다.
    <ul>
      <li>5개보다는 7개가 더 좋고, … :$n/1001 + 3n/4$«n이면 더 좋으므로</li>
      <li>→ 10001개 짜리를 sorting하는데 과연 이 10001개 sorting하는 시간이 상수 시간이냐 : 그렇게 볼 순 없다.</li>
    </ul>
  </li>
  <li>이 시간이 상수시간이 안 된다.
    <ul>
      <li>n이 어느정도 변해도 변하지 않는, n/100과는 어느정도 큰 것이기 때문에 미묘한 차잉가 있음을 명심하자.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">SELECT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="o">:</span>
<span class="k">if</span> <span class="o">|</span><span class="n">S</span><span class="o">|&lt;</span><span class="mi">50</span> <span class="n">then</span>
	<span class="n">begin</span>
		<span class="n">sort</span> <span class="n">S</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">kth</span> <span class="n">smallest</span> <span class="n">element</span> <span class="n">in</span> <span class="n">S</span>
	<span class="n">end</span>
<span class="k">else</span>
	<span class="n">begin</span>
		<span class="n">divide</span> <span class="n">S</span> <span class="n">into</span> <span class="o">|</span><span class="n">S</span><span class="o">|/</span><span class="mi">5</span> <span class="n">sequences</span> <span class="n">of</span> <span class="mi">5</span> <span class="n">elements</span> <span class="n">each</span> <span class="n">with</span> <span class="n">up</span> <span class="n">to</span> <span class="n">four</span> <span class="n">leftover</span> <span class="n">elements</span><span class="p">;</span>
		<span class="n">sort</span> <span class="n">each</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sequence</span><span class="p">;</span>
		<span class="n">let</span> <span class="n">M</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">medians</span> <span class="n">of</span> <span class="n">the</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sets</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">&lt;-</span> <span class="n">SELECt</span> <span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
		<span class="n">let</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="n">and</span> <span class="n">s3</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequences</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">in</span> <span class="n">S</span> <span class="n">less</span> <span class="n">than</span><span class="p">,</span> <span class="n">equal</span> <span class="n">to</span><span class="p">,</span> <span class="n">and</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">m</span><span class="p">,</span> <span class="n">respectively</span><span class="p">;</span>
		<span class="k">if</span> <span class="o">|</span><span class="n">s1</span><span class="o">|&gt;=</span> <span class="n">k</span>
			<span class="n">then</span> <span class="k">return</span> <span class="n">m</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">SELECT</span> <span class="p">(</span><span class="n">k</span><span class="o">-|</span><span class="n">s1</span><span class="o">|-|</span><span class="n">s2</span><span class="o">|</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span>
	<span class="n">end</span>

</code></pre></div></div>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/17.png" alt="17" /></p>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/18.png" alt="18" /></p>

<h1 id="alg-323-selection-algorithm-complexity-analysis-1">[ALG] 3.2.3. Selection Algorithm: Complexity Analysis (1)</h1>

<ul>
  <li>Theorem
    <ul>
      <li>$\forall c, d \in \mathbb{R^+}$, if the following recurrence relation holds:</li>
      <li>$T(n) \leq d$ for $n≤49$</li>
      <li>$T(n) \leq T(\frac n 5) + T (\frac {3n} 4) + cn, n \geq 50$</li>
      <li>then $T(n) = O(n)$</li>
    </ul>
  </li>
  <li>Proof
    <ul>
      <li>We want to prove that $T(n) \leq kn$ for some constant $k,∀n≥1$
        <ol>
          <li>Base case
            <ul>
              <li>$T(n) \leq d \leq dn, ∀n≥1$</li>
              <li>Therefore, $T(n)≤kn ∀1≤n≤49 $ if we select k such that $k \geq d$</li>
            </ul>
          </li>
          <li>Inductive step
            <ul>
              <li>assume that $n≥5$ and $T(m) \leq km, \forall m &lt; n$
                <ul>
                  <li>Then, $T(n) \leq T(\frac n 5) + T (\frac {3n} 4) + cn$</li>
                </ul>
              </li>
              <li>$T(n)\leq k \frac n 5 + k \frac {3n} 4+ cn = \frac {19}{20}kn +cn$</li>
              <li>$T(n)= kn + (c-\frac k {20})n \leq kn$
                <ul>
                  <li>if $k \geq 20c$</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li>So if we choose <em>k</em> s.t. $k=\max(d,20c), T(n)≤kn$ for all $n≥50.$</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[1. Selection of Both Maximum and Minimum Elements]]></summary></entry><entry><title type="html">[ALG] 3.0. Algorithm Design</title><link href="http://localhost:4000/ALG-3.0.-Algorithm-Design" rel="alternate" type="text/html" title="[ALG] 3.0. Algorithm Design" /><published>2022-09-19T00:00:00+09:00</published><updated>2022-09-19T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.0.-Algorithm-Design</id><content type="html" xml:base="http://localhost:4000/ALG-3.0.-Algorithm-Design"><![CDATA[<h1 id="the-divide-and-conquer-approach">The Divide-and-Conquer Approach</h1>

<p>각각을 나누어 conquer해서 정복하다 : 원래 문제를 푸는 것과 같은 방식으로 combine해서 원래 문제의 해를 찾는 문제 해결 방식. 여러가지 부류의 변형이 존재한다.</p>

<ul>
  <li>(1) <strong>Divide</strong> an instance of a problem into one or more smaller instances
    <ul>
      <li>문제의 인스턴스를 하나 이상의 작은 인스턴스로 나눕니다.</li>
    </ul>
  </li>
  <li>(2) <strong>Conquer</strong> (Solve) each of the smaller instances. Unless a smaller instance is sufficiently small, use recursion to do this.
    <ul>
      <li>각 작은 인스턴스를 정복합니다. 작은 인스턴스가 충분히 작지 않으면 재귀적을 사용하여 이 작업을 수행합니다.</li>
    </ul>
  </li>
  <li>(3) If necessary, <strong>combine</strong> the solutions to the smaller instances to obtain the solution to the original instance.
    <ul>
      <li>필요한 경우 작은 인스턴스에 대한 솔루션을 결합하여 원래 인스턴스에 대한 솔루션을 확보합니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design.md/0.png" alt="0" /></p>

<h1 id="recursion">Recursion</h1>

<ul>
  <li>Tower of Hanoi
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/">Geeksforgeeks</a></li>
      <li>
        <p>작은거 위에 큰 거 올리지 않는 연산</p>

        <p><img src="/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design.md/1.png" alt="1" /></p>
      </li>
    </ul>
  </li>
  <li>$T(n) = 2T(n-1) +1, n&gt;1$</li>
  <li>$T(1)=1$</li>
  <li>Recursive thinking!
    <ul>
      <li><a href="https://introcs.cs.princeton.edu/java/23recursion/">princeton</a></li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design.md/2.png" alt="2" /></p>

<ul>
  <li>recursion의 묘미 - compact하게 recursion하게 표현
    <ul>
      <li>3개 옮기는 데도 복잡하게 가지만 이를 compact하게 바꾸어주는 작업</li>
    </ul>
  </li>
  <li>전체를 옮기는데 하나를 옮긴다 : n개의 disk를 옮기는 비용
    <ul>
      <li>n개의 비용은 어떻게 될까 : $T(n) = 2 T(n-1) + 1 (n \geq 2)$</li>
      <li>작은 것 두 번 옮기고 마지막 하나 가야하므로 → 정확하게는 $1 (n=1)$</li>
    </ul>

    <p>→ $O(2^n)$</p>
  </li>
  <li>$T(n) = $
    <ul>
      <li>$a_n = 2a_{n-1} +1 (n \geq 2), a_1 = 1$ → $a_n = ?$</li>
    </ul>
  </li>
  <li>recursion을 잘 다루면 매우 효율적으로 되고, 대표적으로 divide and conquer 방법론</li>
</ul>

<h1 id="sorting">Sorting</h1>

<blockquote>
  <p>💡 A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.<br />
Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐</p>

  <p>일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐


일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)
</code></pre></div></div>

<ul>
  <li>Problem:
    <ul>
      <li>Given a list of n items, arrange them <strong>in a certain order.</strong>
        <ul>
          <li>Ex: non-increasing, non-decreasing, or etc. : 크기순서대로 정렬한다</li>
          <li>이론적, 알고리즘적으로 문제 해결하는 측면이 있고, practical하게 하는거랑</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Some criteria for choosing a sorting algorithm
    <ul>
      <li>How many items will you be sorting? 얼마나 많은 원소를 정렬할 것인가?</li>
      <li>Will there be duplicate items in the data? 데이터에 중복 항목이 있습니까?</li>
      <li>What do you know about the data? 데이터에 대해 알고 계십니까?
        <ul>
          <li>Is the data already partially sorted?데이터는 이미 부분적으로 정렬되어 있는가?</li>
          <li>Do you know the distribution of the items?품목의 분포를 알고 있습니까?</li>
          <li>Are the keys of items very long or hard to compare?항목 키가 매우 길거나 비교하기 어렵습니까?
            <ul>
              <li>정수 데이터를 sorting하는 건가, 여러 string을 비교하는것인가에 따라 사용하는 알고리즘이 접근 방식이 달라질 수 있다.</li>
              <li>이에 괘념치 않고 sorting alg를 좋다더니 쓰자 하면 버벅되는 꼴이 일어날 것.</li>
            </ul>
          </li>
          <li>Is the range of possible keys very small? 가능한 키의 범위가 매우 작습니까?</li>
        </ul>
      </li>
      <li>Do you have to worry about disk accesses? 디스크 액세스에 대해 염려해야 합니까?</li>
      <li>Do you need a <u>**stable**</u> sorting algorithm? 안정적인 정렬 알고리즘이 필요한가?
        <ul>
          <li>stable한 알고리즘 15 31 2 7 6 7 9 ⇒ 2 6 7 7 9 15 13</li>
          <li>같은 값이 있을 때 그 순서가 유지 - 같은 7, 7의 순서가 변하지 않음 (stable soritng alg)</li>
        </ul>
      </li>
      <li>How much time do you have to write and debug your routine? 루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?</li>
    </ul>
  </li>
  <li>ref. <a href="https://drive.google.com/drive/u/0/folders/1IyehEF9hz96cFu5js6ZWyfR4_Mvk1xb8">Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005</a>,
    <ul>
      <li>원래 <a href="http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK4/NODE148.HTM">링크</a> 깨짐</li>
    </ul>
  </li>
  <li>정수처럼 4byte 저장되는건지 등 어떤 data를 정렬하느냐에 따라서 sw 개발자로서의 approach가 천차만별 : divide and conquer 이해가 ㅁ목적</li>
  <li>GPU Parallel Sorting</li>
</ul>

<h3 id="a-formal-definition-of-sorting">A Formal Definition of Sorting</h3>

<ul>
  <li>A <strong>partial order</strong> on a set S is a relation R such that for each a, b, and c in S:
    <ul>
      <li>$aRa$ is true (R is reflexive).</li>
      <li>$aRb$ and $bRc$ imply $aRc$ (R is transitive)</li>
      <li>$aRb$ and $bRa$ imply $a=b$ (R is antisymmetric)</li>
    </ul>
  </li>
  <li>A Linear Order or Total Older on a set <em>S</em> is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.</li>
  <li>The sorting problem
    <ul>
      <li>Given a sequence of <em>n</em> elements $a_1, a_2, …, a_n$ drawn from a set having a linear order $\preceq$</li>
      <li>find a permutation $Π=(π_1,π_2,…,π_n) $of $(1,2,…,n)$ that will map the sequence into a nondecreasing sequence $a_{\pi_1}, a_{\pi_2},…,a_{\pi_n}$,  such that $a_{\pi_1} \preceq a_{\pi_i+1}$,  for $1 \leq i &lt; n$</li>
    </ul>
  </li>
  <li>Ex: ≤ on $\mathbb{Z}, \subseteq$ on sets</li>
  <li>Sorting on data with partial order?</li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[The Divide-and-Conquer Approach]]></summary></entry><entry><title type="html">[ALG] 3.1. Sorting</title><link href="http://localhost:4000/ALG-3.1.-Sorting" rel="alternate" type="text/html" title="[ALG] 3.1. Sorting" /><published>2022-09-19T00:00:00+09:00</published><updated>2022-09-19T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.1.-Sorting</id><content type="html" xml:base="http://localhost:4000/ALG-3.1.-Sorting"><![CDATA[<h1 id="alg-311-merge-sort-1">[ALG] 3.1.1. Merge Sort (1)</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>divide and conquer 관점에서 - merge sort를 바라보면, 맨 위 임의로 주어진 배열 data를 아래처럼 정렬한다고 하자. 


divide and conqer가 자연스럽게 들어오면, 이제부터 몇 주가 편하게 갈 것이다.


# 1. Merge Sort

- **Problem**: Sort _n_ keys in nondecreasing sequence.
- **Inputs**: positive integer _n_, array of keys _S_ indexed from 1 to _n_.
- **Outputs**: the array _S_ containing the keys in nondecreasing order. 배열 S는 감소하지 않는 순서로 정렬된 key를 갖는다
	1. **Divide** the array into two subarrays each with $\frac n 2$ items.
		1. 전반부 후반부 한 덩어리씩 나눈다 : 절반으로 나누어서
	2. **Conquer** each subarray by sorting it recursively.
		1. 한 element만 남게 되면 정렬 끝
	3. **Combine** the solutions to the subarrays by merging them into a single sorted array.
		1. merge의 경우 크기 순서대로 되어 있는데 각 부분의 solution을 적절히 combine해서 찾는다
		2. 각 그룹중에 비교해서 더 작은 놈 나와 해서 sublist들을 merge하는 과정. : recursive하게 sort하여 정렬된 list로 merge하여 각 데이터를 총합하는 방식

![0](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/0.png)

- A simple implementation

	```c
	// Sort a list from A[left] to A[right].
	// Should be optimized for higher efficiency!!!
	void merge_sort(item_type *A, int left, int right)
	{
	    int middle;
	    if (left &lt; right)
	    {
	        // divide : O(1)
	        middle = (left + right) / 2;
	
	        // conquer : 2T(n/2) - subprogram들을 같은 방식으로 
					merge_sort(A, left, middle);
	        merge_sort(A, middle + 1, right);
	
	        // combine : O(n)
					merge(A, left, middle, right);
	    }
	}
	
	item_type *buffer;
	// extra space for merge sort, allocated beforehand
	void merge(item_type *A, int left, int middle, int right)
	{
	    int i, i_left, i_right;
	    memcpy(buffer + left, A + left, 
						 sizeof(item_type) * (right - left + 1));
	    // O(r-l+1), O(n)
	    i_left = left;
	    i_right = middle + 1;
	    i = left;
	
	    while ((i_left &lt;= middle) &amp;&amp; (i_right &lt;= right))
	    {
	        if (buffer[i_left] &lt; buffer[i_right])
	            A[i++] = buffer[i_left++];
	        else
	            A[i++] = buffer[i_right++];
	    }
	    while (i_left &lt;= middle)
	        A[i++] = buffer[i_left++];
	    while (i_right &lt;= right)
	        A[i++] = buffer[i_right++];
	}
	```


	![1](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/1.png)


	![2](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/2.png)

- Space Complexity
	- order of n만큼의 working space를 안 쓰고, input array의 n만 써서 활용할 때, 그런 알고리즘의 경우 O(n log n)만큼의 time complexity 이상이 찍힐 수 있겠구나.
	- 가능은 하다 : input array O, Working space X
		- inplace merge sort는 굉장히 복잡한 것으로 알고 있음.
	- 시간 복잡도를 증가시키지 않으면서, working space의 추가적인 memory를 안 쓰는 것 (상수 memory 사용)
	- 
</code></pre></div></div>
<details>
  <summary>In-place merge sort</summary>


[bookmark](https://www.geeksforgeeks.org/in-place-merge-sort/)

- stable을 유지하면서 working space는 linear space만 쓰는 것 → 어떤식으로 생각해서 접근할 것인가? 중요
- merge 할 때 추가적인 working space는 안 쓰고, 자연스럽게 생각할 수 있는 것들 :
	- 자연스러운 생각이 들 수 있게 길들여야만 복잡한 것을 하고 하나하나 자연스럽게 생각하는 습관 들이기
- Maintain two pointers that point to the start of the segments which have to be merged.
- Compare the elements at which the pointers are present.
- If _element1 &lt; element2_ then _element1_ is at right position, simply increase _pointer1_.
- Else shift all the elements between element1 and _element2(including element1 but excluding element2)_ right by 1 and then place the element2 in the previous place_(i.e. before shifting right)_ of element1. Increment all the pointers by _1_.

![3](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/3.png)

<details>
  <summary>C++ Code </summary>


```c
// C++ program in-place Merge Sort
#include <iostream>
using namespace std;

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
// Inplace Implementation
void merge(int arr[], int start, int mid, int end)
{
	int start2 = mid + 1;

	// If the direct merge is already sorted
	if (arr[mid] &lt;= arr[start2]) {
		return;
	}

	// Two pointers to maintain start
	// of both arrays to merge
	while (start &lt;= mid &amp;&amp; start2 &lt;= end) {

		// If element 1 is in right place
		if (arr[start] &lt;= arr[start2]) {
			start++;
		}
		else {
			int value = arr[start2];
			int index = start2;

			// Shift all the elements between element 1
			// element 2, right by 1.
			while (index != start) {
				arr[index] = arr[index - 1];
				index--;
			}
			arr[start] = value;

			// Update all the pointers
			start++;
			mid++;
			start2++;
		}
	}
}

/* l is for left index and r is right index of the
sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r)
{
	if (l &lt; r) {

		// Same as (l + r) / 2, but avoids overflow
		// for large l and r
		int m = l + (r - l) / 2;

		// Sort first and second halves
		mergeSort(arr, l, m);
		mergeSort(arr, m + 1, r);

		merge(arr, l, m, r);
	}
}

/* UTILITY FUNCTIONS */
/* Function to print an array */
void printArray(int A[], int size)
{
	int i;
	for (i = 0; i &lt; size; i++)
		cout &lt;&lt;" "&lt;&lt; A[i];
	cout &lt;&lt;"\n";
}

/* Driver program to test above functions */
int main()
{
	int arr[] = { 12, 11, 13, 5, 6, 7 };
	int arr_size = sizeof(arr) / sizeof(arr[0]);

	mergeSort(arr, 0, arr_size - 1);

	printArray(arr, arr_size);
	return 0;
}

// This code is contributed by shivanisinghss2110
```



  &lt;/details&gt;

  &lt;/details&gt;	- 

	## Worst Case Copmlexity of merge sort

	- $O(n^2) $:
	- 
	- An example of merging two arrays
		- left, right 각각 $
		\frac n 2$개

	→ 그림으로 바꾸기


		![4](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/4.png)


	## Worst-case time complexity


	![5](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/5.png)


	![6](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/6.png)


	![7](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/7.png)

	- 편의상 $n=2m$이라 할 경우 $(m \in Z^+ \cup \{0\}$)
		- $T(n) = 2T(\frac {n} {2}) + cn, n \geq 2$
			- 2 : Number of subproblems
			- $\frac n 2$ : Subproblem size
		- $T(1)=1 \rightarrow T(n) = O(nlogn)$
		- Merge Sort Complexity Analysis
	- n개의 원소를 k개와 l개로 나누어 진행한다고 가정하면 ($n=k+l$),
		- $T(n) = T(k) + T(l) + cn (k \approx l)$
		- $n = 2^m$ 이 아닌 일반적인 경우에도 같은 시간 복잡도를 가짐을 증명할 수 있음.

	## Solving Recurrence Equations

	- Solve the following recurrences $T(n)$ for given $T(1)=1$
		1. $T(n) = aT(n-1) + bn$
		2. $T(n) = T(\frac n 2) + bn \log n$
		3. $T(n) = aT(n-1) + bn^2$
		4. $T(n) = aT(n/2) + bn^2$
		5. $T(n) = T(\frac n 2) + c \log n$
		6. $T(n) = T(\frac n 2) + cn$
		7. $T(n) = 2T(\frac n 2) + cn$
		8. $T(n) = 2T(\frac n 2) + cn \log n$
		9. $T(n) = T(n-1) + T(n-2)$, for $T(1)=T(2)=1$
	- space complexity : embedded program 등 사실 제일 중요한 요소중에 하나로서, 현실 사회에서도 반드시 개발할 때 고려해야 함

	→ Space Complexity : $O(n)$

	- Space complexity : merge sort algorithm을 구현하는데 lienar space보다 더 적게 할수 있나?
		- 불가능: 데이터 input n개를 모두 저장해야하다
		- input array O(n)이 필요하고, 더 필요한건 O(n)이니가 알고리즘 관점에서 문제가 되지는 않음 : O(n)
		- 실제 구현한다고할 때, 심각한 문제가 될 수 있음.
	- Time complexity : time complexity가 나왔을 때 진짜 알고리즘 전공하거나 어느정도 수준이 되면 이거보다 더 빠른 알고리즘을 만들 수 있을까 싶을 것임. → $O(n \log n)$을 넘어설 수는 없다.
		- alg - implementation은 서로 다른 세상이다.

	## Some Derivations

	1. T(n) = 2 T(n/2) + cn, T(1) = 1
		- assume $n=2^m$, i.e., $m=\log_2m$ for some $m \geq 0, m \in \mathbb{Z}$
		- $T(2^m) 
		
		\\= 2T(2^{m-1})+c \cdot 2^mT(2m)
		\\ =2T(2m−1)+c⋅2m\\=2{2T(2m−2)+c⋅2m−1}+c⋅2m
		\\=2^2⋅T(2m−2)+2⋅c⋅2m\\=2^2{2⋅T(2m−3)+c⋅2m−2}+2⋅c⋅2m...\\=2m⋅T(20)+m⋅c⋅2m=n⋅1+(\log 2n)⋅c⋅n=O(n \log n)$

			$\\= 2 \{2T(2^{m-2})+c \cdot 2^{m-1} \}+c \cdot 2^m$


			$\\=2^2 \cdot T(2^{m-2})+2 \cdot c \cdot 2^m$


			$\\= 2^2 \{2 \cdot T(2^{m-3})+c \cdot 2^{m-2} \}+2 \cdot c \cdot 2^m$


			$\\ ... \\= 2^m \cdot T(2^0) + m \cdot c \cdot 2^m$


			$\\= n \cdot 1 + (log_2 n) \cdot c \cdot n = O(n \log n )$


		![8](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/8.png)

	2. $T(n) = T(n-1) + cn, T(1) = 1$
	3. $T(n) = 2 T(n/2) + cn^2, T(1) = 1$
		- Assume $n=2^m$ for some $m \in \mathbb{Z} - \mathbb {Z^-}$
undefined		- $2 \cdot T (2^{m-1}) + c \cdot 2 ^2m2⋅T(2m−1)+c⋅22m=2$

			$\\ = 2 \{ 2 \cdot T(2^{m-2}) + c \cdot 2 ^{2(m-1)} \} + c \cdot 2 ^2m$


			$\\= 2^2 \cdot T(2^{m-2}) + c \{ 2^{2m-1} + 2 ^{2m}\}$


			$\\ = 2 \{ 2 \cdot T(2^{m-3}) + c \cdot 2 ^{2(m-2)} \} + c \{ 2^{2m-1} + 2^{2m} \}$


			$\\= 2^3 \cdot T(2^{m-3})+ c \{ 2^{2m-2} + 2^{2m-1} + 2 ^{2m}\}$


			$\\ … \\= 2^m + 2 \cdot c \cdot 2^{2m} - 2 \cdot c \cdot 2^m$


			$\\ =2 \cdot c \cdot n^2 - (2 \cdot c -1) n = O(n^2)$


	## Another Implementation of Merge Sort

	- ref. [Horowitz 7.6.3]

		```c
		typedef struct {
		  int key;
		  int link;
		} element;
		```


		![9](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/9.png)

	- `rmerge` returns an integer that points to the start of the sorted list. start = rmerge(list, 0, n-1);

		```c
		int rmerge(element list[], int lower, int upper)
		{
		    /*sort the list, list[lower], ..., list[upper]. 
				// the link field in each record is initially set to -1*/ 
				// list[lower], …, list[upper]까지 오름차순으로 정렬.
				// 각 레코드의 link filed는 초기에 -1로 설정int middle;
		    if (lower &gt;= upper)
		        return lower;
		    else
		    {
		        middle = (lower + upper) / 2;
		        return listmerge(list, rmerge(list, lower, middle), rmerge(list, middle + 1, upper));
		    }
		}
		```

	- `listmerge` takes two sorted chains, first and second, and returns an integer that points to the start of a new sorted chain that includes the first and second chains.

		```c
		int listmerge(element list[], int first, int second)
		{
		    // first와 second가 가리키는 서브리스트들을 합병int start = n;
		    while (first != -1 &amp;&amp; second != -1)
		    {
		        if (list[first].key &lt;= list[second].key)
		        {
		            list[start].link = first;
		            start = first;
		            first = list[first].link;
		        }
		        else
		        {
		            list[start].link = second;
		            start = second;
		            second = list[second].link;
		        }
		    }
		    if (first == -1)
		        list[start].link = second;
		    else
		        list[start].link = first;
		    return list[n].link;
		    // 합병된 리스트의 시작 인덱스를 return
		}
		```

		- `listmerge` 함수 수행 예 start

			![10](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/10.png)


# [ALG] 3.1.2. Quick Sort (1)


	## 3.1.2. Quick Sort

	- comparison sort 중 하나
		- merge sort보다 worst case  : O(n^2)
		- 일반적으로 quick sort의 변형이 제일 빠르다고 실험을 통해 알려져 있음
	- Pivot strategy
		1. **Divide**
			- Select a **pivot element**, and then divide the array into two subarrays such that ....
				- 원소 중 하나를 뽑음
			- 비용 : $O(n)$ - 상수시간 안에 뽑고 쭉 n개를 보면서 15보다 크면 오른쪽으로 가고 15보다 작으면 왼쪽 그룹에 배치하여 모으는 작업 - 하나 씩 건드리는 작업이므로 n-1개를 보아야 함.
		2. **Conquer**
			- sort each subarray recursively.
			- $T(n_1) + T(n_2)  (n_1 + n_2+1 = n)$
		3. **Combine**
			- do nothing.
			- conquer 결과를 갖고 전체 결과를 만들어 냄.
			- merge sort: 각 subproblem을 해결해서 합쳐 원래 문제의 해답을 얻는 단계
			- quick sort : 이미 다 정렬된 케이스

		![11](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/11.png)


	![12](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/12.png)

	- merge sort : 계산 과정에서 binary tree가 만들어지는데, well-balanced binary tree가 만들어짐.
		- quick sort의 경우 well-balenced tree가 안될 수도있고, skewed (한 쪽으로 치우쳐진) tree
		- worst case의 경우 : 높이는 $O(n)$ + stack overflow의 가능성
			- 완전 정렬된 경우 맨 왼쪽 것을 pivot으로 삼았을 때
			- 거꾸로 정렬된 경우
		- 시간복잡도 등 여러 측면에서 well-balanced가 skewed보다 낫다.
		- 평균적으로 임의의 데이터가 들어왔을 때 quick sort가 빠르다.
	- Quick sort worst case Time Complexity : $O(n^2)$
		- $T(n) = T(n-1) + cn (n\geq 2)$
			- cn : divide cost
			- 한 쪽으로만 skewed된 tree
			- → $T(n) = O(n^2)$
		- $T(n) = 1 (n =1)$
	- average T.c. $O(n \log n)$, worst t.c. : $O(n^2)$
		- 일반적으로 quick sort가 구현하는데 있어서 빠르다
		- merge sort : average, worst - $O(n \log n)$
	- A simple implementation
		- $r-l&gt;0 → r-l+1 &gt;1$
			- 2개 이상의 개수 판별

		![13](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/13.png)


		```c
		// Sort a list from A[left] to A[right].
		// Should be optimized for higher efficiency!!!
		void quick_sort(item_type *A, int left, int right)
		{
		    int pivot;
		    if (right - left &gt; 0)
		    {
		        // divide
		        pivot = partition(A, left, right);
		        // conquer
						quick_sort(A, left, pivot - 1);
		        quick_sort(A, pivot + 1, right);
		    }
		}
		```


		```c
		#define SWAP(a, b) {
			item_type tmp;
			tmp = a;
			a = b;
			b = tmp;
		}
		
		int partition(item_type *A, int left, int right)
		{
		    int i, pivot;
		    pivot = left; //제일 왼 쪽에 있는 element를 pivot으로 설정
		    for (i = left; i &lt; right; i++)
		    {
		        if (A[i] &lt; A[right])
		        {
		            SWAP(A[i], A[pivot]);
		            pivot++;
		            // How is the pivot element chosen in this function?
		        }
		    }
		    SWAP(A[right], A[pivot]);
		    return (pivot);
		}
		```


		![14](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/14.png)

		- → 스스로 이해해볼 것

		&gt; ☀️ 첫 벉재 프로그래밍 과제  
		&gt; - 구현과 이론 사이 간극, 성능 검정


	# 직관적인 시간 복잡도 추정

	- skewed보다는 well-balanced가 더 나음
	- $T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1)$ if $n&gt;1$
	- $T(1) = 1$
	- → $O(n \log n) \leq T(n) \leq O(n^2)$

	![15](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/15.png)

	- node에 붙은 것을 다 더하면 n^2
	- log n *n 해서 n \log n
	- 평균적으로 봤을 때 n log n

	# Cost Analysis

	- worst case : $O(n^2) &lt;&lt; $merge, quick sort

	![16](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/16.png)

	- Cost
		- $T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1)$ if $n&gt;1$
	- Analysis
		- Divide : $O(n)$
		- Conquer : $T(m_1)+T(m_2)$
		- Combine : $O(1)$
	- Worst-case time complexity
		- 매 단계에서 선택한 pivot element가 가장 크거나 가장 작을 경우,
		- $T(n) = T(0) + T(n-1) + cn, T(1)=1$ then $T(n)=O(n^2)$
		- $T(1) = 1$
		- $T(n) = O(n^2)$
		- Skewed vs well-balanced trees
			- 

			![17](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/17.png)

	- Average-case time complexity
		- $T(n) = \sum_{p=1}^n {T(p-1) + T(n-p)} + cn$
		- $T(0) = 1 \rightarrow$
		- $\therefore T(n) = O(n log n)$
		- 

			![18](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/18.png)

	- mathematical induction

		![19](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/19.png)


		![20](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/20.png)


	# Average Case Time Complexity


	### 첫 번째 사실

	- $n \leq 0, \forall n \in \mathbb{Z}, T_{ave}(n)$ 을 n개의 원소를 가지는 배열을 퀵 정렬 방법을 사용하여 정렬하는데 걸리는 평균 수행시간이라고 하자. 그러먼 어떤 양의 정수 b와 c에 대해 다음과 같은 재귀 관계 존재
		- $T_{ave} (n) \geq cn + \frac {1}{n} \sum_{p=1}^{n} \{ T_{ave} (p-1) + T_{ave} (n-p) \}$
		- $\\= cn + \frac{2}{n} {\sum_{p=0}^{n-1} {T_{ave}(p)}}$
		- $\forall n \geq 2$
	- $T_{ave} (1) \leq b$
	- $T_{ave} (0) \leq b$
	- $Cost_{ave} = \sum_{p=1}^n {P_r (p) \cdot Cost(p)} = \frac {1}{n} \sum_{p=1}^n {... + ...}$

	### 두 번째 사실

	- $k=2(b+c)$ 라 할 때, 2보다 같거나 큰 모든 정수 n 에 대하여 $T_{ave} (n) \leq kn \log_e n$과 같은 관계 존재
	- 증명: 위의 부등식을 수학적 귀납법을 사용하여 증명하자.
		1. $n=2$
			- 첫 번째 사실로부터 다음과 같은 관계 성립
				- $T_{ave}(2) \leq 2c + T_{ave} (0) + T_{ave} (1) \leq 2(b+c) \leq k \cdot 2 \ log_e 2$
			- ∴ 따라서 두 번째 사실 성립
		2. 3보다 같거나 큰 임의의 n_n_ 이 given
			- Assume that : m&lt;n_m_&lt;_n_ 인 모든 m_m_ 에 대하여 두 번째 사실 성립한다고 가정하자.
			- 그러면 첫 번째 사실과 이 과정을 사용하여 다음과 같은 관계 유도 가능
			- $T_{ave} (n) \leq cn + \frac {2} {n} \sum_{m=0}^{n-1} {T_{ave} (m)}$
				- $\\ = cn + \frac 2 m \{ T_{ave} (0)+T_{ave} (1) \} + \frac {2} {n} \sum_{m=2}^{n-1} {T_{ave}(m)}$
				- $\\ \leq cn + \frac {4b} n + \frac {2k} n \sum_{m=2}^{n-1} {m log_e m}$
			- 그러므로 $T_{ave} (n) \leq cn + \frac {2} {n} \sum_{p=0}^{n-1} {T_{ve} (p)}∀n≥2$
			- $\frac 2 n \Sigma_{m=2}^{n-1} T_{ave} (m) : T_{ave}(m) \leq km \log _e m \leq \frac {2k}{n} \Sigma _{m=2}^{n-1} m \log_e n$
		- 함수 $x \log_e x$가 x_x_에 대하여 아래로 볼록한 함수이어서 $m log_e m \leq \int_m^{m+1} x \log_e x dx$라는 사실을 이용하면 다음과 같은 관계식을 얻는다.
			- $T_{ave} (n)= cn + \frac {4b}n + \frac {2k}n \int_2^n x log_e x dx$
			- $≤cn+n4b+n2k{2n2 \log_en−4n^2}=kn \log_e n+{cn+n^4b−2kn}$

				$\\ \leq cn + \frac {4b}{n} + \frac{2k}{n} \{ \frac{n^2 log_e n}{2} - \frac {n^2} 4 \}$


				$\\= knlog_e n + \{ cn + \frac{4b} n - \frac {kn} 2\}$


			&gt; $\int_2^n x log_e x dx =[\frac 1 2 x^2 log_e x - \frac {x^2} 4]_2^n$


				$= (\frac {n^2} 2) log_e n - \frac {n^2} 4 - (2log_e 2 - 1) \leq \frac {n^2} {2} {log_e n} - \frac {n^2} {4}$

		- 이 때, $cn + \frac{4b} n - \frac {kn} 2 = (c-\frac k 2 )n + \frac {4b} n = b(\frac 4 n -n)$ 과 같고 이 값은 2보다 같거나 큰 n에 대해 항상 0보다 같거나 작으므로 $ T_{ave} (n) \leq kn log_e n$이 되어 3보다 같거나 큰 임의의 n에 대해서도 두 번째 사실이 성립한다. 따라서 2보다 같거나 큰 모든 정수 n에 대해 다음과 같은 두 번째 사실이 성립한다.

		![21](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/21.png)


		![22](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/22.png)


		![23](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/23.png)


	## Another Implementation


	&gt; 🏝️ 중간고사 빈칸 .??? 코드가 편해질 때 까지!


	```c
	void quicksort(element list[], int left, int right)
	{
	    // list[left], …, list[right]까지 오름차순으로 정렬.
	    // list[left].key를 중추 키(pivot key)로 선정
	    // list[left].key ≤ list[right + 1].key 라고 가정
	    int pivot, i, j;
	    element temp;
	    if (left &lt; right)
	    {
	        i = left;
	        j = right + 1;
	        pivot = list[left].key;
	        do
	        {
	            // pivot을 중심으로 왼쪽과 오른쪽 리스트 생성
	            // 왼쪽 리스트: pivot보다 적은 키들을 저장, 오른쪽은 반대do
	            // 왼쪽부터 pivot보다 큰 키를 검색
	            i++;
	            while (list[i].key &lt; pivot);
	            do // 오른쪽부터 pivot보다 작은 키를 검색
	                j--;
	            while (list[j].key &gt; pivot);
	            if (i &lt; j)
	                // 각 리스트의 속성을 만족하도록 데이터 교환
	                SWAP(list[i], list[j], temp);
	        } while (i &lt; j);
	        SWAP(list[left], list[j], temp);
	        quicksort(list, left, j – 1);
	        // 왼쪽 리스트를 다시 정렬
	        quicksort(list, j + 1, right);
	        // 오른쪽 리스트를 다시 정렬
	    }
	}
	
	//code 약간 다르니 수정
	```


	## Comparison Sorts

	- source: WikiPedia

		![24](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/24.png)

	- 못난이 삼형제 sort : $O(n^2)$
		- insertion, select, bubble
		- n log n 방법들이 있음에도 n^2를 공부 : 장점은 구현하기 쉽다. 그리고 n log n, n^2늬 차이는 n이 커질 때 차이가 나는 것이지, 10개 즈음이면 복잡하게 function call하면서 쓸 필요가 없는 것이다. 너무 구현이 단순해서 오히려 더 빠를수도 있다.
		- insertion : 이를 이용하여 quick sort를 더 빠르게 할 수 있다.

	cost comparison


	![25](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/25.png)


	---


	## Improving the Performance of Quick Sort


	<첫 번째="" technique="">

	- How can you select a “good” pivot element? : pivot element를 잘 선택하는 것이 중요
		- Choose a <u>random</u> element in the list.
		- 가장 이상적인 케이스 : Choose **the** <u>**median**</u> **of the first, middle, and final** elements in the list.
			- 세 개만 보자, 다섯 개만 보자 : constant time
				- 데이터가 11개 있는데 그 중 크기 순으로부터 5번째 것을 찾아라 → linear time에 될까?
					- linear time에 당연히 된다.
					- median이 아니라 임의의 kth element를 찾는 문제도 나중에 divide and conquer에 나오고, 당연히 median 찾는 것도 가능
		- Choose **the** <u>**median**</u> **of the entire elements** in the list. (bad idea)
			- 다 보자 : 상수 시간에서 lienar time (to pick pivot element)
		- 이론적으로는 아무 문제 없음
			- 그러나 그만큼의 linear time 만큼이 추가되는 것이기 때문에 구현 측면에서 좋지 않음
		- Etc.

	![26](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/26.png)

	- Program 7.4. improved quicksort
		- Choosing the median of the first, middle, and final elements as the partitioning element and cutting off the recursion for small subfiles can significantly improve the performance of quicksort.
		- This implementation partitions on the median of the first, middle, and final elements in the array (otherwise leaving these elements out of the partitioning process).
		- Files of size 11 or smaller are ignored during partitioning; then, insertion from is used to finish the sort.

	<두 번째="" technique="">

	- if (r - l &lt;= M)  // r-l+1 &lt;= M + 1
		- compiler가 다 없애줌 : compiler의 최적화
	- merge sort:
		- 함수의 작동 기작 : 처음에 전체에 대해서 함수가 호출되고, recursively 1/2로 나누어지며 원소가 1개일 때 까지 split되며 control이 왔다갔다한다.
		- stack에 각 정보를 저장해 두고 내려간다.
		- quick sort → insertion
			- 이빨 빠지듯 중간에 quicksort가 이루어지지 않은 부분에 대해서

		```c
		#define M
		
		void quicksort(ITEM[] a, int l, int r)
		{
		//첫 벉재 technique : 어떻게 하면 pivot을 더 좋은 것을 뽑을가?
		//두 번째 technique : 
		// 정렬하려는 개수 r-l+1인데 이를 r-l+1 &lt;= M+1 
		// 해당 문장이 의미하는 바 : 정렬하고자 하는 원소의 개수가 주어진 상수값 m+1보다 작거나 같으면 정렬하지 말고 넘어가라. m=5, 7, 10, .. 사용하는 computing system에서 실험을 통해 얻어야 하는 값 (적당히 작은 값)
		// 원소으ㅐ 개수가 5-6개 정도 되면 그냥 빠져나와라 : 정렬이 안 된 경우 -&gt;건너뛴 부분 생김
		// insertion sort를 적용하면 이론적으로는 n^2이지만 정렬 안 하고 건너 뛴 부분들이 있을 때 전체적으로 sorting이 되어 있는데 부분 부분 정렬되지 않은 부분 -&gt; linear time에 돈 부분
		
		// 왜 빨라지는지 생각해 보고 올 것.
		    if (r - l &lt;= M)
		        return;
				// r-l+1 &lt;= M + 1
		
		    exch(a, (l + r) / 2, r - 1);
		    compExch(a, l, r - 1);
		    compExch(a, l, r);
		    compExch(a, r - 1, r);
		    int i = partition(a, l + 1, r - 1);
		//median을 찾아 divide하는 단계
		    quicksort(a, l, i - 1);
		    quicksort(a, i + 1, r);
		//양 쪽에 대하여 quick sort
		}
		
		void sort(ITEM a[], int l, int r)
		{
		    quicksort(a, l, r);
		    insertion(a, l, r);
		}
		```

	- How can you minimize the bookkeeping cost involved in the recursive calls?
		- Much of the pushing and popping of the frame stack is unnecessary.
		- Lists of size smaller than M are ignored during quick sort, then do a single sorting pass at the end.
		- depth만큼의 stack 필요함
		- 한없이 줄줄 내려가는 recursive function call : skewed되어서 줄줄이 내려가는 케이스의 경우 system에서 stack overflow

	![27](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/27.png)

	- How can you minimize the bookkeeping cost involved in the recursive calls?
		- pivot element: 제일 왼 쪽에 있는 것을 갖고 싶다
		- 작은 쪽에 대해서는 recursivesy
			- 큰 쪽 : 속도보다는 큰 데이터에 알맞게
		- Avoid making the recursive call on the larger subrange.
		- The depth of recursion $\leq O(\log n)$

	```c
	quicksortTRO(E, first, last)
	{
	  int first1, last1, first2, last2;
	  first2 = first;
	  last2 = last;
	  while (last2 - first2 &gt; 1)
	  {
	
	      pivotElement = E[first];
	      pivot = pivotElement.key;
	      int splitPoint = partition(E, pivot, first2, last2);
	      E[splitPoint] = pivotElement;
	      if (splitPoint &lt; (first2 + last2) / 2)
	      {
	          first1 = first2;
	          last1 = splitPoint - 1;
	          first2 = splitPoint + 1;
	          last2 = last2;
	      }
	      else
	      {
	          first1 = splitPoint + 1;
	          last1 = last2;
	          first2 = first2;
	          last2 = splitPoint - 1;
	      }
	      quicksortTro(E, first1, last1);
	// continue loop for fist2, last2.
	  }
	  return;
	}
	
	
	```


	![28](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/28.png)


	## Example: Quick Sort


	By courtesy of David R. Musser

	- Average-case: $O(n \log n)$
	- Worst-case: $O(n^2)$

		![29](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/29.png)

	- 코드 상에서는 별 차이 없지면 simulation에서는 에러가 날 수도 있다.
		- tech 1,2, 3

	## Performance Comparisons

	- 

	![30](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/30.png)


	## Quicksort: Implementation 2 [K. Loudon]


	```c
	#include <stdlib.h>
	#include <string.h>
	#include "sort.h"
	static int compare_int(const void *int1, const void *int2)
	{
	    // Compare two integers (used during median-of-// three partitioning
			if (*(const int *)int1 &gt; *(const int *)int2)
		    return 1;
	
	    else if (*(const int *)int1 &lt; *(const int *)int2) 
			return -1;
	
	    else return 0;
	}
	
	static int partition(void *data, int esize, int i, int k, int (*compare)(const void *key1, const void *key2))
	{
	    char *a = data;
	    void *pval, *temp;
	    int r[3];
	    /*  Allocate storage for the partition value and swapping. */
	    if ((pval = malloc(esize)) == NULL)
	        return -1;
	    if ((temp = malloc(esize)) == NULL)
	    {
	        free(pval);
	        return -1;
	    }
	    /* Use the median-of-three method to find the partition value.  */
	    r[0] = (rand() % (k - i + 1)) + i;
	    r[1] = (rand() % (k - i + 1)) + i;
	    r[2] = (rand() % (k - i + 1)) + i;
	    issort(r, 3, sizeof(int), compare_int);
	    memcpy(pval, &amp;a[r[1] * esize], esize);
	    /* Create two partitions around the partition   value.  */
	    i--;
	    k++;
	    while (1)
	    {
	        /* Move left until an element is found in the wrong partition. */
	        *do { k--; }
	        while (compare(&amp;a[k * esize], pval) &gt; 0)
	            ;
	        /* Move right until an element is found in the wrong partition. */ do
	        {
	            i++;
	        } while (compare(&amp;a[i * esize], pval) &lt; 0);
	
	        if (i &gt;= k)
	        {
	            break;
	        }
	        /* Stop partitioning when the left and right counters cross. */ else
	        {
	            /* Swap the elements now under the left and   right counters.  */ memcpy(temp, &amp;a[i * esize], esize);
	            memcpy(&amp;a[i * esize], &amp;a[k * esize], esize);
	            memcpy(&amp;a[k * esize], temp, esize);
	        }
	    }
	
	    /* Free the storage allocated for
	         partitioning. */
	    free(pval);
	    free(temp);
	    /* Return the position dividing the two partitions. */ return k;
	}
	
	int qksort(void *data, int size, int esize, int i, int k, int (*compare)(const void *key1, const void *key2))
	{
	    int j;
	    /* Stop the recursion when it is not possible
	         to partition further. */
	    if (i &lt; k)
	    {
	        // Determine where to partition the elements
	        if ((j = partition(data, esize, i, k, compare)) &lt; 0)
	            return -1;
	        // Recursively sort the left partition
	        if (qksort(data, size, esize, i, j, compare) &lt; 0)
	            return -1;
	
	        // Recursively sort the right partition
	        if (qksort(data, size, esize, j + 1, k, compare) &lt; 0)
	            return -1;
	    }
	
	    return 0;
	}
	```


# [ALG] 3.1.3. Insertion Sort (1)


	## Insertion Sort: Example 1


	매번 for loop이 돌 때마다 정렬된 stack이 다시 정렬됨


	![31](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/31.png)

	- 정렬된 배열이 끝에 가선 다 정리됨.
	- comparison sort : nlog n보다 더 빨리 할수 없다고 증명되어 있음.
	- $O(n^2)$ : worst case time complexity
		- $1+2+3+ ... + (n-1)$
		- 처음에 15 비교 → 10, 15 비교, …
		- 제일 오른쪽애랑비교하여 나보다 크면오른쪽으로 가라, 작으면 왼쪽으로 가라
	- best case time complexity
		- 1 + 1 + … + 1 = n-1 = O(n) - linear time
	- inp place algorithm

	## Insertion Sort: Example 2


	![32](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/32.png)

	- 전체적으로는 정렬 잘 된 것처럼 보이지만 중간에 잘 안된 케이스 존재
		- worst case는 o(n^2)이지만 linear처럼 돌아가게 됨.
			- n이 100만 일 때 엄청나게 큰 차이 존재
	- Insertion : $O(n+d)$ in the worst case over sequences that have d inversions
	- When does the insertion sort run fast?
	- 이러한 insertion sort의 성질을 quick sort의 성능 향상에 활용하자.
		- 이러한 insertion sort의 성질을 이용해서 quick sort를 더 빠르게 어떻게 할 것인가? (practical 구현 관점)
			- 

	## Implementation


	```c
	void insertion_sort(int *A, int n)
	{
	    int i, j, tmp;
	    for (i = 1; i &lt; n; i++)
	    {
	        tmp = A[i];
	        j = i;
	        while ((j &gt; 0) &amp;&amp; (tmp &lt; A[j - 1]))
	        {
	            A[j] = A[j - 1];
	            j--;
	        }
	        A[j] = tmp;
	    }
	}
	```

	- Sort a list of elements by iteratively inserting a next element in a progressively growing sorted array.

		```c
		#include <stdlib.h>
		#include <string.h>
		#include "sort.h"
		int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))
		{
		    char *a = data;
		    void *key;
		    int i, j; // Allocate storage for the key element.
		    if ((key = (char *)malloc(esize)) == NULL)
		        return -1;
		    // Repeatedly insert a key element among the sorted elements.
		    for (j = 1; j &lt; size; j++)
		    {
		        memcpy(key, &amp;a[j * esize], esize);
		        i = j - 1;
		        // Allocate storage for the key element.
		        if ((key = (char *)malloc(esize)) == NULL)
		            return -1;
		        // Repeatedly insert a key element among the sorted elements.
		        for (j = 1; j &lt; size; j++)
		        {
		            memcpy(key, &amp;a[j * esize], esize);
		            i = j - 1;
		            /* Determine the position at which to insert the key element. */ while (i &gt;= 0 &amp;&amp; compare(&amp;a[i * esize], key) &gt; 0)
		            {
		
		                memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
		                i--;
		            }
		            memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
		            i--;
		        }
		        memcpy(&amp;a[(i + 1) * esize], key, esize);
		    }
		    // Free the storage allocated for sorting.free(key);
		    return 0;
		}
		```


	## Run-Time Analysis

	- Worst case
		- No. of comparisons:
			- $1+2+ ...+n-1 = O(\frac {n^2}{2})$ : 완전히 뒤집혀진 경우 최악
		- No. of record assignments:
			- $1+2+ ...+n-1 = O(\frac {n^2}{2})+2(n-1)$
				- 왜 2가 붙는가 :

		![33](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/33.png)


		![34](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/34.png)

	- Average case
		- No. of comparisons

			$\sum_{i=1}^{n-1} {\frac{1+2+...+i+i}{i+1} } =\sum_{i=1}^{n-1} {(\frac{i}{2}+1-\frac{1}{i+1})}$


			$\approx \frac{(n-1)(n+4)}{4} - \ln n = O(\frac{n^2} 4)$

		- No. of record assignments

			$\sum_{i=1}^{n-1} {\frac{0+1+2+...+i}{i+1} +2} = \frac{n(n-1)}{4}+2(n-1) = O(\frac{n^2}4)$

			- 0번으로 시작해서 8번째에 insert : 확률적으로 위치는

			![35](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/35.png)


	## Example (skip)


	![36](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/36.png)


# [ALG] 3.1.4. Selection Sort (1)


	## Implementation

	- $T(n) = O(n^2)$

		```c
		#define SWAP(a, b) {
		    item_type tmp;
		    tmp = a;
		    a = b;
		    b = tmp;
		}
		
		void selection_sort(item_type *A, int n)
		{
		    int i, j, cur;
		
		    for (i = 0; i &lt; n - 1; i++)
		    {
		        cur = i;
		        for (j = i + 1; j &lt; n; j++)
		            if (A[j] &lt; A[cur])
		                cur = j;
		        SWAP(A[i], A[cur]); // what if i == cur? }
		    }
		}
		```


	## Example


	![37](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/37.png)


	## Run-Time Analysis

	- Worst case
		- No. of comparisons

			$\sum_{i=0}^{n-2} (n-i-1) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$3(n-1) = O(3n)$

	- Average case
		- No. of comparisons

			$\sum_{i=0}^{n-2} (n-i-1) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$3(n-1) = O(3n)$

	- [생각해보기] If we code like “if (i != cur) SWAP(A[i], A[cur]);”, what is the average cost?

# [ALG] 3.1.5. Bubble Sort (1)


	## Example


	![38](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/38.png)


	## Implementation


	```c
	#define SWAP(a, b) {
			item_type tmp;
			tmp = a;
			a = b;
			b = tmp;
	}
	
	void bubble_sort(item_type *A, int n)
	{
	    int i, j;
	
	    for (i = 0; i &lt; n - 1; i++)
	    {
	        for (j = n - 1; j &gt; i; j--)
	        {
	            if (A[j] &lt; A[j - 1])
	                SWAP(A[j], A[j - 1]);
	        }
	    }
	}
	```


	![39](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/39.png)


	## Run-Time Analysis

	- Refer to The Art of Computer Programming (Vol. 3)
	- Worst Case
		- No. of comparisons

			$\sum_{i=1}^{n-1} (n-1-i) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$\sum_{i=1}^{n-1} 3i = \frac 3 2 n(n-1)= O (\frac {3} {2} n^2)$

	- Average case
		- No. of comparisons

			$\sum_{i=1}^{n-1} (n-1-i) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$\frac 1 2 \sum_{i=1}^{n-1} 3i = \frac 3 2 n(n-1)= O (\frac {3} {4} n^2)$


# [ALG] 3.1.6. Cost Comparison (1)

	- 

	![40](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/40.png)

	- # of comparisons
		- Insertion
			- (average) $\frac {n^2} 4$
			- (worst) $\frac{n^2} 2$
		- Bubble
			- (average) $\frac{n^2}{2} $
			- (worst) $\frac{n^2}2$
		- selection : $\frac{n^2}2$
	- # of record assignments
		- Insertion
			- (average) $\frac{3n^2} 4$
			- (worst) $\frac{n^2}2$
		- Bubble
			- (average) $\frac 4 3n^2$
			- (worst) $\frac{3n^2}2$
		- selection : $3n$

	## Comparison Sorts


	[https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms)


	![41](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/41.png)


	## Performance Comparisons

	- By courtesy of David R. Musser
	- 

		![42](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/42.png)

</string.h></stdlib.h></string.h></stdlib.h></두></첫></iostream></details></details>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] 3.1.1. Merge Sort (1)]]></summary></entry><entry><title type="html">[ALG] 2. Heap-based PQ</title><link href="http://localhost:4000/ALG-2.-Heap-based-PQ" rel="alternate" type="text/html" title="[ALG] 2. Heap-based PQ" /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-2.-Heap-based-PQ</id><content type="html" xml:base="http://localhost:4000/ALG-2.-Heap-based-PQ"><![CDATA[<p>Heap-based Priority Queue, Heap Sort</p>

<h1 id="a-variety-of-priority-queue-implementations">A Variety of Priority Queue Implementations</h1>

<ul>
  <li>Heap이라는 개념 - 매우 전공에서 중요한 자료구조. 실제로 컴퓨터 system에서 메모리르 다루는 데 쓰이는 핵심적인 구조중 하나</li>
  <li>Insert, delete : 원소를 집어넣고 빼고 - queue</li>
  <li>Push, Pop : 데이터를 집어넣었다가 빼고 - stack</li>
  <li>data를 넣었다가 뺐다가 이런것을 반복하는 것들. 구현이 적합한 stack
    <ul>
      <li>→ queue, stack은 굉장히 특정 형태를 갖는 방식으로 데이터를 넣고 빼는 작업</li>
    </ul>
  </li>
  <li>[Priority Queue 1: Max(Min) Heap]</li>
  <li>[Priority Queue 2: Min-Max Heap]</li>
  <li>[Priority Queue 3: Heap and Hashing]</li>
  <li>[Priority Queue 4: Deap]</li>
  <li>[Priority Queue 5: Leftist Tree]</li>
  <li>[Priority Queue 6: Binomial Heap]</li>
  <li>[Priority Queue 7: Fibonacci Heap]</li>
  <li>

    <p><img src="/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/0.png" alt="0" /></p>
  </li>
</ul>

<h1 id="job-scheduling-example-priority-queue">[Job Scheduling Example: Priority Queue]</h1>

<ul>
  <li>Consider the following sequence of requests in an operating system:</li>
  <li>multiprocessing을 할 때 여러 process가 도는데,
    <ul>
      <li>예를 들어 바이러스가 침입했고 이를 막기 위한 process가 제일 먼저</li>
      <li>제한된 rsrc를 시간 쪼개가며 쓴다. cpu 입장에서는 다음에 시간을 나누어 process를 돌릴 놈을 나와라 하여 처리해 주고 그 다음 줄 서있는 놈들 중 process 번호, owner , priority일 때 여러 policy로 OS를 만들 수 있다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/1.png" alt="1" /></p>
  </li>
  <li>data 저장소에 처리해달라는 것이 들어가 있고, data 저장소에 들어갔다 나왔다가 계속반복되고 있다. 가장 먼저 들어온 애를 가장 먼저 처리해 주고, OS마다 인터넷에서 동영상 보는 process보다는 운영체제들이 바이러스 및 네트워크 처리 등 priority 높은 process들이 있다.</li>
  <li>data저장소에 element가 있는데 priorty를 가지고 우선순위가 높은 놈 나와, 하는 것이 priority-based
    <ul>
      <li>각각의 원소들이 들어갈 때 계속 들어가고 뺄 때는 priority에 따라 나오게 함.</li>
      <li>데이터 저장 :나올 때 우선순위 설정</li>
    </ul>
  </li>
</ul>

<h2 id="requirement-1">Requirement 1</h2>

<ul>
  <li>CPU executes the process with the highest priority first.</li>
  <li>Use a heap structure – a simple max heap :)</li>
  <li>

    <p><img src="/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/2.png" alt="2" /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_process</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">proc_id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Process</span><span class="p">;</span>
	
<span class="k">static</span> <span class="n">Process</span> <span class="o">*</span><span class="n">_proc_heap</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_proc_heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_proc_heap_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="kt">int</span> <span class="nf">PH_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">PH_full</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">PH_empty</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">PH_insert</span><span class="p">(</span><span class="n">Process</span> <span class="n">item</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">PH_delete</span><span class="p">(</span><span class="n">Process</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="requirement-2">Requirement 2</h2>

<ul>
  <li>
    <p>The priority of processes can be modified after they are placed in the priority queue.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">H_change_priority</span><span class="p">(</span><span class="kt">int</span> <span class="n">proc_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_priority</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>This function requires locating a particular process in the heap, but the basic heap operations provide no efficient way to do it.</li>
      <li>Employ an auxiliary data structure such as a hash table that keeps track of the location of each process in the heap structure.</li>
    </ul>
  </li>
  <li>
    <p>Once the two requirements are satisfied, the operating system can process the following basic commands efficiently</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  INSERT  &lt;proc_id&gt;  &lt;owner&gt;  &lt;priority&gt;
  DELETE
  CHANGEPR &lt;proc_id&gt; &lt;new_priority&gt; PRINTHEAP
  END
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-22-pq1-maxmin-heap-1">[ALG] 2.2. PQ1: Max(Min) Heap (1)</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_ref_. [Horowitz 5.6.2] [Neapolitan 7.6]


# PQ1: Max(Min) Heap

- Problem
	- The following operations must be performed as mixed in data processing:
		- Store a record with a key in an arbitrary order.
		- Fetch the record with the current largest key.
- A solution
	- &lt;u&gt;Design a&lt;/u&gt; &lt;u&gt;**data structure**&lt;/u&gt; that offers an efficient implementation of the following operations:
- &lt;u&gt;**Insert an element with an arbitrary key.**&lt;/u&gt;
- &lt;u&gt;**Delete an element with the largest key.**&lt;/u&gt;

	![3](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/3.png)

	- key = priority 의미
		- 두 가지 operation을 효율적으로 구현하는 자료구조를 설계하여 구현하라
		- insert, delete 등 용어는 알아서 생각하면 될 것.
- 배열 array 가지고 구혆할 수 있는 방법
	- 0, 1, 2, 3. .. 끝에다 계속 집어넣으면 됨
	- 제일 끝에 있는 애를 보내주면 끝이 된다.
	- insert하고 delete의 연산이 있는데, data가 현재 배열 data 저장소에 n개 원소가 있을 때 insert, delete의 비용은
		- insert $O(1)$
		- sequential search → delete $O(n)$
- system 들어가는 것은 느려도 상관 없는데 나올 때는 빨리 나와야 한다고 하면 array가 더 좋을수도 있음
	- 일반적으로 heap이 성능이 좋기는 함

	![4](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/4.png)


	|        | array | array | heap     |
	| ------ | ----- | ----- | -------- |
	| insert | O(1)  | O(n)  | o(log n) |
	| delete | O(n)  | O(1)  | O(log n) |
</code></pre></div></div>

<p>undefined
	# An Array Implementation</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Ref. [Sedgewick 9.2]

	```c
	void PQinit();
	int PQempty();
	void PQinsert(int);
	int PQdelmin();
	void PQdec(int);
	
	#include &lt;stdlib.h&gt;
	static int *pq;
	static int N;
	#define MAX_N 10000;
	
	void PQinit()
	{
	    pq = malloc(MAX_N * sizeof(int));
	    N = 0;
	}
	int PQempty()
	{
	    return N == 0;
	}
	void PQinsert(int v)
	{
	    pq[N++] = v;
	}
	
	int PQdelmin()
	{
	    int j, min = 0;
	    for (j = 1; j &lt; N; j++)
	        if (less(pq[min], pq[j]))
	            min = j;
	    exch(pq[min], pq[N - 1]);
	    return pq[--N];
	}
	
	int less(int i, int j)
	{
	    return **... * *;
	}
	
	void exch(int i, int j)
	{
	    ...
	}
	
	void PQdec(int k)
	{
	    ...
	}
	```

- What will be the worst-case time complexity of each operation?

# Max(Min) Heap: Definitions


![5](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/5.png)

- tree
	- rooted tree
		- 일반적인 tree에서 vertex를 하나 잡아 올려 root
		- binary - 최대 두 개 까지의 child를 가지는 tree
		- full binary tree : 모두 두개 child를 갖는 tree
		- complete binary tree : 제일 끝의 leaf 몇 개만 날아간 bt
			- pointerless representation
			- 왼쪽 child는 parent의 두 배, 오른쪽 child는 parent의 두 배 +1
	- a kind of graph
		- connected + acyclic
		- vertex, edge

## Definition 1

- [Horowitz 5.6.2] [Neapolitan 7.6]
- A max(min) heap is a complete binary tree where the key value in each internal node is no smaller(larger) than the key values in its children.

## Definition 2

- A binary tree has the max(min) heap property if and only if
	- The number of nodes of the tree is either 0 or 1, or
	node 0개거나 1개면 max heap
	- For the tree that has at least two nodes, the key in the root is no smaller(larger) than that in each child and the subtree rooted at the child has the max(min) heap property.
	
	root node는 자신의 child보다 같거나 작지 않다 (같거나 크다)
	그리고 각각의 child를 root으로 하는 subtree.
	- 나랑 같이 생겼는데 size만 작은 것의 성질 : recursion 성질을 잘 생각해보면 밑으로 내려가면 결국 어떤 node든 건에 parent는 child보다 크다.
- A &lt;u&gt;max(min) heap&lt;/u&gt; is a complete binary tree that has the &lt;u&gt;max(min) heap property.&lt;/u&gt;
	- max heap : complete BT - max heap property를 갖는

![6](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/6.png)


### Brainstorming on Max Heap Operations

- Max Heap Example
	- 성질을 잘 이해할 것 : 자기 자신보다 같거나 크니까 36이 아니라 101이어도괜찮음
- Deletion Example 1
	- data 저장된 것들 중 priority/key 제일 큰 것 나감. - 103
	- 계속해서 complete BT 유지하려고 하는데 대장 103이 나가버림.
	- 원래 있던 것보다 원소 개수가 하나 더 줄은, heap을 유지하는 방법은 어떻게 되는가?

		→ 자식보다 같거나 크다는 성질 : 101을, 99를 올리느냐 고민하며 101이 올라가며 빈 곳을 다른 node들이 채워 줌.


		max heap property가 깨지기 때문에 아님. 무조건 하나씩 위로 올리는 것은 아님을 확인할 수 있음. 9를 올리면 맨 끝 13은 해결할 수 없음


	![7](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/7.png)

- Deletion Example 2
	- 13을 왕 시키면 항상은 문제 생기지 않음
		- 우연히 밑의 원소가 13일 때는 문제가 안생기겠지만.
	- child에서 101, 99중에 이 동네 왕 한번 해 볼까 하고 살펴보는 그 상황ㅇ으로 바뀌게 됨. 13이 왕 해볼까 하는 상황에서 101을 올려보는 상황이고 왼쪽 아래로 내려감.
	- 많은 tree의 문제들이 recursion 자체를 서서 활용가능함
	- delete alg의 최대 비용, 시간 비용 - 최대 몇 칸까지 내려가는가 (3칸) - log적으로 보여얗 ㅏㅁ
	- complete bt는 됨.
	- 경로에 있는 애들은 ‘내가 내 child보다 크다’라는 heap 조건을 잘 지켰음
	- 두 child보다 큰 13 &gt; 9, 6의 형태 - 두 child보다 같거나 크다는 성질을 유지하며 내려옴./
- Insertion Example
	- 50을 집어넣어라. 그러면 complete bt 만들어야 하나ㅣ node를 하나 만들고 100을 집어넣는다.
	- root까지의 path 경로에 있는 관계만 따지면 됨 :
		- left family에서 100이 있건 없건 아무 상관없음 (heap의 정리에 의해서)
		- 형제 관계 중에서도 상관없고, 중요한 건 부모와 나의 관계일 뿐
		- 경로를 쫓아 올라가며 부모를 보고 부모보다 크면 자신잉 부모가 됨. (부모보다 작으면 그 시점에서 멈춤. 같은 논리로, 경로를 max heap 성질을 유지하면서 왔고 + 나머지는 유지가 되어 있고 → 알고리즘의 합리성 검증
		- 최악의 경우 log(n) time

	![8](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/8.png)

- $C = \log_2 n$
- Deletion from a Max Heap
- ref. [Horowitz 5.6.2]

	```c
	#define MAX_ELEMENTS 200
	#define HEAP_FULL(n) (n == MAX_ELEMENTS - 1) #define HEAP_EMPTY(n)(!n)
	typedef struct
	{
	    int key;
	    /* other fields */
	} element;
	element heap[MAX_ELEMENTS];
	int n = 0;
	```


	![9](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/9.png)


	$2^c \leq n &lt; 2^{c+1} \rightarrow c \leq log_2 n &lt;c+1$


	```c
	//최대 히프에 삽입
	void insert_max_heap(element item, int *n)
	{
	    int i;
	    if (HEAP_FULL(*n))
	    {
	        fprintf(stderr, "the heap is FULL\n");
	        exit(1);
	    }
	    i = ++(*n);
	    while ((i != 1) &amp;&amp; (item.key &gt; heap[i / 2].key))
	    {
	        heap[i] = heap[i / 2];
	        i /= 2;
	    }
	    heap[i] = item;
	}
	
	```


	![10](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/10.png)


	$C \sim log_2n $


	```c
	element delete_max_heap(int *n)
	{
	    int parent, child;
	    element item, temp;
	    if (HEAP_EMPTY(*n))
	    {
	        fprintf(stderr, "The heap is empty\n");
	        exit(EXIT_FAILURE);
	    }
	
	    item = heap[1];
	
	    temp = heap[(*n)--];
	    parent = 1;
	    child = 2;
	    while (child &lt;= *n)
	    {
	
	        if ((child &lt; *n) &amp;&amp; (heap[child].key &gt; heap[child + 1].key))
	            child++;
	        if (temp.key &lt;= heap[child].key)
	            break;
	
	        heap[parent] = heap[child];
	        parent = child;
	        child *= 2;
	    }
	    heap[parent] = temp;
	    return item;
	}
	```


	![11](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/11.png)


	![12](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/12.png)


	$O(\log n)$

- child가 있을 때까진 내려가야 한다.
	- child가 2개면 left , right 중 큰 거 선택해서 줄줄줄 while 문에서 돈다.
- 중간고사에서 빈칸 매꾸기 문제 가능

	child 2개 : 


# Another Heap Implementation (Min Heap)

- _ref_. [Sedgewick 9.3]

	```c
	void PQinit(int);
	int PQempty();
	void PQinsert(int);
	int PQdelmin();
	static int *pq;
	static int N;
	void PQinit(int maxN)
	{
	    pq = malloc(maxN * sizeof(int));
	    N = 0;
	}
	
	int PQempty()
	{
	    return N == 0;
	}
	
	void PQinsert(int v)
	{
	    pq[++N] = v;
	    fixUp(pq, N);
	}
	
	Item PQdelmin()
	{
	    exch(pq[1], pq[N]);
	    fixDown(pq, 1, N - 1);
	    return pq[N--];
	}
	
	fixUp(int a[], int k)
	{
	    while (k &gt; 1 &amp;&amp; a[k / 2] &gt; a[k])
	    {
	        exch(a[k], a[k / 2]);
	        k = k / 2;
	    }
	}
	
	fixDown(int a[], int k, int N)
	{
	    int j;
	    while (2 * k &lt;= N)
	    {
	        j = 2 * k;
	        if (j &lt; N &amp;&amp; a[j] &gt; a[j + 1])
	            j++;
	        if (a[k] &lt;= a[j])
	            break;
	        exch(a[k], a[j]);
	        k = j;
	    }
	}
	```

- What will be the worst-case time complexity of each operation?

&gt; 💡 sort by comparisoin algorithm. 원소 n개 있을 때 n log n 속도 보다 빠르게 불가능하다.


## Comparisons of Priority Queue Implementations


![13](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/13.png)


# Heap Sort


Horowitz 7.7., Neapolitan 7.6

- Method
	1. Convert an input array of n unordered items into a max heap.
	2. Extract the items from the heap one at a time to build an ordered array.
- Sort by comparison : comparison을 통해 정렬하는 방법은 input size n에 대해서 cost는 아무리 좋은 알고리즘을 만들더라도 $O(n \log n)$보다 더 빠르게 할 수는 없다 (optimal이다)
	- 불가능하다고 증명된 바 있음

	&gt; 💡 원소의 개수 n에 대해서 정렬이 안된 임의의 배열에 대해서 min, max heap은 ilnear time에 적용할 수 있다. 그리고 그 둘은 유용한 자료구조

- max heap : 크기가 같거나 큰 순서대로 데이터를 정렬하는 것이 목표인데, max heap 상태에서는 정렬은 정확하게는 안 되어있는 어정쩡한 상태. 대충 정렬은 된 듯한데 중간에 삐쭉한, 정확하게 맞지는 않은 상태.
- unordered data를 크기 순서대로 정리하려고 함. 한 단계 중간단계를 거쳐서 max heap 으로 변경한 다음 ordered 단계로 변환

![14](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/14.png)

- 1번 단계의 시간 복잡도 - n이 걸리고 2번에서 n이 걸려서 N log n 타임의 데이터를 정렬한다.
- 주어진 정수들을 비감소 순서(non-decreasing order)대로 정렬하라.
	- nondecreasing ≠ increasing (단조증가 등의 차이)

	```c
	typedef struct
	{
	    int key;
	    /* other fields */
	} element;
	Element list[MAX_SIZE];
	```


	```c
	void heapsort(element list[], int n)
	{
	    /*perform heapsort on the array*/ int i, j;
	    element temp;
	
	    // (1) Make a (max) heap
	    for (i = (n) / 2; i &gt; 0; i--)
	        adjust(list, i, n);
	
	    // (2) Extract items one by one
	    for (i = n - 1; i &gt; 0; i--)
	    {
	        SWAP(list[1], list[i + 1], temp);
	        adjust(list, 1, i);
	    }
	}
	```

	- (1) Make a (max) heap : $O(n)$
	- (2) Extract Items : $O(n \log n)$

→ n log n


upper bound eㅚ면서 operation들이 없어지고 다 하면 각각은 tight upper bound


제일 큰 거 나와 해서 집어넣어주고 n-2개 대해서 똑같은거 반복하니까 


log n-1


처음에 n개 있었는데 나머지 n-1개에 대해서 어떤 node가 leaf에 들어갈 수 있는지 없는지 확인


$2^c \leq n &lt; 2^{c+1} \rightarrow c \leq \log_2 n &lt;c+1$


## Make a Max Heap

1. $O(n\log n) \rightarrow O(n\log n)$
	- Make a (max) heap.

		![15](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/15.png)


		![16](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/16.png)


		![17](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/17.png)


		![18](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/18.png)


		![19](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/19.png)


## The `adjust()` function


&gt; 💡 과거 알고리즘 만든 사람의 논리를 분석해서 적용해보자. 그러면 computatinoal thinking 상황에서 자연스럽게 파악하며 성장할 수 있다!

- cost : 각각에 대해서 핵심이 되는 operation
	- root에서 시작해서 두 child중에 큰 것 (list[child].key &lt;
- 어떻게 생각했을까 추적해보면 : ‘혹시 정의에 의해서 :
	- 정의 : root node는 두 child보다 같거나 크고, 각각의 child를 root로 하는 subtree가 max heap이면 recursive한 max heap이 구성된다
	- 두 child를 root로 하는 tree
- code

	```c
	void adjust(element list[], int root, int n)
	{
	    int child, rootkey;
	    element temp;
	    temp = list[root];
	    rootkey = list[root].key;
	    child = 2 * root;
	    while (child &lt;= n)
	    {
	        if ((child &lt; n) &amp;&amp; (list[child].key &lt; list[child + 1].key))
	            child++;
	        if (rootkey &gt;= list[child].key)
	            break;
	        else
	        {
	            list[child / 2] = list[child];
	            child *= 2;
	        }
	    }
	    list[child / 2] = temp;
	}
	```


	![20](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/20.png)

	- Executed d times, where d is the depth of the tree with root i → $O(d)$

# Cost of Make-Heap


![21](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/21.png)

- Executed d_d_ times, where d_d_ is the depth of the tree with root i_i_
	- So $O(d)$ time
- `Output`: a binary tree T adjusted so that the entire binary tree satisfies the heap property
- `Input`: a binary tree T whose left and right subtrees satisfy the heap property but whose root may not

## Proof of correctness of Heap Construction Algorithm


```c
//make a max heap
for(i =n/2;i&gt;0;i--)
	adjust(list,i,n);
```

- $i = \frac n 2 , \frac n 2 -1, \frac n 2 -2, ... 2, 1$
- Loop Invariant
	- just before each iteration for the for-loop starts, each node numbered i+1, i+2, … n is the root of a max heap
- Proof of correctness by mathematical Induction
	- base step (base case, basis)
		- when $i = \frac n 2 $ (why?)
	- induction step (inductive step)
		- assume that the loop invariant holds for $i=k(k&lt;\frac n 2)$
		- then it also holds for $i = k-1$
			- $k+1, k+2, ... n \rightarrow k, k+1, k+2, ... n$
			- fact 1 : each child node of node k is a max-heap
			- fact 2 : the `adjust()` function makes the node k a root of max-heap
			- fact 3 : it also preserves the property that the nodes k+1, .. n are roots of max-heaps
- notes
	- when the for-loop terminates, the node 1 is the root of a max-heap

## Extract items one by one.

- 꼼꼼히 따져보면서 성적 및 시험에서 그동안 기출 문제를 올릴 예정인데, 이를 강조하는 이유가 나타날 듯
- 제일 큰 놈 나왈 해서 leaf에다 집어넣고,
	- 비용이 n log n : 매번 해 주는 비용을 생각해보면
	- 매번 제일 큰 것 나와 해서 줄줄줄 update를 반복하다보면 제일큰 것 순서대로 쌓이게 될 것.

![22](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/22.png)

- Time Complexity Analysis
	- $2^k \leq 2n2k≤2n, −k&lt;−\log2n$
		- $k &lt; -\log_2 n$
	- then $2k−k−1&lt;2n−\log2n−1$

		$2^k -k -1 &lt; 2n - log_2n -1$

	- so $C_{MH} = O(n)$
- $I = -k+ \frac {1 \cdot (2^k-1)}{2-1} = 2^k -k -1I=−k+2−11⋅(2k−1)=2k−k−1$

	$∴ C_{MH} \leq 2^k -k -1$

- $2I= (k-1)2^1 + (k-2)2^2 + (k-3)2^3 + ...+1 \cdot 2^{k-1}$
	- $\rightarrow 2I-1I= -(k-1) + 2^1+ 2^2 + ... + 2^{k-2}$
- $I= (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \cdot 2^{k-2}$
- $C_{MH} \leq (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \cdot 2^{k-2}$

![23](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/23.png)


$2^{k-1} \leq n &lt; 2^k$ → $k-1 \leq \log_2 n &lt; k$


## Complexity of Item Extractions


![24](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/24.png)


```c
for (int i = n / 2; i &gt; 0; i--)
    adjust(list, i, n);
for (int i = n - 1; i &gt; 0; i--)
{
    SWAP(list[1], list[i + 1], temp);
    adjust(list, 1, i);
}
```

- Heap Sort : $C_{MH} +C_{IE} = O(n)+ O(n \log n) = O(n \log n)$
- $C_{IE}
\\=⌊\log (n-1)⌋+⌊\log (n-2)⌋+⌊\log (n-3)⌋...+⌊\log2⌋+⌊\log 1⌋\\ \leq \log2 + \log3 + ...+\log {(n-1)} = \log (n-1)!\\=O((n-1)\log (n-1)) = O(n \log n)\\&lt; \sum_{i=2}^n \log_2 n
\\= O(n \log n)
\\≤log2+log3+...+log(n−1)\\&lt;∑i=2n \log 2n\\ =O(n \log n)$
- for a given $n$, the cost (depth) is $c = ⌊\log_2n⌋$
- $O(\log n!) = O(n \log n)$
	- proof

## Heap Sort in C Implementation

- 상황에 맞게 판단하여 적용
	- constant time , log n하고는 엄청난 차이가 존재하는 시간 복잡도
	- 2^20이 백만인데 그에 비례하는 시간,

# Priority Queue 2 : Min-Max Heap

- Problem
	- The following operations must be performed as mixed in data processing:
		- Store a record with a key in an arbitrary order.
		- Fetch the record with the current largest key.
		- Fetch the record with the current smallest key.
- A solution
	- Design a data structure that offers the efficient implementation of the following operations (Double-Ended Priority Queue):
		- Insert an element with an arbitrary key.
		- Delete an element with the largest key.
		- Delete an element with the smallest key.
		- → 어떻게 풀 것인지

O(log n) → 

- ref._ref_. [Horowitz 9.1]

---


{교육과정 외}


Priority Queue 3: Heap and Hashing


Priority Queue 4: Deap


Priority Queue 5: Leftist Tree


Priority Queue 6: Binomial Heap


Priority Queue 7: Fibonacci Heap
</code></pre></div></div>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[Heap-based Priority Queue, Heap Sort]]></summary></entry><entry><title type="html">[ALG] 1. Introduction</title><link href="http://localhost:4000/ALG-1.-Introduction" rel="alternate" type="text/html" title="[ALG] 1. Introduction" /><published>2022-09-02T00:00:00+09:00</published><updated>2022-09-02T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-1.-Introduction</id><content type="html" xml:base="http://localhost:4000/ALG-1.-Introduction"><![CDATA[<p>Algorithm : Big O and MSS</p>

<h1 id="10-computational-thinking"><strong>1.0. Computational Thinking</strong></h1>

<h2 id="definition-of-computational-thinking"><strong>Definition of computational thinking</strong></h2>

<p>The thought processes involved in (i) formulating a problem and (ii) expressing its solutions in such a way that a computer –human or machine- can effectively carry out.</p>

<ol>
  <li>Problem formulation (abstraction)</li>
  <li>Solution expression (automation)</li>
  <li>Solution execution &amp; evaluation (analyses)</li>
</ol>

<h2 id="characteristics-of-computational-thinking"><strong>Characteristics of computational thinking</strong></h2>

<ul>
  <li>Formulating problems in a way that enables us to use a computer and other tools to help solve them</li>
  <li>Logically organizing and analyzing data → Data structure</li>
  <li>Representing data though abstractions such as models and simulations → Data Structure</li>
  <li>Automating solutions through algorithmic thinking (a series of ordered steps) → Algorithm</li>
  <li>Identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and effective combination of steps and resources → time and space complexity</li>
  <li>Generalizing and transferring the problem solving process to a wide variety of problems</li>
</ul>

<h2 id="problem-solving-in-computer-science-and-engineering"><strong>Problem Solving in Computer Science and Engineering</strong></h2>

<p>문 제 (Problem) → 해 (Solution)</p>

<ul>
  <li>Problem : 가상 현실, 문서작성, 홈뱅킹, 인터넷 신문, 문서 번역, 회로 설계, 유전자 분석, 무인 자동차, 온라인 게임, 비디오 편집, 자료 검색, 영화 제작, 음성 인식, 가상 수술, 건축 설계, 기상 예측, 주가 예측, 인공 지능, 대용량 과학 계산, …</li>
</ul>

<h2 id="problem-solving-pipeline"><strong>Problem Solving Pipeline</strong></h2>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/0.png" alt="0" /></p>

<h1 id="도강-문제"><strong>도강 문제</strong></h1>

<p>한 어부(M)가 늑대(W), 염소(G), 양배추(C)를 강 한 쪽에서 다른 쪽으로 옮기려 한다. 어부가 배를 타고 강을 건널 때 어부 자신 외에 늑대, 염 소, 양배추 중 하나만 배에 가지고 갈 수가 있는데, 문제는 어부가 늑대 를 싣고 가는 동안, 염소가 양배추를 같은 쪽에 남겨두면 염소가 양배 추를 먹어버리게 되고, 양배추를 싣고 갈 때 늑대와 염소를 같은 쪽에 남겨둘 경우 늑대가 염소를 잡아 먹게 된다. 과연 어떻게 하면 어부가 가장 적은 회수로 강을 건너면서 세 가지를 모두 안전하게 옮길 수 있을까?</p>

<h2 id="문제-분석"><strong>문제 분석</strong></h2>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/1.png" alt="1" /></p>

<ul>
  <li></li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/2.png" alt="2" /></p>

<h2 id="해법-고안"><strong>해법 고안</strong></h2>

<ul>
  <li>Graph, search, and so on → Which data structures and algorithms?</li>
  <li>Cost, time, space, and so on → What complexities?</li>
</ul>

<p>[연습] 이 문제에 대한 알고리즘과 시간/공간 복잡도를 컴퓨터학의 용 어를 써서 기술한다면, ???</p>

<ul>
  <li>무슨 말인지 전혀 모르겠으면 [43-080 자료구조]를 재수강한 후 이 과목을 들을 것!</li>
</ul>

<h1 id="구현---programming-is-an-art"><strong>구현 : ✓ Programming is an art!</strong></h1>

<ul>
  <li>어떻게 하면 주어진 알고리즘을 가장 효과적으로 구현을 할 수 있을까?</li>
  <li>어떻게 하면 C/C++를 사용하여 주어진 알고리즘을 가장 최적으로 구현할 수 있을까?
    <ul>
      <li>원시 코드 레벨의 측면</li>
      <li>어셈블러 레벨의 측면</li>
      <li>시스템 레벨의 측면</li>
      <li>기타</li>
    </ul>
  </li>
  <li>✓ 과연 내가 <a href="http://acm.uva.es/problemset/%EC%97%90">http://acm.uva.es/problemset/에</a> 있는 문제들을 스스로 “문제 분석 → 해법 고안 → 구현” 과정을 통하여 효과적으로 해결할 수 있을까???
    <ul>
      <li>Programming Challenges by S. Skiena and M. Revilla, Springer, 2003.</li>
    </ul>
  </li>
  <li>어떻게 하면 좋은 구현 결과를 얻을 수 있는가?
    <ul>
      <li>동일한 프로세서 상에서 더 빠르게</li>
      <li>적은 메모리만 사용하게</li>
      <li>안정적이게</li>
    </ul>
  </li>
  <li>
    <p>구현 예</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/3.png" alt="3" /></p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/4.png" alt="4" /></p>
  </li>
</ul>

<p>19 0.265968초 4.862961초 3.4GHz Intel Core i7 CPU</p>

<h1 id="data-structure--algorithm--theory-of-computation"><strong>Data Structure → Algorithm → Theory of Computation</strong></h1>

<ul>
  <li>어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?
    <ol>
      <li>[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?</li>
      <li>[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까?</li>
      <li>[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?</li>
      <li>[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결할 수 있을까?</li>
    </ol>
  </li>
  <li>✓ 이 과목에서는 [CSE3080 자료구조] 과목에 이어, 1번과 2번을 집중적으로 살펴보 고, 3번 문제에 대하여 어느 정도 살펴볼 예정임.</li>
  <li>4번 문제는 [CSE3085 자동장치이론] 과목에서 다룸.</li>
</ul>

<h1 id="11---12-solve-with-alg"><strong>1.1 - 1.2 Solve with Alg</strong></h1>

<h1 id="1-how-to-think-and-solve-problems-with-computer"><strong>1. How to think and solve problems with computer</strong></h1>

<h2 id="data-structurealgorithmtheory-of-computation"><strong>Data Structure→Algorithm→Theory of Computation</strong></h2>

<ul>
  <li>어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?
    <ol>
      <li>[Data Structure] 주어진 추상적인 문제를 <strong>어떠한 자료 구조</strong>를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?</li>
      <li>[Algorithm] 주어진 추상적인 문제를 어떠한 <strong>알고리즘을</strong> 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까</li>
      <li>[Complexity] 과연 컴퓨터가 주어진 문제를 <strong>효율적으로</strong> 해결할 수 있을까 ?</li>
      <li>[Computability] 과연 컴퓨터가 세상의 <strong>모든 문제를 해결</strong>할 수 있을까?</li>
    </ol>
  </li>
  <li>Data Structure &amp; Algorithm → 1, 2, 3</li>
  <li>Automata Theory → 4</li>
</ul>

<h1 id="2-def-of-algorithm"><strong>2. Def. of Algorithm</strong></h1>

<h2 id="definition-of-algorithm"><strong>Definition of Algorithm</strong></h2>

<p>from [Horowitz 1.2]</p>

<ul>
  <li>An <strong>algorithm</strong> is a <strong>finite set of instructions that</strong>, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:
    <ol>
      <li><strong>Input</strong>.
        <ul>
          <li>Zero or more quantities from the outside.</li>
          <li>외부로부터 0개 이상의 수량이 입력으로서 들어온다.</li>
        </ul>
      </li>
      <li><strong>Output</strong>.
        <ul>
          <li>At least one quantity is produced.</li>
          <li>하나 이상의 결과값이 수행된다.</li>
        </ul>
      </li>
      <li><strong>Definiteness</strong>.
        <ul>
          <li>Each instruction is clear and unambiguous.</li>
          <li>각 지침은 모두 명확하며, 애매하게 쓰여 있지 않다.</li>
        </ul>
      </li>
      <li><strong>Finiteness</strong>.
        <ul>
          <li>If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.</li>
          <li>제한된 수의 단계 후 종료된다.</li>
        </ul>
      </li>
      <li><strong>Effectiveness</strong>.
        <ul>
          <li>Every instruction must be basic enough to be carried out, in principle, by a person using only pencil and paper.</li>
          <li>손으로 풀 수 있을 만큼 효과적이어야 한다.</li>
          <li>It is not enough that each operation be definite as in (3);</li>
          <li>it also must be feasible. 또한 실현 가능하여야 한다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="thoughts-on-4-finiteness-computability"><strong>Thoughts on 4) Finiteness: [Computability]</strong></h2>

<ul>
  <li>Problem (<a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Post’s correspondence problem</a> 포스트 대응 문제)
    <ul>
      <li>결정 불가능한 결정 문제의 예시, 1946년 emil post 에 의해 고안</li>
      <li>Consider a finite set <em>P</em> of ordered pairs of nonempty strings such as <em>P</em>={(<em>a</em>,<em>ab</em>),(<em>b</em>,<em>c__a</em>),(<em>c__a</em>,<em>a</em>),(<em>ab__c</em>,<em>c</em>)}</li>
      <li>A match of <em>P</em> is any string w such that, for some <em>m</em>&gt;0 and some pairs (<em>u_1,_v_1),(_u_2,_v_2),…,(_u__m</em>,<em>v__m</em>)∈<em>P</em>, <em>w</em>=<em>u_1_u_2…_u__m</em>=<em>v_1_v_2…_v__m</em>.</li>
      <li>Design an algorithm that determine, given P, whether P has a match.</li>
    </ul>
  </li>
  <li>
    <p>Cheolsu’s algorithm</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">For</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">...</span> <span class="k">do</span>
    <span class="n">For</span> <span class="n">each</span> <span class="n">permutation</span> <span class="n">of</span> <span class="n">P</span> <span class="n">of</span> <span class="n">length</span> <span class="n">i</span><span class="p">,</span> <span class="k">do</span>
      <span class="n">If</span> <span class="n">it</span> <span class="n">is</span> <span class="n">a</span> <span class="n">match</span><span class="p">,</span> <span class="n">print</span> <span class="err">‘</span><span class="n">yes</span><span class="err">’</span> <span class="n">and</span> <span class="n">exit</span><span class="p">.</span>
      <span class="n">If</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span><span class="p">.</span>
	
</code></pre></div>    </div>

    <ul>
      <li>Can this be regarded as an algorithm?</li>
    </ul>
  </li>
</ul>

<h2 id="thoughts-on-efficiency-complexity"><strong>Thoughts on Efficiency: [Complexity]</strong></h2>

<ul>
  <li><strong>An algorithm is regarded as efficient or good</strong> if there exist a polynomial <em>P</em>(<em>n</em>) such that the time required for solving any instance of size <em>n</em> is bounded above by <em>P</em>(<em>n</em>).</li>
  <li>NP-Complete problems:
    <ul>
      <li>Nobody has found so far any good algorithm for any problem in this class.</li>
      <li>It has been proved that if a good algorithm exists for some algorithm in this class, then a good algorithm exists for all NP-Complete Problem.</li>
    </ul>
  </li>
  <li>Examples
    <ul>
      <li>Suppose a CD-ROM can store up to 720MBytes of data. You have a sequence of n files of sizes <em>s_1,_s_2,…,_s__n</em> Mbytes, to dump into backup CDs. What is the minimum number of necessary CDs to store all the files?</li>
      <li>Consider n tasks to be executed on CPU. All the tasks must be finished within the time requirement L (seconds). If the <em>i_th task takes _s__i</em> seconds, and you can harness multiple processors, what would be the minimum number of processors needed to accomplish this?</li>
      <li>Ex. <em>L</em>=10, <em>n</em>=6, and $(s_1, s_2, s_3, s_4, s_5, s_6) = (5, 6, 3, 7, 5, 4) $</li>
      <li>then (5,5),(6,4),(7,3)</li>
    </ul>
  </li>
</ul>

<p>어떻게 하면 좀 더 “효율적으로” 문제를 해결할까?</p>

<h2 id="efficient-algorithm-design"><strong>Efficient Algorithm Design</strong></h2>

<p><strong>Example 1</strong></p>

<ul>
  <li>Sequential search vs binary search
    <ul>
      <li>Problem: Determine whether <em>x</em> is in the sorted array <em>S</em> of <em>n</em> keys.</li>
      <li>Inputs: positive integer <em>n</em>, sorted (nondecreasing order) arrays of keys S indexed from 0 to <em>n</em>−1, a key <em>x</em>.</li>
      <li>Outputs: the location of <em>x</em>∈<em>S</em> (−1 if <em>x</em>∈/<em>S</em>).</li>
    </ul>
  </li>
  <li>Sequential search: <em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
  <li>Binary search: <em>T</em>(<em>n</em>)=<em>O</em>(<em>l__o__g__n</em>)</li>
  <li>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/5.png" alt="5" /></p>

    <ul>
      <li>[From Neapolitan] The number of comparisons done by Sequential &amp; Binary Search when <em>x</em> is larger than all the array items
        <ul>
          <li>40억 개의 element가 array에 있을 때, Sequential Search는 40억 개 항목과 비교하는 반면에 Binary Search는 단 33개의 항목만을 비교한다.</li>
          <li>컴퓨터가 1ns에 whlie loop를 통과할 수 있다고 가정한들 Binary search는 즉각적으로 결정을 내리는 반면 Sequential Search는 4s가 걸린다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why is the binary search more efficient? 왜 이진검색이 더 효율적인가?</li>
</ul>

<p><strong>Example 2:The Fibonacci Sequence</strong></p>

<ul>
  <li>Problem: Determine the _n_th term in the Fibonacci sequence.</li>
  <li>Inputs: a nonnegative integer <em>n</em></li>
  <li>
    <p>Outputs: the nth term of the Fibonacci sequence.</p>

    <p><em>f_0=0_f_1=1_f__n</em>=<em>f__n</em>−1+<em>f__n</em>−2 for <em>n</em>≥2</p>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//&lt;recursive: divide-and-conquer&gt;</span>
<span class="kt">int</span> <span class="nf">fib</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//&lt;iterative: dynamic programming&gt;</span>
  <span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">index</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="n">n</span><span class="p">];</span>
  <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  	<span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
  <span class="p">}</span><span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>Recursive: $T(n) = O(2^n) $</li>
  <li>Iterative: <em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
  <li>Why is the iterative version more efficient?
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/6.png" alt="6" /></p>
      </li>
      <li><em>T</em>(<em>n</em>)&gt;22<em>n</em> for <em>n</em>≥2</li>
      <li>Mathematical induction을 써서 증명해볼 것!</li>
    </ul>
  </li>
  <li>Linear versus exponential
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/7.png" alt="7" /></p>
      </li>
      <li>[From Neapolitan] This table compares these expressions for various values of n. The execution times are based on the simplifying assumption that one term can be computed in 10−9 second.</li>
      <li>The table shows the time it would take ‘Iterative Algorithm’ to compute the nth term on a hypothetical computer that could compute each term in a nanosecond, and it shows a lower bound on the time it would take to execute ‘Iterative Algorithm’.</li>
      <li>By the time n is 80, ‘Recursive Algorithm’ takes at least 18 minutes. When n is 120, it takes more than 36 years, an amount of time intolerable compared with a human life span. Even if we could build a computer one billion times as fast, ‘Recursive Algorithm’ would take over 40,000 years to compute the 200th term. This result can be obtained by dividing the time for the 200th term by one billion.</li>
      <li>We see that regardless of how fast computers become, ‘Recursive Algorithm’ will still take an intolerable amount of time unless n is small. On the other hand, ‘Iterative Algorithm’ computes the nth Fibonacci term almost instantaneously.</li>
    </ul>

    <p>This comparison shows why the efficiency of an algorithm remains an important consideration regardless of how fast computers become</p>
  </li>
</ul>

<h1 id="alg-13-order-of-algorithms-1">[ALG] 1.3. Order of Algorithms (1)</h1>

<ul>
  <li>제일 먼저 생각
    <ul>
      <li>Input Size
        <ul>
          <li>Problem을 풀고자 하는데 이를 sol하고자 하는 algorithm에서, 알고리즘에 들어오는 data의 크기는 어떻게 되는가.
            <ul>
              <li>문제 상황에 따라 가로 n, 세로 m의 데이터가 들어오면 (n,m) n일수도 nm일수도 있다.</li>
            </ul>
          </li>
          <li>data size가 커짐에 따라 얼마나 시간이 걸리는가 분석 : 얼마난 크기의 데이터가 들어왔을 때, 얼마나 시간이 걸리는가.</li>
          <li>시간 분석의 기본 요소 : data의 수</li>
        </ul>
      </li>
      <li>Cost : $g(n)$
        <ul>
          <li>문제가 있을 때 n에 대하여 어느 정도의 비용이 걸리는가.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="obigonotation"><em>O</em> (Big $O$ Notation)</h1>

<blockquote>
  <p>💡 for given two functions $f(n)$ and $g(n)$,</p>

  <p>$g(n) = O(f(n))\iff \exists c \in \mathbb{R}, N \in \mathbb{N}\quad g(n)\leq c\cdot f(n), \forall n \geq N$</p>
</blockquote>

<ul>
  <li>complexity를 따질 때, data size가 작을 때 보다는 커질 때 문제가 발생함을 확인하고 싶음.
    <ul>
      <li>→ 모든 n일 필요는 없고, 그 N보다 큰 모든 input size에 대해서 이러한 조건을 만족하면.</li>
    </ul>
  </li>
  <li>then we say that :$g(n)$ is big O of $f(n)$</li>
  <li>예)
    <ul>
      <li>코드의 비용을 분석해 봤더니
        <ul>
          <li>for loop 1, for loop n 자승만큼 돌게 된다.</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>비용 : $g(n) = c_0 + c_1 n + c_2 n^2$</li>
  <li>예 : $g(n) = 5 + 6 + 7n^2 \leq 8n^2 \quad \forall n \geq 8$
    <ul>
      <li>$8 \cdot n^2 = c \cdot f(n), N = 8$
        <ul>
          <li>n이 커지면 g(n)이 압도적으로 다른 친구들을 누르게 된다.</li>
          <li>다시한번 이야기하지만, n이 커질 때, 내가 분석한 비용은 f(n)이라는 함수에 눌리게 되는 upper bound 개념</li>
        </ul>
      </li>
      <li>$g(n) = O(n^2)$</li>
    </ul>
  </li>
  <li>$g(n) = O(n^{1000})$?
    <ul>
      <li>정의에 의하면 맞음 : 그래프상 확인해보아도 맞음.</li>
      <li>$f(n)\geq g(n) \cdot c$</li>
    </ul>
  </li>
</ul>

<h2 id="notes-for-big-o">Notes for big O</h2>

<ul>
  <li>[Note 1] The big O puts an <u>**asymptotic**</u> <u>upper bound</u> on a function.
    <ul>
      <li>복잡도를 따질 때 ‘몇 초’가 걸린다기 보다는 얼마나 효율적인가를 따지는 척도
        <ul>
          <li>PL, HW 상황에 대해서 implementation 관점에서 개인 차 발생</li>
        </ul>
      </li>
      <li>Asymptotic analysis (from Wikipedia)
        <ul>
          <li>asymptotic : 점근적인</li>
          <li>
            <p>data size가 커질 때, 이 알고리즘이 시간이나 필요로 하는 메모리 사이즈가 얼마나 나빠지는가? → 알고리즘이 요구하는 시간, 메모리 양 등이 얼마나 나쁜 형태로 변화하는지 ‘형태’</p>

            <blockquote>
              <p>If $f(n) = n^2 + 3n$, then as n becomes very large, the term $3n$ becomes insignificant compared to $n^2$. The function f(n)f(n) is said to be “asymptotically equivalent to n^2n2, as $n→∞$”. This is often written symbolically as $f(n) -&gt; n^2$, which is read as “$f(n)$ is asymptotic to $n^2$”.</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>계산 비용이 $0.01n^2$ 과 $100n$ 알고리즘 중 어떤 것이 더 효율적인가?
        <ul>
          <li>이론적인 관점에서 $100n = O(n), 0.01n^2 = O(n^2)$</li>
          <li>input size $n=3$: $0.09 \quad 300$</li>
          <li>input size $n=10^6$: $0.01 \cdot (10^6)^2 = 10^{10}$, $100 \cdot 10^6 = 10^8$</li>
        </ul>

        <p>→ 결국 $O(n^2)$</p>
      </li>
      <li>(Tight) upper bound
        <ul>
          <li>$37log n + 0.1n = O(n)$
            <ul>
              <li>n이 커지면 $\log n$은 상당히 작아짐</li>
            </ul>
          </li>
          <li>$n^2 + 10n = O(n^2)$</li>
          <li>$4(\log n)^2 + n \log n + 100n = O(n \log n)$
            <ul>
              <li>$\log n$ vs $n$ → 당연하게 $\log n$</li>
              <li>$n \log n &gt; {\log n} ^2$</li>
            </ul>
          </li>
          <li>$n^2 + 10n = O(n^{200})$???
            <ul>
              <li>upper bound 맞아 틀린 말은 아니지만, 일반적으로 O Notation을 활용할 때에는 tight upper bound를 선택하여 표현한다.</li>
            </ul>
          </li>
        </ul>

        <blockquote>
          <p>💡 Dominating Term</p>
          <ul>
            <li>지배하는 term을 찾아 Upper Bound를 찾는다.</li>
          </ul>
        </blockquote>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 지배하는 term을 찾아 Upper Bound를 찾는다.   - $\log _en $등 base는 왜 고려하지 않느냐 → 상수에 해당하므로 상관 없기 때문에.
  - $\log _2 n = \frac {\log_e n }{\log_e2}$
</code></pre></div>        </div>
      </li>
    </ul>

    <p>### Growth Rates of Some Common Complexity Functions</p>

    <ul>
      <li>이론적으로는 $n^3$은 efficient하지만 현실적으로는 문제가 발생할 수 있을만한 복잡도</li>
      <li>감당할 수 없을 정도로 커지네 등 asymptotic 특성을 분석하기 위함</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/8.png" alt="8" /></p>

<ul>
  <li>[Note 2] Given a cost function g(n), how do you find the proper complexity function f(n) such that $g(n) = O(f(n))$?
    <ul>
      <li>Suppress lower-order terms and constant factors!</li>
      <li>Example:
        <ul>
          <li>$10^3 + 10^3n + 10^-3 n^2 = O(n^2)$
            <ul>
              <li>then $lim_{n \to \infty} \frac{n^2}{n} = \infty$</li>
            </ul>
          </li>
          <li>$5n \log_3 n + 3(\log_2 n)^2 + n + 6n^2 = O(n^2)$
            <ul>
              <li>then $lim_{n \to \infty} \frac{n}{log_en} = lim _{n \to \infty} = \infty$</li>
            </ul>
          </li>
          <li>$3(log_2 n)^2+ 0.1n = O(?)$
            <ul>
              <li>Dominate Term이 무엇일까?</li>
              <li>$\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}}$ =$\infty, c, 0$
                <ul>
                  <li>$\infty$ : $(\log n)^2$ , $0$ : $n$ , $c$ :</li>
                  <li>L’Hospital Theorem : $\lim _{n \rightarrow \infty}{\frac {f(n)}{g(n)}} = \lim _{n \rightarrow \infty}{\frac {f’(n)}{g’(n)}} $
                    <ul>
                      <li>$\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}} = \lim = \lim _{n \rightarrow \infty} {\frac {2}{n}{}}0$</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>→ Linear Time</li>
            </ul>
          </li>
          <li>$2^{n+5} = O(2^n)$ ??</li>
          <li>$2^{5n} = O(2^n)$??</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="comparing-orders-of-growth">Comparing Orders of Growth</h2>

<ul>
  <li>How do you compare orders of growth of two functions?
    <ul>
      <li>One possible way is to compute the limit of the ratio of two functions in question.</li>
      <li>$x = lim_{n \to \infty } \frac{f_1(n)}{f_2(n)}$
        <ul>
          <li>if <em>x</em>=0, _f_1 has a smaller order of growth than _f_2</li>
          <li>if $x=c$, $f_1$ has a same order of growth than $f_2$</li>
          <li>if $x=\infty$, $f_1$ has a larger order of growth than $f_2$</li>
        </ul>
      </li>
      <li>Ex.1: $\log_2 n $ vs. $\sqrt{n}$
        <ul>
          <li>$lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} = lim_{n \to \infty} \frac{(log_2 n)’}{(\sqrt(n))’} = lim_{n \to \infty} \frac{(log_2 e)\frac{1}{n}}{\sqrt\frac{1}{2\sqrt(n)}} $</li>
        </ul>
      </li>
      <li>Ex.1.2.: $\log_2 n $ vs. $n^{0.0001}$
        <ul>
          <li>$lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} $</li>
        </ul>
      </li>
      <li>Ex.2: $n!$ vs $2^n$ - factorial vs. exponential
        <ul>
          <li>$lim_{n \to \infty} \frac{ n!}{2^n} = lim_{n \to \infty} \frac{\sqrt{2 \pi n} (\frac {n}{e})^n}{2^n}=lim_{n \to \infty }\sqrt{2 \pi n} \frac{({n})^n}{2^n e^n}$</li>
          <li>stirling’s formula : $n! \approx \sqrt{2 \pi n} (\frac {n}{e})^n$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="ωbig-omega-notation">$Ω$ (Big Omega Notation)</h1>

<p>→ Lower Bound</p>

<ul>
  <li>for two given functions $f(n), g(n)$</li>
</ul>

<blockquote>
  <p>💡 $g(n) = \Omega(f(n))g(n)=Ω(f(n)) ⟺ \exists c \in \mathbb{R}, ∃c∈R,$ and $N \in \mathbb{Z^+ \cup {0}}$, s.t. $g(n) \geq cf(n) \forall n \geq N$</p>
</blockquote>

<ul>
  <li>We say that g(n)<em>g</em>(<em>n</em>) is <em>ω</em> of $f(n)$.</li>
  <li>The Ω puts an asymptotic lower bound on a function.</li>
  <li>Ex:
    <ul>
      <li>$37\log n+0.1n=\Omega(n)$</li>
      <li>$n^2 + 10n = \Omega(n^2)$</li>
      <li>$4(logn)^2 +nlogn+100n=\Omega(nlogn)$</li>
      <li>$n^{200} +10n=\Omega(n^2)$</li>
      <li>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/9.png" alt="9" /></p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="θbig-theta-notation">$Θ$ (Big Theta Notation)</h1>

<ul>
  <li>for two given functions f(n)<em>f</em>(<em>n</em>) , g(n)<em>g</em>(<em>n</em>)
    <ul>
      <li>위에서 누르고</li>
      <li>아래에서 누르고</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 $g(n) = \Theta(f(n))g(n)=Θ(f(n)) \iff⟺ g(n) = O(f(n))g(n)=O(f(n)) and g(n) = \Omega (f(n))$</p>
</blockquote>

<ul>
  <li>
    <p>that is,</p>

    <blockquote>
      <p>💡 $g(n) = \Theta (f(n))g(n)=Θ(f(n)) \iff⟺ \exists c,d \in \mathbb{R}∃c,d∈R and N \in \mathbb{Z^+ \cup {0}}N∈Z+∪0 s.t. g(n) \geq cf(n)g(n)≥cf(n) \forall n \geq N∀n≥N$</p>
    </blockquote>
  </li>
  <li>We say that g(n)<em>g</em>(<em>n</em>) is order of f(n)<em>f</em>(<em>n</em>).</li>
  <li>The \ThetaΘ puts an asymptotic bound on a function.</li>
  <li>$0.1n + 10n^2 = O(n^{1000}) / O(n^2)$
    <ul>
      <li>Big O 로 N 자승이다 하며는 tight upper bound를 이야기한다.</li>
    </ul>
  </li>
  <li>Ex:
    <ul>
      <li>$37\log n+0.1n=\Theta(n)$
        <ul>
          <li>$O(n), \Omega(n)$</li>
        </ul>
      </li>
      <li>$n^2 + 10n = \Theta(n^2)$</li>
      <li>$4(logn)^2 +nlogn+100n=\Theta(nlogn)$</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 $\Theta(1)&lt;\Theta(log n)&lt;\Theta(n)&lt;\Theta(n log n)&lt;\Theta(n^2)&lt;\Theta(n^3)&lt;\Theta(n^j)&lt;\Theta(n^k)&lt;\Theta(a^n)&lt;\Theta(b^n)&lt;\Theta(n!)$</p>
</blockquote>

<ul>
  <li>for $k&gt;j&gt;3 , b&gt;a&gt;1$</li>
  <li>O(1) or <em>O</em>(<em>c</em>) : constant
    <ul>
      <li>$g(n) = 0.000001 \cdot n$</li>
      <li>g(n) = 1000000<em>g</em>(<em>n</em>)=1000000</li>
    </ul>
  </li>
  <li>Ref. Neapolitan Ex. (pp.42) 19, 24, 26, 28]</li>
</ul>

<h1 id="big-o-omega-and-order">Big O, Omega, and Order</h1>

<ul>
  <li>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/10.png" alt="10" /></p>
  </li>
  <li>Ref.<em>Ref</em>. [ Neapolitan Chapter 1.]</li>
</ul>

<h2 id="execution-times-for-algorithms-with-the-given-time-complexities">Execution Times for Algorithms with the Given Time Complexities</h2>

<ul>
  <li>n의 k승, 이를 polynomial time (다항 시간)이라고 칭한다.</li>
  <li>n log n, log는 다항식이 아닌데 왜 polynomial이라고 하는가?
    <ul>
      <li>upperbound : n 자승보다 빠르니까 polynomial time에 들어가게 됨.</li>
    </ul>
  </li>
  <li>실제적으로 회사 가서 이 문제를 풀어주는 SW를 해서, 제출한다고 했을 때, n이 커짐에 따라 이러한 효율적인 알고리즘들은 그 피해가 덜한데, 뒤는 피해가 현실적으로 받아들일 수 없을 정도로 커진다. 우리가 이론적으로 구별은 무엇이냐 하면은 polynomial - nonpolynomial alg.를 구분
    <ul>
      <li>$n^6$은 이론적으로는 polynomial - 안 좋긴 하지만</li>
    </ul>
  </li>
  <li>exponential, factorial algorithm은 inefficient, polynomial algorithm은 algorithm
    <ul>
      <li>현실적으로는 cubic도 빡셈</li>
    </ul>
  </li>
  <li>알고리즘 :
    <ul>
      <li>이론적인 측면에서 polynomial time 에 쓰이는가</li>
      <li>프로그램을 구현해서 돌릴 때, 당연히 cuvic보다는 효유적으로 돌아갈 것이다</li>
    </ul>
  </li>
  <li>현실적으루 n이 작을 때에는 그렇게 큰 지장이 없지만, n이 점차 커질 때 log, linear는 잘 버티는 데에 반해 exp, factorial
    <ul>
      <li>processor가 좋아진다 한들 풀고자 하는 문제가 더 커지기 때문에 시대적 needs라기 보다는 항상 우리 곁의 needs</li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/11.png" alt="11" /></p>

    <ul>
      <li>logarithmic, linear, n log n, quadratic, cubic « exp « factorial</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/12.png" alt="12" /></p>

<h1 id="worst-case-vs-average-case-time-complexity">Worst-Case vs. Average-Case Time Complexity</h1>

<ul>
  <li>complexity : time, space complexity
    <ul>
      <li>편의상 time complexity를 따짐</li>
    </ul>
  </li>
  <li><strong>Expected value</strong> (from Wikipedia)
    <ul>
      <li>let X_X_ be a random variable with a finite number of finite outcomes $x_1, x_2, …, x_k$ occuring with probabilities $p_1, p_2, … p_k$ respectively.</li>
      <li>the Expectation of X is defined as :
        <ul>
          <li>$E(X) = \sum_{i=1}^{k }{x_i p_i} = x_1p_1+ x_2 p_2 + … + x_k p_k$</li>
        </ul>
      </li>
      <li>since the sum of all probabilities $p_i$ is 1 (\sum_{i=1}^{k} {p_i}=1∑<em>i</em>=1<em>k__pi</em>=1) , the expected value is the weighted sum of the x_i_xi_ values, with the p_i_pi_ values being the weights</li>
      <li>$a_1, a_2, a_3 \rightarrow b_1 , b_2, b_3$
        <ul>
          <li>input size n에 대해서 모든 가능한 input들의 집합을 S_n</li>
          <li>임의의 input $I$</li>
          <li>$c(I) $ :</li>
          <li>$p(I):$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Worst-case complexity :
    <ul>
      <li>모든 가능한 인풋중에 최악으로 가장 많은 시간이 걸리는 경우. 가장 시간이 많이 걸리는 경우</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$T_W (n) = max { c(I)</td>
              <td>I \in S_n }$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>Average-case complexity
    <ul>
      <li>모든 input에 대해서 일어날 확률 등에 대해 평균을 낸 것.</li>
      <li>$T_A (n) = \sum_{I \in S_n} p(I) c(I)$</li>
    </ul>
  </li>
  <li>Problem
    <ul>
      <li>Find the index of a given value <em>a</em> in a givven array $(a_0, a_1, …,a <em>{n-1})$. if _a</em> doesn’t exist in the array return −1</li>
    </ul>
  </li>
  <li>Cost for a linear search algorithm
    <ul>
      <li>let P_i_Pi_ be the probability such that a= a_i_a_=<em>ai</em></li>
      <li>
        <p>then the average cost is :</p>

        <p>$g(n) = 1 \cdot P_0 + 2 \cdot P_1 + 3 \cdot P_2 + …+ n \cdot P_{n-1} + n (1 - \sum_{k=0}^{n-1} P_k)$</p>

        <p>$= \sum_{k=0}^{n-1} (k+1)P_k + n (1 - \sum_{k=0}^{n-1} P_k)=∑k=0n−1(k+1)Pk+n(1−∑k=0n−1Pk)$</p>

        <ul>
          <li>Ex.1. $n = 10^9$, $P_0 + P_1 + …+ P_{10^3} = 1$ so $g(n)=O(1)$</li>
          <li>Ex.2. $n = 10^9$, $P_0 + P_1 + …+ P_{\frac n {100} }= 1$, so g(n) = O(n)<em>g</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 배우게 될 내용, 중요</p>
</blockquote>

<ul>
  <li>[중요] <strong>참고: Quick sort 알고리즘 →</strong>
    <ul>
      <li>Worst-case : $O(n^2)$</li>
      <li>Average-Case : $O(n \log n)$</li>
    </ul>
  </li>
</ul>

<h1 id="reviews">Reviews</h1>

<h2 id="summation">Summation</h2>

<ul>
  <li>Sums of powers
    <ul>
      <li>$\sum_{i=1}^{n} i = \frac {n(n+1)} {2}$</li>
      <li>$\sum_{i=1}^{n} i^2 = \frac {n(n+1)(2n+1)} {6}$</li>
      <li>$\sum_{i=1}^{n} i^3 = (\frac {n(n+1)} {2})^2$</li>
      <li>$\sum_{i=1}^{n} i^4 = \frac {n(n+1)(2n+1)(3n^2+3n-1)} {30}$</li>
      <li>$\sum_{i=1}^{n} i^s = \frac {(n+1)^{s+1}} {s+1} + \sum_{k=1}^{s} \frac {B_k} {s-k+1} {s \choose k} (n+1)^{s-k+1}$
        <ul>
          <li>$B_k$ is the $k^{th}$ Bernoulli Number.</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} i^{-s} = \prod_{p prime} \frac {1} {1 - p^{-s}} = \zeta(s)$
        <ul>
          <li>$\zeta_k$ is the Riemann zeta function</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Growth rates
    <ul>
      <li>$\sum_{i=1}^{n} i^c \in \Theta(n^{c+1})$
        <ul>
          <li>for real c greater than 1−1</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} \frac 1 i \in \Theta(log n)$</li>
      <li>$\sum_{i=1}^{n} c^i \in \Theta( n \cdot log(n)^{c+1})$
        <ul>
          <li>for real c_c_ greater than 11</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} log(i)^c \in \Theta(n \cdot log(n)^{c})$ for nonnegative real $c$</li>
      <li>$</li>
    </ul>

    <p>\sum_{i=1}^{n} log(i)^c \cdot i^d \in \Theta(n^{d+1} \cdot log(n)^{c})$ for nonnegative real $c, d$</p>
    <ul>
      <li>$\sum_{i=1}^{n} log(i)^c \cdot i^d \cdot b^i \in \Theta(n^{d} \cdot log(n)^{c} \cdot b^n) $for nonnegative real $b&gt;1, c, db&gt;1,c,d$</li>
    </ul>
  </li>
  <li><strong>Read</strong> <a href="http://en.wikipedia.org/wiki/Summation"><em>Summation</em></a>, <a href="http://en.wikipedia.org/wiki/List_of_mathematical_series."><em>Mathematical Series</em></a></li>
</ul>

<h2 id="run-time-analysis">Run Time Analysis</h2>

<p>What is the worst-case time complexity of each loop?</p>

<ul>
  <li>어디가 dominate한가 : SW를 개발 할 때 최적화를 해 주어야 함. program이 도는 것을 보면 어디가 bottleneck이 되어 비효율적인가</li>
  <li>
    <p>(1) Matrix Addition : $O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>(2)$O(n^2)$
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x+= i+j</code>가 i번 수행되고, $\Sigma_{i=1}^N i = \frac{N(N+1)}{2} = \frac {N^2} 2 + \frac N 2$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">x</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(3) $O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">else</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="c1">// N^2</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
      <span class="c1">// N^2</span>
</code></pre></div>    </div>
  </li>
  <li>(4) $O(n^3)$
    <ul>
      <li>$\frac N 2 \cdot N$ . $\frac N 2 N^2$ → $n^3$이 dominate</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span>
          <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="p">{</span>
                  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>(5)
    <ul>
      <li>$\Sigma_{i=1}^N \Sigma_{j=1}^i j= O(N^3)$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="c1">//What if this is i*i?</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>(6)$ \rightarrow O(N^4)$
    <ul>
      <li>$\Sigma_{i=1}^N \Sigma_{j=1}^{i^2} \Sigma_{k=1}^j k= O(N^4)$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//j가 i의 배수이면</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>n 이 작냐, 크냐에 따라서 10만이냐 100만이냐 할 때 어떤 속도로 나빠질 것인가? 얼마나 잘 유지될 것인가?</li>
      <li>항상 j가 1부터 i^2까지 도는데, j%i ==0 일 때 까지만 돈다 : j가 i의 배수인 경우</li>
      <li>j가 i의 배수일 때 :
        <ul>
          <li>$i = 1,2, … n$</li>
          <li>$j = 1, i, 2i, …, i^2$</li>
          <li>$\Sigma_{i=1}^{N}{(1 + i + … + i^2)}$</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>What is the worst-case time complexity of each loop?</p>

<ul>
  <li>
    <p>(1)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n = 2^k for some positive</span>
      <span class="c1">// integer k</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="c1">// some O(1) computation</span>
              <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(2)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n = 2^k for some positive</span>
      <span class="c1">// integer k</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="c1">// some O(1) computation</span>
              <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(3) Could this be faster?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//</span>
      <span class="kt">float</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="err">–</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(4) Magic square : Could this be faster?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n: odd integer</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">key</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span> <span class="n">key</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">])</span>
              <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
          <span class="k">else</span>
          <span class="p">{</span>
              <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
              <span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(5)$ O(\log n)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// compute x^n (n &gt;= 0)</span>
      <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>
          <span class="p">{</span>
              <span class="n">m</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
              <span class="n">z</span> <span class="o">*=</span> <span class="n">z</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">m</span><span class="o">--</span><span class="p">;</span>
          <span class="n">power</span> <span class="o">*=</span> <span class="n">z</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>time complexity. : $c_0 + c_1 n + c_2 n^2 = O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
              <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>time complexity. : $c( ⌊{log_2 n}⌋+1) \cdot n^2 = O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// n &gt; 0</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>for k=1;k≤n;k=k*2</li>
      <li>floor : 3.7 → 3, ceil : 3.7 → 4</li>
      <li>$n=15 \rightarrow \lfloor log_2 15 \rfloor = \lfloor 3.*** \rfloor = 3$</li>
      <li>1 2 4 8 15</li>
    </ul>
  </li>
  <li>
    <p>time complexity. : $??= O( \sqrt n)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// n &gt; 0</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">i</span><span class="o">++</span><span class="p">;</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
          <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-14-mss-1">[ALG] 1.4. MSS (1)</h1>

<blockquote>
  <p>최대 부분 수열의 합 Maximum Subsequence Sum</p>
</blockquote>

<ul>
  <li>어떠한 알고리즘을 설계하느냐에 따라서 어떻게 결과가 달라지는지.</li>
</ul>

<h1 id="maximum-subsequence-sum-mss-problem">Maximum Subsequence Sum (MSS) Problem</h1>

<ul>
  <li><em>Ref</em>. <strong>[M. Weiss,</strong> <strong>Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]</strong>
    <ul>
      <li>Given $N$ (possiblly negative) $A_0, A_1, …, A_{N-1} \in \mathbb{Z}$</li>
      <li>find the maximum value of $\sum_{k=i}^{j} {A_k }$ for $0 \leq i \leq j \leq N-1$</li>
      <li>for convenience, the max subseuqence sum is 0 if all the integers ‘re &lt;0</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>$(-2, 11, -4, 13, -5, -2). → MSS = 20$</li>
      <li>$(a_1, …, a_6)$ : 수열의 모든 가능한 부분수열 중 $\Sigma_{k=i}^j {A_k}$ 임의의 i에서 시작해서 j에서 끝나는 것들을 더했는데 그런 것들 중 제일 큰 것을 찾아라.
        <ul>
          <li>sequence element들은 정수일 때 subsequence를 찾는다.: subsequence의 합이 최대가 되게하는 수열.</li>
          <li>주어진 수열의 정수가 모두 음수이면 mss=0 간주</li>
        </ul>
      </li>
      <li>length = 0, 1, 2로 시작하거나,,
        <ul>
          <li>아무리 빨라도 $n^2$보다 빠르게는 못 만들겠다는 생각이 들 수 있다.
            <ul>
              <li>n개 data 중 가장 작은 것 뽑기 : 한 번씩 sequential search를 해야 하므로 n</li>
              <li>n^2개의 경우는 n^2가 될 것 같은데,</li>
              <li>divide n conquer : $O(N \log N), $ DP : $O(n)$</li>
            </ul>
          </li>
          <li>→ $n + (n-1) + (n-2) + … + 2 + 1 = \frac {n(n+1)}{2} = O(n^2)$</li>
        </ul>
      </li>
      <li>
        <p>이 안에 모든 존재하는 subsequence 중에 합을 가장 크게 하는 subsequence를 찾아라.</p>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/13.png" alt="13" /></p>
      </li>
    </ul>
  </li>
  <li>Maximum Subarray Problem</li>
  <li>Maximum Positive Sum Subarray Problem</li>
  <li>Max. Sum Subsequence versus Max. Subsequence Sum</li>
</ul>

<h1 id="alg-of-maximum-subsequence-sum">Alg of Maximum Subsequence Sum</h1>

<ul>
  <li>길이 n인 정수의 수열 $a_0, a_1, …, a_{n-1}$이 입력으로 주어져 있다.</li>
  <li>여기서 부분 수열 $[i, j]$ 라는 것은 $ a_i, a_{i+1}, a_{i+2}…, , a_{j}$를 말한다.</li>
  <li>a의 최대값을 구하는 문제이다.
    <ul>
      <li>(이때 주어진 수열의 정수가 모두 음수이면 최대 부분 수열의 합은 0 이라고 간주한다)</li>
      <li>예를 들어 다음과 같은 수열이 주어졌을 때, $+ 31, −41, +59, +26, −53, +58, +97, −93, −23, +84$  최대 부분 수열은 [2,6]이며 수열의 합은 187 이 된다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/14.png" alt="14" /></p>
  </li>
  <li>이 문제는 최대 부분 수열의 합을 구하는 것이지만, 앞으로 소개할 알고리즘을 조금만 수정하면 최대 부분 수열도 쉽게 구할 수 있다.
    <ul>
      <li>empty string : letter char=0, NULL String</li>
      <li>substring</li>
      <li>string</li>
      <li>length</li>
    </ul>

    <blockquote>
      <p>Algorithm1 : 모든 경우의 수 찾기 - $O(N^3) $</p>
    </blockquote>

    <blockquote>
      <p>Algorithm2 : Sum구할 때 중복 조금 피하기 - $O(N^2)$ </p>
    </blockquote>

    <ul>
      <li>simple counting
        <ul>
          <li>$O(n^2)$ : SS 여러 개가 있는데 한 번씩 모두 보자.</li>
          <li>$i$에서 시작하는 것들 1, 2, … 개를 모두 보자 : $n^2$개를 모두 본 것.</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/15.png" alt="15" /></p>

    <blockquote>
      <p>Algorithm3 : Divide n Conquer - $O(N \log N)$ </p>
    </blockquote>

    <ul>
      <li>Divide n Conquer
        <ul>
          <li>경우를 나눈다 : MSS subsequence가 존재하는데 이를 반으로 잘라서 분명히 어딘가 존재한다 → 왼쪽 혹은 오른쪽, 아니면 양다리 걸치던지.</li>
          <li>왼쪽 중 제일 큰 것 찾고, 오른쪽 존재 중 제일 큰 것 ㅈ찾고, 양다리 중 제일 큰 것 찾고.</li>
          <li>그중에 제일 큰 것을 찾았는데 O(Nlog N)걸리더라</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/16.png" alt="16" /></p>

    <blockquote>
      <p>Algorithm4 : Dynamic Programming - $O(N)$</p>
    </blockquote>

    <ul>
      <li>DP
        <ul>
          <li>각각의 i에 대해서 i번째 끝나는 애들</li>
          <li>분명히 maximum sum을 해주는 것은 하나 존재하는데 첫 번째 원서로 끝나던지, … 몇 번째쯤에 끝날 것이다. n번째에서 끝나는 것들 각각을 보자는 의미이다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/17.png" alt="17" /></p>

    <ul>
      <li>algorithm을 만들 때, 효율을 신경쓰지 말고 하나하나 따져본다. 고등학교 때 순열과 조합으로 경우의 수를 따지는데, 전공에서 매우 중요한 요소이다.
        <ul>
          <li>문제를 어떻게 접근해 해결함에 따라 n^2개가 있음에도 불구하고 훨씬 더 효율적으로 문제를 해결할 수 있다.</li>
        </ul>
      </li>
      <li>이런 수열이 주어졌을 때 분명 답은 존재한다:</li>
      <li>alg 1, 2
        <ul>
          <li>모두 -라면 정답은 0이고 :
            <ul>
              <li>-임을 확인하는 비용은 linear time</li>
            </ul>
          </li>
          <li>양수가 하나라도 있으면 찾아보아야 한다</li>
        </ul>
      </li>
    </ul>

    <p>0에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고, —- 1, 2 번째에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고. n-1 까지 중 제일 작은 거</p>
  </li>
</ul>

<h1 id="mss-1---simple-counting">MSS 1 - simple counting</h1>

<ul>
  <li>Strategy
    <ul>
      <li>Enumerate all possibilities one at a time.</li>
      <li>
        <p>No efficiency is considered, resulting in a lot of unnecessary computation!</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Maxsum</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">Thissum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">j</span><span class="p">])</span>
              <span class="n">Maxsum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Thissum</span><span class="p">,</span> <span class="n">Maxsum</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>모든 경우의 수를 하나하나 모두 따져보는 방법.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
      <span class="c1">// i = 리스트 왼쪽 끝 인덱스, j = 리스트 오른쪽 끝 인덱스,</span>
      <span class="c1">//  ThisSum = 고려 대상 부분 리스트 합, MaxSum = 문제 최종결론</span>
      <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
                  <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>Is this for-loop OK for you?</li>
      <li>Time Complexity : $O(N^3)$
        <ul>
          <li>𝑖와 관련된 반복문은 𝑛n번, 𝑗와 관련된 반복문은 최대 𝑛번, Thissum을 구할 때 최대 𝑛개의 요소를 계산해야 하기에</li>
          <li>
            <p>$\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>$\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// for (i = 0; i &lt; N; i++)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
     <span class="c1">// {</span>
       <span class="c1">//   ThisSum = 0;</span>
         <span class="c1">// for (k = i; k &lt;= j; k++)</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>$\sum_{k=i}^{j} 1 = j-i+1$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//for (i = 0; i &lt; N; i++)</span>
  <span class="c1">//    for (j = i; j &lt; N; j++)</span>
  <span class="c1">//    {</span>
  <span class="c1">//        ThisSum = 0;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>0번째에서 시작해서 Max 구한 것,…, n번째에서 시작하여 Max 구한 것.</li>
      <li>크게 바깥쪽에서 for loop이 돌면서 i번째부터 시작해서 i 하나, 두개, 세개, … 모든 것을 다 봐서 i번째에서 시작하는 것 중 가장 큰 것을 찾으려 한다.</li>
      <li>for loop은 i, i+1, i - i+2, i - n-1… 까지 더해 봄.</li>
    </ul>

    <blockquote>
      <p>💡 [개선점] 이전에 더한것에다가 하나만 더 더하면 되지 않을까</p>
    </blockquote>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/18.png" alt="18" /></p>

<h1 id="mss-2">MSS 2</h1>

<ul>
  <li>
    <p>Strategy</p>

    <blockquote>
      <p>💡 이전 스택에서 하나만 더 더하면 되는 것 아닌가?</p>
    </blockquote>

    <ul>
      <li>Get rid of the inefficiency in the innermost for-loop. Algorithm 1보다 중복을 줄이는 방법</li>
      <li>
        <p>for loop가 하나 사라지게 됨.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Maxsum</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">Thissum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">j</span><span class="p">])</span>
              <span class="n">Maxsum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Thissum</span><span class="p">,</span> <span class="n">Maxsum</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>Notice that $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
      <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
                  <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
      <li>time complexity : $O(N^3) \rightarrow O(N^2)$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/19.png" alt="19" /></p>

<h1 id="mss--3--divide-n-conquer">MSS  3 : Divide n Conquer</h1>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/20.png" alt="20" /></p>

<ul>
  <li>Divide and Conquer
    <ul>
      <li>경우의 수를 따짐 : 전부 다 음수가 아니라면 분명히 하나 존재한다.</li>
      <li>0번 원소부터 n-1 원소까지 있는데 이를 반으로 1/2로 뚝 자르고,
        <ul>
          <li>홀수 개수면 정확히 나눠지지 않음, 짝수 개수이면 정확히 둘로 나누어짐</li>
        </ul>
      </li>
      <li>left segment에 있던지 right segment에 있던지 양다리 걸치던지. 의 세가지 케이스 중 제일 큰 값을 찾는다.</li>
      <li>→ 이 전체에서 mss를 찾고자 하는데, 일단 왼쪽하고 오른쪽 각각에서 MSS 찾고</li>
    </ul>
  </li>
  <li>원래 플고자 하는 문제와 problem size만 다르다
    <ul>
      <li>전체 subsequence를 반으로 잘라 left- right segment 각각 영역에서의 MSS를  찾고자 함.</li>
      <li>결국 같은 문제 : problem size 만 1/2, 1/2된 케이스</li>
      <li>전체 문제 사이즈 2인것을 1, 1로 divide하여 각각의 segment에서 conquer하여 찾는다</li>
      <li>with - ‘Recursion’
        <ul>
          <li>자기 자신을 부른다 :</li>
          <li>항상 recursive call을 할 때는 problem size를 작게 하여 부른다.</li>
          <li>양다리 걸치는 것 중 제일 큰 것을 찾아 비교</li>
          <li>각 동네에서 MSS를 찾아 그 중 제일 큰 것을 돌린다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why is Log N
    <ul>
      <li>[사진]</li>
      <li>Binary Tree에서 각 depth별로 $1 , 2, 4, 8, …$</li>
      <li>$O (N \log N)$</li>
    </ul>
  </li>
  <li>Strategy
    <ul>
      <li>Use the <strong>Divide-and-Conquer</strong> strategy.
        <ul>
          <li>원 문제를 작은 문제로 나눠 풀고, 그 결과를 합쳐 문제를 해결하는 알고리즘</li>
        </ul>
      </li>
      <li>The maximum subsequence sum can be in one of three places.</li>
      <li>교재에 탑재되어 있지만 그렇게 좋은 코드가 아닌듯 하다 !</li>
      <li>leaf node 1개까지 내려왔을 경우 양수이면 그대로 return하고 음수이면 0</li>
      <li>Divide and Conquer
        <ul>
          <li>center를 찾아 중앙 지점 : 똑같은 문제 [index left-right] 를 풀지만 [left-center], [center-right]로 원래 풀고자 하는 문제를 divide해서 푼다.</li>
          <li>recursion의 묘미 : 막아주는 부분 (else return 0)이 있어야 top-down으로 내려갈 수 있는 divide and conquer</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">Left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Right</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">MaxLeftBorderSum</span><span class="p">,</span> <span class="n">MaxRightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">LeftBorderSum</span><span class="p">,</span> <span class="n">RightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">Center</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">//종료조건if (Left == Right){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">];</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// divide n conquer</span>
  <span class="n">Center</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="o">+</span> <span class="n">Right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//왼쪽, 오른쪽, 중간</span>
  <span class="n">MaxLeftSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Center</span><span class="p">);</span>
  <span class="n">MaxRightSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Right</span><span class="p">);</span>
		
  <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">LeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 1. left ending 끝으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">LeftBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LeftBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxLeftBorderSum</span><span class="p">)</span>
          <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">LeftBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
  <span class="c1">// 2. right ending 시작으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">RightBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RightBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxRightBorderSum</span><span class="p">)</span>
          <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="n">RightBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">Max3</span><span class="p">(</span><span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">,</span> <span class="n">MaxLeftBorderSum</span> <span class="o">+</span> <span class="n">MaxRightBorderSum</span><span class="p">);</span>
  <span class="c1">// MaxLeftSum - left segment의 sum</span>
  <span class="c1">// MaxRighttSum - right segment의 sum</span>
  <span class="c1">// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대</span>
  <span class="err">}</span>
  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것
            <ul>
              <li></li>
            </ul>
          </li>
        </ul>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/21.png" alt="21" /></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">Left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Right</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">MaxLeftBorderSum</span><span class="p">,</span> <span class="n">MaxRightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">LeftBorderSum</span><span class="p">,</span> <span class="n">RightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">Center</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">//종료조건if (Left == Right){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">];</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// divide n conquer</span>
  <span class="n">Center</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="o">+</span> <span class="n">Right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//왼쪽, 오른쪽, 중간</span>
  <span class="n">MaxLeftSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Center</span><span class="p">);</span>
  <span class="n">MaxRightSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Right</span><span class="p">);</span>
		
  <span class="c1">// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것</span>
		
  <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">LeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 1. left ending 끝으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">LeftBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LeftBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxLeftBorderSum</span><span class="p">)</span>
          <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">LeftBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
		
  <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
  <span class="c1">// 2. right ending 시작으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">RightBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RightBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxRightBorderSum</span><span class="p">)</span>
          <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="n">RightBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">Max3</span><span class="p">(</span><span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">,</span> <span class="n">MaxLeftBorderSum</span> <span class="o">+</span> <span class="n">MaxRightBorderSum</span><span class="p">);</span>
  <span class="c1">// MaxLeftSum - left segment의 sum</span>
  <span class="c1">// MaxRighttSum - right segment의 sum</span>
  <span class="c1">// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대</span>
  <span class="err">}</span>
  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>cost : $T(n) = 2T(\frac n 2) + cn$, $T(1) = d$</li>
  <li>why O(N log N)<em>O</em>(<em>NlogN</em>) ?
    <ul>
      <li>$T(n) = 2T(\frac n 2) + cn$</li>
      <li>
        <p>$T(1) = d$</p>

        <p>$= 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$</p>

        <p>$= 2^2 T [ \frac n {2^2}] + 2cn$</p>

        <p>$= 2^3 T [ \frac n {2^3}] + 3cn =…$</p>

        <p>$= 2^i T [ \frac n {2^i}] + icn$</p>

        <p>$= 2^{\log_2 n} T(1) + \log_2 n \cdot cn$</p>

        <p>$=nT(1) + \log_2 n \cdot cn$</p>

        <p>$= O(n) + O(n \log_2 n) = O(n \log_2 n)$</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="mss--4-kadanes-algorithm">MSS  4; Kadane’s algorithm</h1>

<ul>
  <li>
    <p>i번째 원소로 끝나는 가장 합이 큰 subsequence가 얘라면, 다른 나머지를 분리했을 때 i-1로 끝나는 subsequence이다.</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/22.png" alt="22" /></p>

    <ul>
      <li>아니다 → 모순 증명 : 고등학교 proof by contradiction 귀류법으로</li>
      <li>i원소로 끝나는 합이 제일 큰 subsequence는 얘인데, 합이 제일 큰 subsequence가 되어야 한다.</li>
      <li>합이 제일 큰 부분을 찾는데, 나보다 하나 앞애 있는 i-1까지의 sequence로 바뀐다.
        <ul>
          <li>recursion이랑 비슷 : 같은 문제룰 푸는데 문제 크기가 달라짐. 이를 어떤 형식으로 해결하느냐에 따라서 달라지게 됨.</li>
        </ul>
      </li>
      <li>i번째 끝나는 subsequence중에 여러가지 있을 수 있는데, 그 중 가장 합이 큰 것을 Bi라고 할 때
        <ul>
          <li>$B[i]$ : the sum of the maximum subsequence that ends at index $i$</li>
          <li>$B[i] = \max { B[i-1] + A[i], 0}$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Strategy</p>
    <ul>
      <li>Use the Dynamic Programming strategy.</li>
      <li>subsequence sum&lt;0인 경우, 논리적으로 최대값이 될 수 없음에 착안한 전략</li>
      <li>
        <p>만약에 sum이 음수라도 무방하고 1개 이상의 원소로 구성된 Subsequence (subarray)를 구하는 문제라면?</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		
      <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// j번째 원소르 끝나는 것 중 합이 제일 큰 것</span>
          <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 지금까지의 원소르 끝나는 것 중 합이 제일 큰 것</span>
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
          <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
              <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="c1">// if (ThisSum&lt;0) ThisSum=0; </span>
              <span class="c1">// else if (ThisSum&gt;MaxSum) MaxSum = ThisSum;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>thissum : j 번째 돌 때 j-1번째 원소로 끝나는 것 중 제일 합이 큰 것.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">ThisSum += A[j]</code></li>
        </ul>
      </li>
      <li>ThisSum → 0, j번째 원소로 끝나는 것 중 가장 큰 거보다 크면 바꿔치기하고..</li>
      <li>최소한 모든 원소를 한 번씩은 봐야 하기 때문에 linear보다 더 빠른 alg는 없다.</li>
      <li>Time Complexity : $O(n)$
        <ul>
          <li>for i, iteration n times, and $ O(1$) for 1 calculation</li>
        </ul>
      </li>
      <li>C Implementation
        <ul>
          <li>
            <p>Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">kadane</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">finish</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
			
      <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">local_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="n">local_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">maxSum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
              <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">local_start</span><span class="p">;</span>
              <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">finish</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
  <span class="c1">// at least one non-negative number.</span>
			
  <span class="c1">// When all numbers in the array are negative</span>
      <span class="n">maxSum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">maxSum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
              <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="c1">// Empty subsequence를 허용하면 0을 리턴 (원래 문제)</span>
  <span class="c1">// Empty subsequence를 허용하지 않으면 음수 중 가장 큰 원소를 리턴</span>
          <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
  <span class="p">}</span>
			
			
			
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="so-why-do-we-bother-with-the-time-complexity">So, why do we bother with the time complexity?</h3>

<h1 id="alg-15-maximum-sum-subrectangle-in-2d-array-1">[ALG] 1.5. Maximum Sum Subrectangle in 2D Array (1)</h1>

<h1 id="maximum-sum-subrectangle-in-2d-array">Maximum Sum Subrectangle in 2D Array</h1>

<p>= max sum submatrix</p>

<p>2차원 array가 있을 때 합을 제일 최대로 만들게 하는 subrectangle을 찾아라.</p>

<ul>
  <li>empty subrectangle 허용
    <ul>
      <li>모두 음수면 0</li>
    </ul>
  </li>
  <li>empty subrectangle 비허용
    <ul>
      <li>모두 음수라면 절댓값이 제일 작은 것 선택</li>
    </ul>
  </li>
  <li>행이 m개, 열이 n개 :
    <ul>
      <li>n자승개가 존재한다고 햇는데, order로 subrectangle이 몇 개 존재할 것인가?</li>
      <li></li>
    </ul>
  </li>
  <li>Problem
    <ul>
      <li>Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle is <strong>any contiguous sub-array of size 1x1 or greater</strong> located within the whole array.)</li>
    </ul>
  </li>
  <li>Note
    <ul>
      <li>What is the input size of this problem?
        <ul>
          <li>$(m, n)$</li>
          <li>If $m = n→n$</li>
          <li>problem size를 (n,n) 할수도 있고</li>
        </ul>
      </li>
      <li>How many subrectangles are there in an mxn array?</li>
      <li>For the case of $m = n$,
        <ul>
          <li>Design an $O(n^6)$ algorithm.</li>
          <li>Design an $O(n^5)$ algorithm.</li>
          <li>Design an $O(n^4)$ algorithm.</li>
          <li>
            <p>Design an <em>O</em>(_n_3) algorithm.</p>

            <p>O(n^3)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>각각의 $(i,j,k,l)$에 의해 하나가 정의 :</li>
  <li>How many subrectangles are there in an mxn array?
    <ul>
      <li>
        <p>[1D case] for an m * n_m_∗<em>n</em> rectangle,</p>

        <p>$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1$</p>

        <p>$= (\sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1)(\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} 1)$</p>

        <p>$= { \sum_{k=0}^{m-1}(m-k)}{\sum_{i=0}^{n-1}{(n-i)}}$</p>

        <p>$= \frac {m(m+1)} {2} \frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4)$ if $m=n$</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="a-naïve-approach">A Naïve Approach</h2>

<ul>
  <li>For each subrectangle, find its sum.</li>
  <li>
    <p>[가정] $n=m$</p>

    <p>$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} {(l-k+1)}$</p>

    <p>let $A =\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)}$</p>

    <p>$A = 1<em>n + 2</em>(n-1) +3(n-2) + … + n*1A=1∗n+2∗(n−1)+3(n−2)+…+n∗1 = \sum_{i=1}^{n} {i(n-i+1)} = n \sum_{i=1}^n i - \sum_{i=1}^n i^2 + \sum_{i=1}^n i = \frac{1}{6} n^3$</p>

    <ul>
      <li>so $O(\frac{1}{36} n^6 )$
undefined- Time Complexity : $O(n^6)$</li>
    </ul>
  </li>
  <li>inefficient algorithm</li>
</ul>

<h2 id="mss--summed-area-table">MSS : Summed Area Table</h2>

<ul>
  <li>memory 자체도 resource이기 때문에 항상 많이 쓰는 것이 좋은 건 아니지만, summed area table이라는 memory를 하나 써서 문제를 풀게 된다.</li>
  <li>Table construction: $O(n^2)$
    <ul>
      <li>각 원소는 대응되는 영역의 합이 각 대응되는 위치에 지정한다 : 순서대로 쭉 원소들을 훑으며 계산한다. 이를 계산하면 내가 훑어야 하는 원소의 개수가 n^2만큼 있다. 각각의 원소는 상수 시간에 계산되어야 한다.</li>
      <li>n^2에 대해서 계산하려고 하는데, 각각을 상수 시간 안에 계산하여야 한다.</li>
      <li></li>
    </ul>
  </li>
  <li>Sum comparisons:$O(n^4)$</li>
  <li>
    <p>Time Complexity : $O(n^4)$</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/23.png" alt="23" /></p>

    <ul>
      <li>preprocess를 통해 table의 내용을 채울 것이다.</li>
      <li>$(i,j,k,l)$에 해당하는 것이 $n^4$개만큼 나오는데, 그 영역에 대한 합을 계산해서 사각형의 합 중 제일 큰 것을 선택하면 됨.</li>
      <li>$S(i,j,k,l) = T(l,j) - T(k-1, j) + T(k, j-1) + T (k-1. i-1)$
        <ul>
          <li>constant time : 각 사각형에 대한 계산</li>
          <li>살펴봐야 할 것들은 $n^4$개 존재하니까.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>문제 : 지금까지는 time complexity를 따졌지만 문제는 space complexity
    <ul>
      <li>input data : @n^2 만큼의 자리를 차지함.
        <ul>
          <li>→ 모바일 SW를 개발한다 : input data 말고도 성능이 낮거나 memory size 작거나 access 느린 cpu에 대해서는 안 좋을수 있다. 시스템 부담이 되는 상황 발생 가능</li>
        </ul>
      </li>
      <li>time complexity : n인 문제를 푸는 데 걸리는 시간</li>
      <li>space complexity : 문제 푸는데 걸리는 메모리
        <ul>
          <li>문제 사이즈 n에 대해서 $n^4$</li>
        </ul>
      </li>
      <li></li>
    </ul>
  </li>
</ul>

<h3 id="maximum-sum-subrectangle-kadane-algo-based">Maximum Sum Subrectangle: Kadane Algo.-Based</h3>

<blockquote>
  <p>💡 n^3에 해보자</p>
</blockquote>

<ul>
  <li>분명히 MSS인 rectangle이 존재하는데, i에서 시작해서 j로 끝남 : 그러면 이제 어떤 식으로 문제를 바라볼 것이냐 : $0 \leq i \leq j \leq n-1$이 가능한 pair
    <ul>
      <li>i번째 열에서 j번째로 끝나는 모든 가능한 rectangle을 살펴보자.</li>
      <li>가능한 조건을 만족하는 i,j → n^2만큼 존재함.</li>
      <li>모든 가능한 i, j에 대해서 i행에서 시작하고 j열에서 끝나는 mss를 찾아보자.</li>
      <li>column이 i, j번째에 끝나는 : 합이 제일 큰 것을 찾자. 라고 접근</li>
      <li>만약
        <ul>
          <li>temp array를 만들어서 임의의 주어진 i, j에 대해서 첫 번재 원소는 1 행, 2번째 원소는 2행, … 을 모두 저장해 놓은 값을 저장해 두었다고 하자.</li>
          <li>주어진 i, j에 대해서 행 열이 i에서 시작해서 j로 끝나는 subrectangle 중 제일 큰 것은 어떻게 찾을 수 있을까.</li>
          <li>1차원 sequence에서 합을 제일 크게 하는 mss를 찾으면 된다.</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>💡 모든 가능한 (i,j) pair에 대해서 볼 것이다.<br />
바깥에서 for loop이 돌 때 저만큼 존재한다.<br />
각 행에 있는 것들을 다 더해두면 (temp) → i열에서 시작해서 j로 끝나는 가능한 rectangle을 만든다. 합이 제일 큰 것은 temp가 있기 때문에, linear time에 합이 제일 큰 subsequence를 찾으면 바로 k행부터 l행까지 정의되는 사각형이 Maximum sum이 되더라.</p>
    </blockquote>

    <ul>
      <li>다시 이양기하지만, 조건 만족하는 쌍이 i,j개 존재하니까 linear time에 계산할 수 있으면</li>
      <li>각각을 n에 대해서 계산하면 $n^3$이 나온다.</li>
    </ul>
  </li>
  <li>Idea
    <ul>
      <li>ref. <a href="https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/">geeksforgeeks</a></li>
      <li>MSS(2D)의 해당 열은 어디이건 i에서 j까지 임.</li>
      <li>가능한 모든 (i, j) 조합에 대하여 MSS(1D)를 Kadane 알고리즘을 사용하여 찾음.</li>
      <li>
        <p>그렇게 하기 위하여, …</p>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/24.png" alt="24" /></p>
      </li>
    </ul>
  </li>
  <li>어떤 식으로 구현할지 보여야 구현할 것인데 자꾸 경험을 통해서 몸에 배면 구구단 외우듯이 간다.</li>
  <li>C Implementation
    <ul>
      <li>
        <p>left, right : $n^2$만큼 돈다</p>

        <table>
          <thead>
            <tr>
              <th>1</th>
              <th>2</th>
              <th>-1</th>
              <th>-4</th>
              <th>-20</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>-8</td>
              <td>-3</td>
              <td>4</td>
              <td>2</td>
              <td>1</td>
            </tr>
            <tr>
              <td>3</td>
              <td>8</td>
              <td>10</td>
              <td>1</td>
              <td>3</td>
            </tr>
            <tr>
              <td>-4</td>
              <td>-1</td>
              <td>1</td>
              <td>7</td>
              <td>-6</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<p>undefined
	```c
	// Program to find maximum sum subarray
	// in a given 2D array
	#include <stdio.h>
	#include <iostream>
	#include <string.h>
	using namespace std;
	#define INT_MAX 2147483647
	#define INT_MIN 2147483648
	#define ROW 4
	#define COL 5</string.h></iostream></stdio.h></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Implementation of Kadane's algorithm for
// 1D array. The function returns the maximum
// sum and stores starting and ending indexes
// of the maximum sum subarray at addresses
// pointed by start and finish pointers
// respectively.
int kadane(int *arr, int *start, int *finish, int n)
{
    // initialize sum, maxSum and
    int sum = 0, maxSum = INT_MIN, i;

    // Just some initial value to check
    // for all negative values case
    *finish = -1;

    // local variableint
    local_start = 0;

    for (i = 0; i &lt; n; ++i)
    {
        sum += arr[i];
        if (sum &lt; 0)
        {
            sum = 0;
            local_start = i + 1;
        }
        else if (sum &gt; maxSum)
        {
            maxSum = sum;
            *start = local_start;
            *finish = i;
        }
    }

    // There is at-least one
    // non-negative number
    if (*finish != -1)
        return maxSum;

    // Special Case: When all numbers
    // in arr[] are negative
    maxSum = arr[0];
    *start = *finish = 0;

    // Find the maximum element in array
    for (i = 1; i &lt; n; i++)
    {
        if (arr[i] &gt; maxSum)
        {
            maxSum = arr[i];
            *start = *finish = i;
        }
    }
    return maxSum;
}

// The main function that finds
// maximum sum rectangle in M[][]
void findMaxSum(int M[][COL])
{
    // Variables to store the final output
    int maxSum = INT_MIN,
        finalLeft,
        finalRight,
        finalTop,
        finalBottom;

    int left, right, i;
    int temp[ROW], sum, start, finish;

    // Set the left column
    for (left = 0; left &lt; COL; ++left)
    {
        // Initialize all elements of temp as 0
        memset(temp, 0, sizeof(temp));

        // Set the right column for the left
        // column set by outer loop
        for (right = left; right &lt; COL; ++right)
        {

            // Calculate sum between current left
            // and right for every row 'i'
            for (i = 0; i &lt; ROW; ++i)
                temp[i] += M[i][right];

            // Find the maximum sum subarray in temp[].
            // The kadane() function also sets values
            // of start and finish. So 'sum' is sum of
            // rectangle between (start, left) and
            // (finish, right) which is the maximum sum
            // with boundary columns strictly as left
            // and right.
            sum = kadane(temp, &amp;start, &amp;finish, ROW);

            // Compare sum with maximum sum so far.
            // If sum is more, then update maxSum and// other output values
            if (sum &gt; maxSum)
            {
                maxSum = sum;
                finalLeft = left;
                finalRight = right;
                finalTop = start;
                finalBottom = finish;
            }
        }
    }

    // Print final values
    cout &lt;&lt; "(Top, Left) ("
         &lt;&lt; finalTop &lt;&lt; ", "
         &lt;&lt; finalLeft
         &lt;&lt; ")" &lt;&lt; endl;
    cout &lt;&lt; "(Bottom, Right) ("
         &lt;&lt; finalBottom &lt;&lt; ", "
         &lt;&lt; finalRight &lt;&lt; ")" &lt;&lt; endl;
    cout &lt;&lt; "Max sum is: " &lt;&lt; maxSum &lt;&lt; endl;
}

// Driver Codeint
main()
{
    int M[ROW][COL];

    // Function call
    findMaxSum(M);

    return 0;
}
```
</code></pre></div></div>

<ul>
  <li>
    <p>결과는 아래와 같다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="n">Top</span><span class="p">,</span> <span class="n">Left</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="n">Bottom</span><span class="p">,</span> <span class="n">Right</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">sum</span> <span class="n">is</span><span class="o">:</span> <span class="mi">29</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="mathematical-induction--proof-of-correctness">Mathematical Induction &amp; Proof of Correctness</h2>

<ul>
  <li>
    <p>Proof by Induction</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/25.png" alt="25" /></p>
  </li>
  <li>
    <p>Proof of Correctness : MSS (1D)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">ThisSum</span> <span class="o">=</span> <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	
      <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
          <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
	
  <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>P(j) : for-loop가 j번 수행한 직후에 ThisSum 변수는 ( )값을, MaxSum 변수는 ( )값을 가지고 있다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[Algorithm : Big O and MSS]]></summary></entry></feed>