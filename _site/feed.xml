<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-30T00:41:28+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Kyuhwan Shim</title><subtitle>Kyuhwan Shim is a senior undergraduate in CS at Sogang University.
</subtitle><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><entry><title type="html">회고와 대회</title><link href="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C" rel="alternate" type="text/html" title="회고와 대회" /><published>2023-11-16T00:00:00+09:00</published><updated>2023-11-16T00:00:00+09:00</updated><id>http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C</id><content type="html" xml:base="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C"><![CDATA[<h1 id="블로그">블로그</h1>

<ul>
  <li>리디자인</li>
</ul>

<h1 id="대회">대회</h1>

<ul>
  <li>2022
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2022 빅콘테스트</li>
    </ul>
  </li>
  <li>2023
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />강서구 데이터 공모전</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />LG Aimers</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Samsung AI Challenge</li>
    </ul>
  </li>
</ul>

<h1 id="일">일</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Nota ITS ML Engineer 인턴 후기
    <ul>
      <li>들어가야 하는 내용
        <ul>
          <li>지원 계기
            <ul>
              <li>타 기업에 대비하여 가질 수 있었던 이점</li>
            </ul>
          </li>
          <li>가서 주로 맡은 업무</li>
          <li>가서 배운 일</li>
          <li>앞으로의 할 일</li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />앞으로 할 일에 대한 정리
    <ul>
      <li>대학원과 취업 사이의 기로</li>
      <li>전공</li>
      <li>ML</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="경험" /><category term="일상기록" /><summary type="html"><![CDATA[블로그]]></summary></entry><entry><title type="html">빅콘테스트 후기 (2022년 이노베이션 분야)</title><link href="http://localhost:4000/%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0-(2022%EB%85%84-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B6%84%EC%95%BC)" rel="alternate" type="text/html" title="빅콘테스트 후기 (2022년 이노베이션 분야)" /><published>2022-12-30T00:00:00+09:00</published><updated>2022-12-30T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0-(2022%EB%85%84-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B6%84%EC%95%BC)</id><content type="html" xml:base="http://localhost:4000/%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0-(2022%EB%85%84-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B6%84%EC%95%BC)"><![CDATA[<h1 id="의미없는-경험은-없다">의미없는 경험은 없다!</h1>

<ul>
  <li><strong>빅콘테스트란?</strong> 국내 최대 규모의 데이터 사이언스 경연 대회이다. 신한카드, LG U Plus, Finda 등 20여개에 이르는 다양한 참여사들이 주관하며, 그에 따라 참가자의 수준 또한 상당히 높은 편이다</li>
  <li>빅콘테스트에는 <strong>데벤져스 DAVANGERS 의 이름으로 팀을 이루어 참여했다</strong>.
    <ul>
      <li>팀원들 모두가 각기 다양한 배경과 경험을 토대로 지금까지 공부해 왔으며 모인 모습이 마치 어벤져스같다는 의미에서 데이터 + 어벤져스를 합해 DAVENGERS라는 이름을 짓게 되었다.</li>
      <li>
        <p>팀원들은 경영&amp;빅데이터 2명 (정현, 경주), 수학&amp;빅데이터 1명 (경훈), 경영&amp;컴퓨터공학 1명(혜나), 그리고 컴퓨터공학 1명(규환) 총 다섯명으로 구성되어 있다. 지금 봐도 화려한 라인업이다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/0.png" alt="0" /><em>우리들의 포토이즘</em></p>
      </li>
    </ul>
  </li>
  <li>
    <p>이름이 정해지는 순간</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/1.png" alt="1" /><em>데이터분석 + 어벤져스 = 데벤져스!</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/2.png" alt="2" /><em>우리의 핵심 모토</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/3.png" alt="3" /></p>
  </li>
</ul>

<h2 id="빅콘테스트-팀-합류">빅콘테스트 팀 합류</h2>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/4.png" alt="4" /><em>팀장 하정현씨의 모집글</em></p>

<ul>
  <li>팀원들은 서강대학교 데이터사이언스학회인 INSIGHT에서 조직했다. 나는 당시 신입기수였던 8기였고, 다른 팀원분들은 7기 선배 기수로서 이미 한 텀동안 데이터 분석 경험이 있는 분들이었다. 데이터 분석 특성상 데이터를 분석하고 이를 바탕으로 인사이트를 도출한 이후, 커뮤니케이션 전략까지 설계해야 한다. 비단 회사에서도 마찬가지로, 팀의 목표에 따라 데이터를 철저히 분석하고 이후 경영팀과 상의해야 한다. 팀플레이에도 익숙한 친구들이라고 생각했고, 학회에 들어가고 나서도 적극적으로 참여하던 친구들이었기에 주저 없이 합류했다. 사실 주제 자체도 재밌어보이는 것이 컸다.</li>
</ul>

<h2 id="주제설명">주제설명</h2>

<ul>
  <li>빅콘테스트에는 이노베이션 분야(신한카드) / 퓨처스 부문(핀다) / 챔피언 부문(엘지 유플러스) 3가지의 분야가 존재한다.
    <ul>
      <li>분야마다 참여사가 다르고, 그에 따라 시상금도 다르고, 주제도 다르고, 원하는것도 달랐기에 주제를 정하는 것이 제일 중요했다. 빅콘테스트 공식 사이트에 내용이 엄청 자세해서 사이트 꼼꼼히 보고 토론했다. 경쟁률도 중요하지만 주제 별 도메인이 너무나도 달랐기에 신중해야하는 순간이었다. 챔피언 부문의 경우에는 비슷한 프로젝트로 수상한 선배들도 있고, 이노베이션에도 비슷한 프로젝트로 수상한 선배들이 있었기에 무엇을 선택해도 0에서 시작하는 환경은 아니었다.</li>
    </ul>
  </li>
  <li>긴 토론 후, <u>**신한카드**</u>에서 주관하는 ‘<u>**MZ세대가 떠나는 친환경 ESG 제주여행 루트짜기’**</u>의 주제에 참여했다. 아이디어와 인사이트를 활용한, 데이터 기반의 전략 도출이 중요한 분야였고 데벤져스 팀의 강점이 드러날 수 있으리라 생각하여 결정하게 되었다.
    <ul>
      <li><strong>(선정 이유) 여행 관련 데이터라 재밌게 할 수 있을 것 같았고, 모델링과 더불어 스토리라인이 잘 드러나는 분야였기에 흥미로웠다.</strong></li>
      <li><strong>(다른 분야와의 비교)</strong> 제주도 여행뿐만 아니라 ESG를 기반한 인덱스를 만드는 느낌이라 재미가 있어 보였다. 이에 반해, 퓨처스 챔피언분야는 방법이 이미 정해져 있고 모범답안이 존재하는 느낌으로 느껴졌다. 치별화된 결과를 만들만했던 건 이노베이션 분야였다.</li>
      <li>신한카드가 데이터 및 IT에 큰 흥미를 가지고 사업을 확장하는 모습도 결정의 주안점에 있었다.</li>
      <li>주최사는 제주관광공사/신한카드이며, 데이터 제공사 : 신한카드/제주관광공사/산림빅데이터/ Leeds University이다.</li>
    </ul>
  </li>
</ul>

<h1 id="진행">진행</h1>

<h2 id="0-매일매일-가을을-갈아넣은-빅콘">0. 매일매일 가을을 갈아넣은 빅콘</h2>

<ul>
  <li>경훈이형은 회사를 다니고 정현/경주/혜나/규환은 학교에 다니면서 학회를 하는 스케줄이었다. 주말을 모두 고정 회의시간으로 정했고 일반 주중에도 남는 시간에 만나서 진행하기로 결정했다. 처음 조직된 상황으로부터 3주밖에 시간이 남지 않아서 데이터 ~ 모델링 ~ 경영 전략에 이르기까지 빡센 일정이었다.</li>
  <li>
    <p>주로 만남은 (1) 바오로관 라운지, (2) 스타벅스-신촌 / 서강대학교정문, (3) 인사이트 세션 교실에서 이루어졌다. 당시 평범한 공대생이었던 나는 바오로관 라운지가 어딘지 몰랐는데, 앞으로의 대학생활에 있어 영혼의 안식처가 될 줄은 몰랐다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/5.png" alt="5" /><em>파라가 어딘지 몰랐던 시절</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/6.png" alt="6" /><em>인사이트 세션 다음날 파라에서 시켜먹은 엽떡!</em></p>
  </li>
</ul>

<h2 id="1-데이터-정제-및-수집">1. 데이터 정제 및 수집</h2>

<ul>
  <li>사실 데이터가 너무 많아서 이노베이션 분야로의 참여를 주저했었다. 지역별 탄소를 어떻게 계산할지부터 위도 경도가 담긴 데이터까지, 처음에 어떻게 시작해야할지에 대하여도 감이 잘 잡히지 않았다.
    <ol>
      <li>데이터 수정 및 정제
        <ul>
          <li>신한카드에서 직접적으로 제공해 준 데이터들은 물론 엑셀에 잘 설명되어 있었지만, 우리가 팀플레이하기에는 이들을 다 암기하기는 어렵겠다 생각했다. 그래서 기존의 이름으로부터, T4, C5 이런식으로 데이터를 간략화하여 명명하도록 정해두었다. 예를 들어, <code class="language-plaintext highlighter-rouge">t6 → t6_jeju_sns_keyword.csv</code>, <code class="language-plaintext highlighter-rouge">t7_jeju_sns_emotion_keyword.csv</code> 등으로 이해하기 쉽게 제목을 변경했다.</li>
          <li>데이터의 row는 실제 현업의 데이터였다보니 그 양이 상당히 많았다. <code class="language-plaintext highlighter-rouge">t1</code>의 경우 <code class="language-plaintext highlighter-rouge">316174개,</code> <code class="language-plaintext highlighter-rouge">t4</code>의 경우 <code class="language-plaintext highlighter-rouge">103만개</code> 등 각각에 대하여 address들을 mapping해야만 했다. 법정동 정의서 기반으로 진행했다.</li>
        </ul>
      </li>
      <li>주소매칭 후 데이터 통합
        <ul>
          <li>처음에 카카오 혹은 네이버지도에서 제공하는 도로명주소 변환API를 활용하면 DataFrame끼리 잘 merge되리라고 생각했다. 그러나 주소가 안 채워진 것들을 삭제하고 나니 컬럼 수가 반이 된 거 같아 무언가 이상하다 생각했다. API를 돌리니 주소가 똑같이 나와 다시 몇번씩 해봤는데도 같은 결과가 나왔다.</li>
          <li><code class="language-plaintext highlighter-rouge">t5</code> 파일의 경우 ‘기존의 도로명 주소’를 다시 카카오맵 API를 통해 ‘정제된 도로명 주소’로 변환하는 것이 목표였는데, 몇몇 컬럼은 도로명 주소가 검색이 안 되어서 변환되지 않았다.</li>
          <li>API Request 사용량이 매일 정해져 있어 일일 제한수만큼만 가능했다. <a href="https://haries.tistory.com/9">카카오맵 API 사용 블로그</a>를 참조하여 예외처리를 통해서 걸렀었는데 다시 해보려하니까 keyError 잘 안되어서 찾아보니 몇개 안 변환했는데도 불구하고 리밋에 도달한 상태였다.</li>
          <li>→ 카카오 API하는 작업도 생각보다 오래 걸리고, 에러들을 일일히 확인하기도 어려웠고, 애초에 몇만개의 컬럼을 프로세싱하기는 어려웠다. 그러나 주소가 변환되어야 각각에 일치하는 것끼리 데이터 row별로 일치시켜 통일해 진행할 수 있었기에 진행했다.</li>
        </ul>
      </li>
      <li>데이터 크롤링
        <ul>
          <li>데이터 크롤링으로부터 탄소 발자국 알고리즘의 설계까지 10월 3일 월요일날 하기로 결정했다.</li>
          <li>비짓제주, 제주관광공사, 네이버플레이스 등으로부터, 여행지 목록 데이터, 여행지 이동 데이터를 산출하는 것이 목표이다.</li>
          <li>주변관광지/음식점/숙소까지 크롤링해서 합친 비짓제주관광지데이터를 하나로 통합했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="2-여행관련-탄소발자국-계산기-구축">2. 여행관련 탄소발자국 계산기 구축</h2>

<ul>
  <li>**<기존 탄소="" 발자국="" 계산기의="" 한계="">**
</기존>    <ul>
      <li>기존에 탄소발자국 계산기들이 있지만, 이용한 전기 사용량 등 일반인들이 구체적으로 기억하고 있기 어려운 값들을 정확하게 입력 값에 넣어야 탄소배출량이 계산되는 형태였다. 따라서 우리가 구축하고자 하는 탄소발자국 계산기는, 정확한 수치를 알고 있지 않은 일반인들도 자신이 이용한 숙소 형태나 음식점 정도만 선택한다면 대략적인 탄소 배출량을 알 수 있게 해주는 계산기이다. 또한, 여행이라는 특정 상황에서의 탄소발자국을 계산한다는 점에서 의미가 있다.</li>
      <li>우리는 실제 사용성을 고려하여 엑셀이 아닌, <strong>배포/관리/시각화가 용이한</strong> <strong>파이썬 기반의 웹 어플리케이션 Streamlit</strong>을 이용하여 계산기를 구현했다. <strong>계산기 중간중간에 탄소배출량을 절감하는 팁</strong>을 추가해 친환경 여행을 유도하였다. 예를 들어, <strong>렌터카 차종을 선택</strong>할 때는 탄소배출량이 적은 연료타입을 알려주고, <strong>숙소를 선택</strong>할 때는 호텔의 탄소배출량이 높다는 사실을 강조하는 식이다.</li>
    </ul>
  </li>
  <li>참조한 링크
    <ul>
      <li>다양한 블로그 등에 사전에 구현된 <a href="https://hwgrn.github.io/howgreenfoodprintcalculator/">음식 탄소발자국 계산기</a>, <a href="https://www.ibm.com/docs/ko/tririga/10.5.2?topic=calculations-carbon-footprint-calculation-formulas">IBM 탄소발자국 계산공식</a>, <a href="http://116.67.44.68/fcr_web/resources/carbon_calc/html/main/CTC_03_01.html">탄소나무계산기</a> 등과 같은 웹 공개 자료와, London 영국 의회에서 발행한 <a href="https://www.londoncouncils.gov.uk/node/38613">보고서</a>나 논문들을 추가적으로 또한 리서치하여 반영하고자 했다. 세번째의 산림청, 국립산림과학원 탄소나무 계산기 참조를 참조하여 웹으로 어느정도 비슷하게 구현하리라는 목표를 세우고 진행했다.</li>
    </ul>
  </li>
  <li>주요 역할 분담은 다음과 같다.
    <ul>
      <li>정현 - 데이터 전처리 (주소 기반), 탄소계산기/관광업 : 데이터 수집, 로직 설계</li>
      <li>경훈 - 데이터 전처리 (주소 기반), 탄소계산기/요식업 : 로직 검증, 탄소계산기/관광업 : 데이터 수집, 로직 설계, 여행 알고리즘 설계</li>
      <li>경주 - 탄소계산기/교통업 : 데이터 수집, 로직 설계, 추가 비짓제주 및 네이버 지도 데이터 크롤링</li>
      <li>혜나 - 탄소계산기/요식업 : 데이터 수집, 로직 설계, 탄소계산기/교통업 : 로직 검증, 기타 로직 검증</li>
      <li>규환 - 프로젝트 웹 페이지 구현, Streamlit을 활용한 탄소 발자국 계산기 구현, 로직 검증, 여행객 페르소나 헥사곤 구현
        <ul>
          <li>탄소 발자국 계산기의 경우 음식, 관광 등 각자 분야별 나누어서 데이터분석 후 로직구현을 하도록 정리했다. 배출 계산 단계가 복잡하였기 때문에, 각각에 대해서 person처럼 정리하거나, 사칙연산으로 Streamlit 상에서 구현할 수 있도록 했다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="여행-카테고리별-구현">여행 카테고리별 구현</h3>

<ul>
  <li><strong>(1) 음식 분야</strong>
    <ul>
      <li>혜나가 음식 분야를 먼저 완성하여 streamlit으로 초안을 만드는 데에 들어갔다.</li>
      <li>한국일보에서 개발해 둔 [<한끼밥상 탄소계산기="">](https://interactive.hankookilbo.com/v/co2e/), [다른 탄소발자국 계산기](https://foodfootprint.nl/en/foodprint-finder/)를 바탕으로 교차검증하여 없는 식품에 대하여 리서치하거나 산출된 배출량에 대하여 확인 후 값을 나오도록 설계했다.</한끼밥상></li>
      <li>기존의 탄소배출량 계산기와 달리, 사용자가 정확한 음식 재료를 몰라도 쉽게 계산할 수 있는 계산기를 개발할 수 있었다.</li>
      <li>데이터의 경우 <strong>제주 가맹점 데이터에 있는 음식점 목록</strong>과 <strong>식품별 탄소배출량 데이터</strong>를 이용했다. <strong>추가적으로,</strong> 음식점별 메뉴 정보를 얻기 위해 <strong>네이버 지도를 크롤링</strong>했다.</li>
      <li><strong>이용한 음식점이 주어진 데이터에 있는 경우</strong>,  <strong>음식점 대표메뉴들의 탄소배출량 평균</strong>을 해당 <strong>음식점의 탄소배출량</strong>으로 산정했다. <strong>이용한 음식점이 주어진 데이터에 없는 경우에는</strong>, <strong>음식점 유형별 탄소배출량</strong>을 일반화해 사용했다. 네이버지도의 태그를 활용해 제주도 음식점을 고기국수집, 횟집 등의 <strong>15개의 유형으로 분류</strong>한 후, <strong>유형에 속하는 메뉴들의 탄소배출량 평균</strong>을 <strong>해당 유형의 탄소배출량</strong>으로 산정했다.</li>
      <li>
        <p>음식의 카테고리를 정하는 데에 사실 재료부터 탄소 발자국을 계산하는 데에 들어가기 때문에, 전문가인 경훈이형에게 많이 물어봤던 기억이 난다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/7.png" alt="7" /></p>
      </li>
    </ul>
  </li>
  <li><strong>(2) 숙박 분야</strong>
    <ul>
      <li>숙박 카테고리의 경우 정현이누나가 맡아서 진행했다.</li>
      <li>데이터의 경우 제공된 <strong>비짓제주 데이터</strong>와 <strong>주소별 온실가스 배출량 데이터</strong>를 이용했습니다. t5 숙소 c3 랑 매칭시켜서 등급별 탄소배출량 평균을 낸 후, 비짓제주 숙박 크롤링이랑 c3 매칭시켜서 호텔 등급별 탄소배출량 평균을 냈다.</li>
      <li>추가적으로 <a href="https://www.data.go.kr/data/15041985/fileData.do">숙박 공공데이터</a>를 리서치해 반영하였다. <a href="https://www.mcst.go.kr/kor/s_policy/dept/deptView.jsp?pCurrentPage=1&amp;pType=05&amp;pTab=01&amp;pSeq=1550&amp;pDataCD=0417000000&amp;pSearchType=01&amp;pSearchWord=%EA%B4%80%EA%B4%91%EC%88%99%EB%B0%95%EC%97%85">문화체육관광부 관광숙박업 등록 현황</a> 또한 참조했다.</li>
      <li><strong>이용한 숙소가 주어진 데이터에 있어서, 주소 매칭을 통해 실제 탄소배출량을 알 수 있는 경우</strong>, 해당 숙소의 탄소배출량을 이용했다. <strong>이용한 숙소가 주어진 데이터에 없는 경우</strong>, <strong>숙소유형별 탄소배출량</strong>을 일반화해 사용했다. 앞서 구한 숙소별 실제 탄소배출량을 이용해 호텔, 리조트 등의 숙소유형별로 평균값을 계산했다.</li>
      <li><strong>사용자가 계산기를 이용할 때</strong>도 위의 로직처럼 이용 숙소가 데이터에 있는 경우와 없는 경우로 분리된다. 이를 통해, 사용자는 정확한 전기사용량 등을 몰라도 탄소배출량을 쉽게 계산할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>(3) 관광 분야</strong>
    <ul>
      <li>관광 분야의 경우 정현, 경주가 맡아서 진행했다.</li>
      <li>선정 데이터 : 주어진 데이터는 t4_nature, t4_tour, t1_culture 를 주소 매칭하여 활용하기로 했다. t4_nature는 자연 경관 관광데이터로서, ‘성산일출봉’, ‘천지연폭포’, ‘천제연폭포’, ‘주상절리대’, 등의 경관이 포함된다. 추가적으로 <a href="https://www.data.go.kr/data/15041982/fileData.do">관광 공공데이터</a>를 리서치해 반영하였다. 관광의 경우, 관광지 목록 데이터와 주소별 온실가스 배출량 데이터를 이용했다. 또한, <strong>비짓제주 사이트의 관광지 정보를 크롤링한 데이터</strong>를 추가로 이용했다.</li>
      <li>아이디에이션 을 통해, → 입장객 수, 카테고리별 탄소배출량, 관광시간을 산출하기로 결정했다.
        <ol>
          <li>관광지카테고리별 (t4) 입장객 수 비율 : 논문 참고 + 추가 자료조사 필요</li>
          <li>관광지 카테고리별 평균 탄소 배출량 : (1인당 계산)</li>
          <li>관광지 카테고리별 평균 관광시간
            <ul>
              <li>아이패드 메모장</li>
            </ul>

            <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/8.png" alt="8" /></p>
          </li>
        </ol>

        <ul>
          <li>c3랑 매칭된 거+c3 매칭 실패들 등 데이터를 일원화함 약간의 충돌도 있었지만, 일반화한 모든 관광지의 탄소배출량 모음을 구현하도록 노력했다. 관광지별 대분류랑 중분류까지 나와있는 csv 등 을 활용해 관광지 루트 추천에도 반영했다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>(4) 교통 분야
    <ul>
      <li><strong>교통은</strong> 주어진 <strong>세개의 내부 데이터</strong>를 이용해 탄소배출량을 구했다. <strong>추가적으로, 비행기</strong>는 탄소배출량이 굉장히 큰 교통편인데, 내부데이터에 자세하게 나오지 않아, <strong>출발공항</strong>과 <strong>이용좌석</strong>에 따른 탄소배출량을 알 수 있는 <strong>구글플라이트 외부데이터</strong>를 이용했다.</li>
      <li><strong>탑승 인원수, 이동거리, 차종</strong> 등을 질문에 담아 탄소 배출량을 최대한 정확히 산출하고자 했습니다.</li>
    </ul>
  </li>
  <li><strong>이상치 처리</strong>
    <ul>
      <li>아무래도 위치정보를 이용한 탄소배출량은 100% 정확할 수 없기에 <strong>탄소배출량에 대한 이상치를 처리</strong>했다.
        <ul>
          <li>예를 들어, ‘<strong>섭지코지</strong>’의 경우 탄소배출량이 매우 높은데, 그 이유는 <strong>주소 권역이 너무 넓게 설정</strong>되어 있어 <strong>여러 건물들이 함께 존재</strong>하기 때문임을 확인했다.</li>
          <li>→ 따라서 <strong>사분위수를 이용해 발견된 이상치들</strong>은 모두 <strong>카테고리별 평균값</strong>으로 대체했다.</li>
        </ul>
      </li>
      <li>우리 프로젝트의 친환경 여행이었기에, 육각형 중 카테고리 부분 점수 선택할때 자연은 5이상으로만 선택할수있게 하는 등의 조치가 필요하리라 생각했다. 자연이 은근 탄소 배출이 안 높게 나오기도 했고 후처리로도 생각보다 잘 걸러지지 않았기 때문이다. 관광지 탄소 배출량은 다 건물로 매칭한 거라 은근 높게 나온다는 것이 문제였다.
        <ul>
          <li>→ 논문 등에 나와있는 유형별 탄소배출량이랑 비교해보고 타당한지 파악하고, 너무 수치 높게나오는 것은 건물 추정 입장객수를 활용해 수치를 정확하게 수정했다.
            <ul>
              <li>교통 / 비행기 $224 kgCO_2$(왕복)</li>
              <li>숙소 / 그랜드호텔 1박에 $28kgCO_2$ → 3박이면 $84kgCO_2$</li>
              <li>음식 / 이탈리안레스토랑 $3.2kgCO_2$ → 12끼면 $2-30kgCO_2$</li>
              <li>관광 / 아직은 천차마별이지만 $0 -3kgCO_2$느낌 -&gt; 12개 한다하면 $1 -30kgCO_2$정도?</li>
            </ul>
          </li>
          <li>사람들이 상식적으로 생각하기에 자연관광지면 탄소배출이 적게나온다는 생각이 드는게 일반적이기에, 우리도 그거에 맞게 탄소배출량 줄이구 그래서 관광지 선택될때도 자연꺼 많이 포함되게 나오도록 조정했다.</li>
        </ul>
      </li>
      <li>단순 해수욕장 등의 자연인데 높은경우는 이상치들 제외한 <code class="language-plaintext highlighter-rouge">md_cat</code> 별 평균으로 대체했다. 상세분류 <code class="language-plaintext highlighter-rouge">md_cat</code>들에 대해서 각각을 boxplot을 그려보고, 이상치를 어떻게 정의할 것인가에 대해 토론 후 이상치를 제외한 평균으로 각 이상치를 대체해야했다. 우리가 원하는 것은 자연 관광지들에 대하여 탄소 배출을 적게 정의하는거니까 평균 밑으로 어느정도 기준점을 잡아서 진행했다.</li>
      <li>대분류&amp;중분류 있는 관광지 이상치: 중분류 내 이상치 제외한 중분류 평균으로 대체</li>
      <li>중분류 없는 관광지 이상치: 중분류 내에서 이상치 처리 완료한 상태에서 대분류 평균으로 대체</li>
    </ul>
  </li>
  <li><strong>번외</strong>
    <ul>
      <li>대상 차량 선별기준 :
  일반 승용차 / 연비 최상 (-탄소배출과 반비례요소) / 탄소배출 최소
  -&gt; 선정 : 현대자동차 아이오닉 N (2019년형)</li>
      <li>
        <p>중간에 너무 엄밀하게 하다 보니 상세한 분류를 어떻게 해야하는지에 따라서 많은 이야기 후 결정하였다. 그 중 기억이 남았던 부분은 말고기가 반추동물이 아니기 때문에 탄소 배출량이 다르다는 말이었다… 구글링 해도 자료가 나오지 않아 돼지고기와 비슷하다 판단하여 적용했다. (사실 말고기를 안 먹기도 하고)</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/9.png" alt="9" /></p>
      </li>
      <li>
        <p>정현이누나가 잘못 보낸 링크에 리액션해주는 모습이다.. 언제였는지 이제는 기억도 안 난다</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/10.png" alt="10" /></p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-친환경-제주-여행-루트와-팁-제안">3. 친환경 제주 여행 루트와 팁 제안</h2>

<ul>
  <li><strong>친환경</strong> 뿐만 아니라, 자유여행을 선호하는 MZ세대에게 매력적인 여행 루트를 제공하기 위해 <strong>개인화 추천</strong>을 중요하게 고려했다. 따라서 단순히 탄소배출량을 최소화하는 것이 아닌, <strong>사용자의 여행취향도 고려하여</strong> <strong>최적의 탄소배출량을 도출</strong>하는, <strong>여행루트 추천시스템</strong>을 설계하였다. 이를 위해서는 <strong>사용자 데이터셋과 여행지 데이터셋이</strong> 필요하다</li>
  <li>
    <p>이때부터는 수업 끝나면 계속 만나서 빅콘만 계속했던 것 같다. 그 때를 생각해봐도, 갤러리를 보아도 그 때의 순간들이 가득하다. 사실 9월 내내동안 데이터만 만질 때도 매일 만나긴했지만..ㅎㅎ 다음 phase로 넘어간 느낌</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/11.png" alt="11" /><em>예쁜 에어비앤비 방에서 빅콘하는 낭만</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/12.png" alt="12" /></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/13.png" alt="13" /></p>
  </li>
</ul>

<h3 id="데이터셋-구축">데이터셋 구축</h3>

<ul>
  <li><strong>3.1. 사용자 데이터셋 생성</strong>
    <ul>
      <li>저희는 <strong>취향저격 Hexagon</strong>이라는 지표를 개발했다. <strong>개인화된 여행루트를 추천하기 위한, 사용자의 취향이 반영된</strong> 6개 요소의 그래프이다. 각 요소에 대해 사용자는 1점부터 10점까지 부여할수 있다. 이 중 <strong>액티비티 선호, 자연 선호, 문화유적 선호</strong> <strong>지표</strong>는 <strong>방문할 관광지를 선정</strong>하기 위한 지표로써, 해당 카테고리의 점수가 높을수록 그 카테고리의 관광지가 루트에 많이 포함된다.</li>
      <li><strong>핫플 선호, 맛집 추구</strong> <strong>지표</strong>는 사용자가 <strong>잘 알려진 곳과 숨겨진 곳 중 어떤 것을 선호하는지</strong>를 반영하기 위한 지표로써, 점수가 높을수록 보다 유명한 곳이 추천된다. <strong>여행 밀도</strong> <strong>지표</strong>는 <strong>방문할 관광지의 총 개수</strong>를 선정하기 위한 것으로, 점수가 높을수록 많은 관광지에 방문한다.</li>
      <li>육각형 지표를 구축했으니 이제 <strong>사용자에게 INPUT을 입력</strong>받는다.
        <ul>
          <li>우선, <strong>제주도의</strong> <strong>어떤 지역</strong><strong>을 여행할 것인지</strong> 선택한다. 동부,서부 같은 큰 단위로도, 구좌읍 같은 작은 단위로도 모두 선택 가능하다. 그리고 <strong>이용할</strong> <strong>교통수단</strong><strong>을 선택한</strong>다. 이 때 친환경 여행을 위한 렌터카 선택 팁도 함께 제공해 친환경 여행을 유도했다.</li>
          <li>그 다음, <strong>취향저격 HEXAGON</strong>을 입력받는다. 이 모든 과정은 <strong>스트림릿</strong>을 활용해 구현했으며, 오른쪽 링크를 통해 확인하실 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3.2. 여행지 데이터셋 생성</strong>
    <ul>
      <li><strong>음식점, 숙박, 관광지</strong> 데이터가 필요했는데, <strong>내부데이터 정보가 부족</strong>하다고 판단해, <strong>여행지 상세 정보</strong>를 제공하는 비짓제주 사이트를 크롤링해 보완했다.</li>
      <li>첫번째로 <strong>음식점 데이터</strong>이다. 비짓제주 사이트에 있는 1646개의 음식점을 크롤링했다. 탄소발자국 계산을 위해 음식점별 해시태그를 바탕으로 음식점을 유형별로 분류한 후, 앞서 구축한 탄소발자국 계산기를 이용해 탄소배출량을 계산했다.</li>
      <li>두번째로 <strong>숙소데이터</strong><strong>는</strong> 총 939개로, 음식점 데이터와 마찬가지로 <strong>숙소를 숙박업종별로</strong> 분류한 후, 탄소발자국 계산기를 이용해 탄소배출량을 계산했다. 마지막으로 <strong>관광지 데이터</strong><strong>는</strong> 총 1101개이며, 여행루트 추천의 메인이 되는 데이터라고 볼 수 있다. 탄소배출량 계산을 위해 제공된 데이터인 ‘<strong>주소별 온실가스배출량 데이터</strong>’를 이용했다.</li>
      <li>이렇게 모인 데이터에 대해 <strong>관광지별 지표 점수</strong>를 계산했다. 앞서 설명드린 것처럼 사용자가 자연선호도를 높게 입력하면, 자연성이 높은 관광지가 추천된다. 이를 위해서 저희는 <strong>한 관광지를 한 카테고리로 분류하는 것이 아니라</strong>, 그 관광지의 상대적인 자연성, 액티비티성, 문화유적성 비율을 산정했다. <strong>예를 들면, ‘성산일출봉’</strong>을 ‘자연’ 카테고리로 분류하는 것이 아닌, 자연성 0.77, 액티비티성 0.68 과 같이 점수를 산정했다.</li>
    </ul>
  </li>
  <li><strong>3.3. 여행지 클러스터링</strong>
    <ol>
      <li>
        <p>우선 <strong>텍스트 전처리</strong>를 하고, <strong>토큰화</strong>를 진행했다. 그다음 Word2Vec를 이용해 관광지를 벡터로 변환하여 수치화하는 <strong>워드 임베딩</strong> 과정을 거쳤다.</p>

        <p><a href="https://colab.research.google.com/drive/1pxjyT3NLVnsUXfO96dD1cuPvazrvXlEe?usp=sharing">bookmark</a></p>
      </li>
      <li>그다음 거리 기반의 군집화 방법인 <strong>k means 클러스터링</strong>을 진행하였고, <strong>고차원의 데이터 셋</strong>을 <strong>차원 축소</strong>하는데 효과적인 <strong>t-SNE</strong>를 이용해, <strong>150차원의 문장벡터를 2차원으로 축소</strong>한 후 결과를 시각화했다.</li>
      <li>생성된 6개의 클러스터 중 <strong>클러스터1</strong>은 해당되는 관광지수가 적으면서, <strong>국내 여행의 목적과 맞지 않는</strong> <strong>의료관광</strong>과 관련된 클러스터라고 판단해 제거했다.</li>
      <li>이후 <strong>클러스터별 상위 10개 명사</strong>를 바탕으로, <strong>유사하다고 판단되는 클러스터를 병합</strong>했고, 최종적으로 <strong>자연, 액티비티, 문화유적 세 개의 클러스터</strong>가 형성되었습니다.</li>
      <li>그 다음 클러스터링 결과를 이용해 <strong>자연성, 액티비티성, 문화유적성 점수를 산정</strong>하는 작업을 진행했다.
        <ul>
          <li>K-means 알고리즘 특성 상 <strong>클러스터의 중심에 위치한 관광지가 해당 클러스터를 가장 잘 대표하므로</strong>, 중심점과의 거리가 가까울수록, 해당 클러스터의 속성이 많이 포함된다고 판단했다.</li>
          <li>따라서  <strong>점수를 (1-거리)의 제곱</strong>으로 설정해, 클러스터 중심점과의 거리가 가까울수록 1, 멀수록 0에 가까운 지표를 산정했다.</li>
          <li>kmeans 클러스터링 개수 일단 6개로 지정하여 (빨주노초파귤) 개수 조정하면서 괜찮은 클러스터를 찾도록 했다.</li>
          <li>
            <p>클러스터 결과 : 최종 크롤링 데이터+명사만 포함+kmeans 8개</p>

            <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">0</span> <span class="p">[</span><span class="s">'카멜리아힐'</span> <span class="s">'휴애리 자연생활공원'</span> <span class="s">'아침미소목장'</span> <span class="s">'김경숙해바라기농장'</span> <span class="s">'아날로그감귤밭'</span> <span class="s">'제주허브동산'</span> <span class="s">'이니스프리제주하우스’..]
  - cluster 1 ['</span><span class="n">성산일출봉</span><span class="p">(</span><span class="n">UNESCO</span> <span class="n">세계자연유산</span><span class="p">)</span><span class="s">' '</span><span class="n">사려니숲길</span><span class="s">' '</span><span class="n">산굼부리</span><span class="s">' '</span><span class="n">섭지코지</span><span class="s">' '</span><span class="n">한라산국립공원</span><span class="s">' '</span><span class="n">에코랜드</span> <span class="n">테마파크</span><span class="s">' '</span><span class="n">비자림</span><span class="err">’</span><span class="p">..]</span>
  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">2</span> <span class="p">[</span><span class="s">'제주국제공항'</span> <span class="s">'하도해변'</span> <span class="s">'제주레일바이크'</span> <span class="s">'서귀포잠수함(대국해저관광)’…]
  - cluster 3 ['</span><span class="n">새별오름</span><span class="s">' '</span><span class="n">용눈이오름</span><span class="s">' '</span><span class="n">다랑쉬오름</span><span class="p">(</span><span class="n">월랑봉</span><span class="p">)</span><span class="s">' '</span><span class="n">백약이오름</span><span class="s">' '</span><span class="n">따라비오름</span><span class="err">’…</span><span class="p">]</span>
  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">4</span> <span class="p">[</span><span class="s">'오설록티뮤지엄'</span> <span class="s">'아쿠아플라넷 제주'</span> <span class="s">'방주교회'</span> <span class="s">'성이시돌목장’…]
  - cluster 5 ['</span><span class="n">우도</span><span class="p">(</span><span class="n">해양도립공원</span><span class="p">)</span><span class="s">' '</span><span class="n">협재해수욕장</span><span class="s">' '</span><span class="n">월정리해변</span><span class="s">' '</span><span class="n">제주올레</span> <span class="mi">12</span><span class="n">코스</span><span class="s">'…]
  - cluster 6 ['</span><span class="n">제주4</span><span class="p">.</span><span class="mi">3</span><span class="n">평화공원</span><span class="s">' '</span><span class="n">마라도</span><span class="p">(</span><span class="n">마라해양도립공원</span><span class="p">)</span><span class="s">' '</span><span class="n">용머리해안</span><span class="s">' '</span><span class="n">정방폭포</span><span class="err">’</span><span class="p">..]</span>
  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">7</span> <span class="p">[</span><span class="s">'썬플라워의원'</span> <span class="s">'THE WE'</span> <span class="s">'서귀포의료원'</span> <span class="s">'솔담한방병원'</span> <span class="s">'제주대학교병원'</span> <span class="s">'제주우리병원'</span> <span class="s">'제주한라병원'</span> <span class="s">'제주카약'</span> <span class="s">'중앙병원'</span> <span class="s">'한국건강관리협회제주특별자치도부'</span><span class="p">]</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="추천시스템-구현">추천시스템 구현</h3>

<ul>
  <li>탄소 배출량만을 최소화하는 친환경 여행 루트를 설계하는 것은 쉽지만, 그러한 여행 루트는 사람들에게 매력적으로 다가오지 못할 것이다. 따라서, 탄소 배출량을 줄이는 친환경 여행 루트를 짜되, 충분히 흥미롭게 느껴지는 루트를 설계하는 게 목적이다.
    <ul>
      <li>저탄소 생태관광 시나리오를 참고하여 이에 주안점을 두고 루트를 설계하는 데에 고려했다. 이를 요약하면 아래와 같다. 그래도 생태관광이기에 자연 경관을 관광지로 선택하였다.
        <ul>
          <li>(최대 배출) 택시 + 호텔, 콘도리조트</li>
          <li>(보편 배출) LPG 렌터카 + 펜션</li>
          <li>(최소 배출) 휘발유 렌터카 + 친구집</li>
        </ul>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/14.png" alt="14" /></p>
      </li>
      <li>저비용으로 설계하는 것 또한 대회에서의 주안사항이었기에 약 70만원 - 100만원으로 그 range를 두고 항공비/식비/숙박비를 지출할 수 있도록 설계했다.</li>
    </ul>
  </li>
  <li>최단경로 알고리즘 이용해서 탄소배출계산기 바탕으로 MZ 세대에 적합한 여행루트 설계
    <ul>
      <li>숙소와 관광명소 크롤링
        <ul>
          <li>숙소/관광명소를 키워드로 네이버 블로그나 인스타그램을 크롤링해서 얻은 데이터를 자연어처리 후 감성분석과 클러스터링한 후, 이를 바탕으로 개인에게 맞는 관광지 추천할 예정이다.</li>
          <li>관광지 근처의 음식점 5개중에서는 네이버 지도 기반 더 유명한 것을 추천하도록 했다.</li>
        </ul>
      </li>
      <li>
        <p>저탄소 배출 관광지</p>

        <p>$input<em>탄소 + (1-input)</em>다른지표$</p>

        <ul>
          <li>다른 지표로는 인기있거나 맛집을 넣었다. 관광지 인기도 지표를 만든 것처럼 음식점도 지표를 만들어 넣었다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>참조하여 구현
    <ul>
      <li>참고한 링크 <a href="https://triple.guide/regions/759174cc-0814-4400-a420-5668a0517edd/articles/841db340-ffb6-4774-8265-45f559f37e2b">트리플에서 제공한 제주 여행 코스 설계방법</a>, <a href="https://www.visitjeju.net/kr/recommendTour/recommendScheduleList?menuId=DOM_000002000000000241&amp;cate1cd=cate0000001350#">비짓제주 여행 일정 페이지</a> 등을 참조하여 구현하도록 했다.
        <ul>
          <li>제주관광공사 - 추천한 곳 → 탄소발자국 매치 : 과연 데이터가 안에 존재하는가?</li>
        </ul>
      </li>
      <li>네이버에서 <a href="https://campaign.naver.com/gabojagojeju/?pcode=naver_brandsearch_myplacesearch_PC">&lt;제주 가보자고, 맛집여지도&gt;</a> 로 해둔 것과 많이 제주도를 가본 경주의 머릿속 네이버지도속 데이터를 활용할수 있도록 했다.</li>
    </ul>
  </li>
  <li>기본 로직
    <ul>
      <li>기본적으로는 ‘관광-밥-관광-밥’, ‘관광-밥-관광-밥-관광’, ‘관광-밥-관광-관광-밥-관광’으로 관광지들을 주요 노드에 두고 밥을 그 사이 끼어넣었다. 방문 관광지 개수는 6개에서 16개 사이로 나왔다.</li>
      <li>여행 첫 날의 경우 비행기 시간에 따라 첫 관광, 혹은 첫 관광밥 생략가능하도록 조정했다. 비행기로 제주도 가는 사람이 많으니 첫 시작지점은 제주공항이고 계산기는 교통에서 선택하도록 했으며, 마지막날은 비행기 시간에 따라 [:-2] 요소 생략가능하도록 설계했다.</li>
      <li>제주도를 크게 동서남북의 네 가지 권역으로 나누었다.
        <ul>
          <li>관광지 주변 숙박이 없는 경우가 많아서, 각 지역별로 가장 유명한 펜션/민박을 하나씩 뽑았다. 꼭 조회수 기반이 아니더라도 인기있는 곳을 추천할수있도록 정의했다.</li>
        </ul>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/15.png" alt="15" /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="제주-어셈블-코드">제주 어셈블 코드</h3>

<p>코드는 이러한 과정들을 구체적으로 구현하는데, 주로 데이터 처리, 필터링, 최적화 알고리즘 등을 포함한다. 예를 들어, <code class="language-plaintext highlighter-rouge">pandas</code> 라이브러리를 사용하여 데이터를 처리하고, <code class="language-plaintext highlighter-rouge">numpy</code>나 <code class="language-plaintext highlighter-rouge">scipy</code>를 사용하여 수학적 계산을 수행하며, 다양한 알고리즘 라이브러리를 통해 최적화 문제를 해결한다. 또한, 사용자의 입력을 받고 결과를 출력하는 사용자 인터페이스 부분도 중요한 역할을 한다. 전체적으로 이러한 코드의 구성은 사용자에게 맞춤형 여행을 제공하는데 필수적인 요소다.</p>

<p>제주_어셈블 코드의 개괄은 다음과 같다. 이 알고리즘은 사용자의 위치, 선호도, 그리고 각 관광지의 특성을 고려하여 개인화된 여행 경로와 식사, 숙박 장소를 제공한다. 전체 과정은 데이터 처리, 최적화 계산, 사용자 입력 처리 등을 포함하여 사용자에게 만족스러운 여행 경험을 제공하는 것을 목표로 한다.</p>

<ol>
  <li>Assemble 함수:
    <ul>
      <li><strong>Filtering</strong>: 사용자의 현재 위치와 관광지 인기도를 바탕으로 관광지를 필터링한다. 적절한 후보군(22개에서 최대 103개)을 선정한 후, 이를 더 관리하기 쉽게 일정 수(예: 22개)로 랜덤 샘플링한다.</li>
      <li><strong>지역 분류</strong>: 관광지를 소분류(loc1, 예: 애월)와 대분류(loc2)로 나누어 관리한다. 유명하지 않은 숨겨진 장소도 포함하여 다양성을 확보한다.</li>
      <li><strong>Combination</strong>: 필터링된 관광지들 중에서 사용자가 하루에 방문할 관광지 수(num tour weighted)에 따라 가능한 모든 조합을 생성한다. 각 조합에 대해 관광 목적, 인기도, CO2 배출량을 합산하여 최적의 조합을 선정한다.</li>
    </ul>
  </li>
  <li>CO2 최소화 및 최적 경로:
    <ul>
      <li><strong>CO2 최소화</strong>: CO2 배출량이 일정 비율 이하인 조합들 중에서, 사용자의 선호도와 가장 유사한 경로를 선택한다.</li>
      <li><strong>최단거리 경로(Recommended tour)</strong>: 선택된 관광지들 중에서 이동 거리를 최소화하는 순서로 방문 경로를 결정한다. 가능한 모든 순서의 조합(permutation)을 고려하여 계산한다.</li>
      <li><strong>Min route</strong>: 전체 경로 중 이동 거리가 가장 짧은 경로를 최종적으로 선택한다.</li>
    </ul>
  </li>
  <li>식사 및 숙박 장소 추천:
    <ul>
      <li><strong>식사 장소 결정</strong>: 사용자가 식사 시간에 맞춰 방문할 수 있는 식당을 daily route에 포함시킨다. 이때 주변 음식점의 정보, 식사 가능 시간, CO2 배출량 및 인기도를 고려한다.</li>
      <li><strong>숙박 장소 결정</strong>: 일정의 마지막 관광지 근처에서 숙박할 수 있는 장소를 추천한다. 사용자의 선호도에 따라 호텔, 펜션, 게스트하우스 등 다양한 유형의 숙소를 고려한다.</li>
    </ul>
  </li>
  <li>유저 적합성 고려:
    <ul>
      <li><strong>User fit 식당 선정</strong>: 사용자의 선호도(bad value)에 따라 식당을 선정하고, 점심과 저녁을 교차하여 배열한다. 만약 적당한 식당이 없으면 지역별 대표 식당(good food)을 제공한다.</li>
    </ul>
  </li>
  <li>숙소 고려
    <ol>
      <li>숙소 추천 시스템:
        <ul>
          <li><strong>일정의 마지막 관광지</strong>: 하루 일정의 마지막 관광지를 기준(min route[-1])으로 주변 숙박 시설을 찾는다.</li>
          <li><strong>주변 숙박 시설 탐색</strong>: 마지막 관광지 이름을 기준으로 주변 숙박 시설을 검색한다. 만약 검색된 숙박 시설이 없거나 분류되지 않은 경우, 추가적인 처리 과정을 통해 적합한 숙박 시설을 찾는다.</li>
        </ul>
      </li>
      <li>사용자 선호도에 따른 숙소 유형 분류:
        <ul>
          <li><strong>여유로운 사용자(beak value &lt; 0.2)</strong>: 사용자가 여유로운 여행을 선호한다고 판단되면, 호텔, 리조트, 콘도와 같은 고급 숙소를 추천한다.</li>
          <li><strong>보통의 여행자(0.2 ≤ beak value &lt; 0.8)</strong>: 평균적인 여행 선호도를 가진 사용자에게는 펜션, 민박, 모텔, 여관 등을 추천한다.</li>
          <li><strong>활동적인 여행자(beak value ≥ 0.8)</strong>: 활동적이고 경제적인 여행을 선호하는 사용자에게는 게스트하우스, 캠핑, 글램핑 등을 추천한다.</li>
        </ul>
      </li>
      <li>예외 처리:
        <ul>
          <li><strong>숙소 미발견 시 대응</strong>: 적합한 숙소를 찾지 못하는 경우, 사전에 정의된 ‘good accom’ 목록에서 대체 숙소를 추천한다. 이 목록에는 각 지역별로 대표되는 숙소가 포함되어 있어, 사용자에게 일정한 품질의 숙박 시설을 제공할 수 있다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">assemble(df, user)</code> 로 함수를 불러서 쓸 수 있다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/16.png" alt="16" /></p>
  </li>
</ol>

<ul>
  <li>
    <p>새벽에 경훈이 형 코드가 잘 돌아가지 않아서,, 혜나랑 열심히 삽질하다, 첫 번째 페르소나가 나왔던 감격스런 순간이다. 깨 있던 혜나와 나는 정말 이 때 기뻤다. 당일 오전 여섯시에 경주는 지쳐 자고 있었고 정현이누나는 집을 갔다가 방으로 다시 오는 길이었던걸로 기억한다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/17.png" alt="17" /><em>드디어 나온 페르소나</em></p>
  </li>
  <li>
    <p><strong>대고객 커뮤니케이션 방안</strong></p>
    <ol>
      <li><strong>인스타그램 활용 방안이다.</strong>
        <ul>
          <li><strong>취향저격 Hexagon에 따라 추천된 여행루트</strong>를 <strong>밤하늘 별자리</strong>로 표현해, 인스타그램에 공유하는 <strong>이벤트</strong>를 제안했다. 이는 탄소배출량을 줄이면, 공기가 맑아지고 밤하늘의 별이 더 밝게 빛나게 된다는 점에서 착안하였다.</li>
          <li><strong>MZ 세대는 인스타그램</strong>을 활발히 이용하기 때문에, MZ 세대 이용자를 확보할 수 있을 것으로 기대했다.</li>
        </ul>
      </li>
      <li><strong>제주도 북두칠성 버스킹 라이브</strong>
        <ul>
          <li><strong>현대카드</strong>는 매년 슈퍼콘서트를 개최해 큰 홍보 효과를 누렸지만, 콘서트는 개최 과정에서 많은 탄소가 배출된다는 문제가 있다. 현대카드가 고객의 문화생활을 타게팅하기 위해서 현대카드 슈퍼콘서트같은거나 현대카드 뮤직라이브러리를 운영하는데 제주도에서도 저녁부터 시작해서 조명없는 어쿠스틱 콘서트 하면 좋을 것 같다고 생각했다.</li>
          <li>별도의 조명이 필요없는 <strong>칠성대 분수 공원</strong>에서 진행하는 <strong>친환경적인 버스킹 콘서트를 신한카드 측에 제안하는 것으로 마무리했다.</strong></li>
        </ul>
      </li>
      <li><strong>신한카드 ESG 제주 여행 콘테스트</strong>
        <ul>
          <li>기존에 존재하는 <strong>신한 그린 인덱스 지수</strong>를 활용하여 여행 시 탄소 절감을 잘 실천한 고객을 선정하거나, <strong>친환경 여행 브이로그 영상 우수작</strong>을 선정하는 콘테스트이다.</li>
          <li><strong>위 3가지의 방법</strong>을 통해 <strong>신한카드의 친환경 경영 이미지를 구축</strong>할 수 있으며,  ‘친환경 여행’이라는 MZ세대의 새로운 트렌드를 만들어나갈 수 있을 것이라 기대한다.</li>
          <li>제주관광공사 측면에서랑 신한카드 가 데이터를 제공했다는 것에 착안하여, 제주 관광객과 신한카드 이용고객에 대한 커뮤니케이션 방안을 제안했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="제출-당일">제출 당일</h2>

<ul>
  <li>분석 주제, 사용한 데이터, 전처리, 모델링, 결과, 활용 방안 등 모두가 쉽게 이해할 수 있을만큼 탄탄한 스토리를 구성했다. 나랑 경주가 같이 작업에 들어갔다. 창업팀 등 다양한 활동으로 나는 프레젠테이션 자료를 빨리 잘 만든다는 장점을 가지고 있고, 경주는 디자인적으로나 경영적으로 어떠한 장표가 어울리는지 잘 알고 있어서 끊임없이 파일을 주고받으며 완성을 시켜나갔던 것 같다.</li>
  <li>
    <p>제출당일, 밤을 새고 긴박하게 제출했던 우리들의 모습이다. 고등학교 때도 대학교 때도 밤을 샌 적 없었는데 에어비앤비로 방을 대여해 열심히 달렸던 기억이 난다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/18.png" alt="18" /></p>
  </li>
  <li>
    <p>경훈 취뽀 이후 현직자 데이까지 예측한 혜나 정현의 모습이다</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/19.png" alt="19" /></p>
  </li>
  <li><strong>수업도 째고.. 마감 5분전 벼락치기 제출 완료</strong>⚡</li>
  <li><u>**1차 서류평가 기준**</u>
    <ul>
      <li>탄소 계산기(40%) + 여행루트(50%) + 고객 커뮤니케이션 방안(10%)</li>
      <li>단순 탄소 배출량 최소화보다, 탄소배출량 절감 TIP등을 활용한 탄소 중립을 실천하는 여행 루트 개발하기</li>
    </ul>
  </li>
  <li>
    <p>제출완료 “귀하의 건승을 기원합니다”</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/20.png" alt="20" /></p>
  </li>
</ul>

<h1 id="발표심사1128">발표심사(11.28)</h1>

<ul>
  <li>2차 PT 발표심사는 현장 발표로 진행되며, 발표순서는 2022 빅콘테스트 서포터즈에서 추첨방식으로 선정 예정이었다. 이노베이션분야의 경우 11. 28(월)이고, 12팀 중에 2번째로 선정되어 열시 쯤 발표가 진행될 예정이었고, 청계천 주변 한국지능정보사회진흥원 서울사무소에서 발표를 진행했다.</li>
  <li><u>**2차 발표평가 기준은 다음과 같았다.**</u>
    <ul>
      <li>1차 서류심사 내용 구체화 및 발표능력</li>
      <li>심사위원 질의에 대한 논리적 대응 및 설명력</li>
    </ul>
  </li>
  <li>
    <p>아침 일찍 만나서 사진 왕창 찍었다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/21.png" alt="21" /></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/22.png" alt="22" /></p>
  </li>
  <li><strong>빅콘테스트 이노베이션분야 2차 PT발표 질의응답</strong>
    <ul>
      <li><strong>1-1 질문과 답변:</strong> 숙소에서의 탄소 배출량 계산에 수용 인원을 고려했는지 여부.
        <ul>
          <li>→ <strong>답변</strong>: 숙소의 성격과 수용 인원이 다양하여 정확한 인원 수와 객실별 탄소 배출량을 알기 어렵다. 따라서 건물에서 나오는 총 탄소 배출량을 기준으로 하며, 특정 건물에 대한 정보가 없을 경우 유형별 평균값을 사용하여 계산한다.</li>
        </ul>
      </li>
      <li><strong>2번째 질문과 답변:</strong> MZ 세대의 특성을 반영한 탄소 저감 여행과 여러 명이 여행할 경우의 여행 루트 설계에 대한 고려 사항.
        <ul>
          <li>→ <strong>답변</strong>: MZ 세대의 특성을 반영하여 인기도, 유행, 독특한 장소 선호 등을 고려하여 알고리즘을 설계했다. 여러 명이 여행할 경우 각자 선호도를 조정하여 그룹에 최적화된 경로를 찾는데, 이는 알고리즘의 인풋 값을 조정하여 다양화된 추천을 받는 방식으로 해결할 수 있다.</li>
        </ul>
      </li>
      <li><strong>3번째 질문과 답변:</strong> GeoPy 라이브러리를 사용한 직선 거리 계산의 정확성.
        <ul>
          <li>→ <strong>답변</strong>: 실제 주행 거리와 직선 거리가 다를 수 있으나, 네이버 API 사용의 비용과 속도 문제로 GeoPy 라이브러리를 사용하여 직선 거리(유클리디언 거리)를 계산했다.</li>
        </ul>
      </li>
      <li><strong>4번째 질문과 답변:</strong> 숙박 시설의 속성별 선택과 탄소 배출량 계산에 대한 고민.
        <ul>
          <li>→ <strong>답변</strong>: 여행 밀도와 선호도에 따라 숙박 시설을 선택하며, 데이터베이스에 있는 호텔의 탄소 배출량 정보를 활용하여 저탄소 숙소를 추천한다.</li>
        </ul>
      </li>
      <li><strong>5번째 질문과 답변:</strong> 개인의 선호도에 고착되지 않고 다양한 관광지를 추천하는 대응책.
        <ul>
          <li>→ <strong>답변</strong>: 알고리즘에 랜덤성을 도입하고, 리커트 척도를 10점으로 설정하여 사용자가 다양한 선호도를 입력할 수 있게 함으로써, 똑같은 입력에도 다른 결과가 나오도록 설계하여 다양화된 추천을 제공한다.</li>
        </ul>
      </li>
      <li>
        <p>이후 메일이 오고 나서 시상식때 최종 결과가 나옴을 전달받았다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/23.png" alt="23" /><em>2022년 2학기의 결실!</em></p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="시상식1221">시상식(12.21)</h2>

<ul>
  <li>
    <p><strong>최우수상을 받을 수 있었다.</strong></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/24.png" alt="24" /></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/25.png" alt="25" /></p>
  </li>
  <li><strong>의미 없는 경험은 없다!</strong>
    <ul>
      <li>2학기 거의 전체, 3개월에 달하는 기간동안 여념 없이 대회에 참여함과 동시에, 공대생 3학년의 신분으로 학교를 다니면서도, 나의 경우엔 창업팀에서의 성과가 나와서 빅콘 대회 당일에도 다이슨 어워드 시상식을 갔다오는 등 빡빡했던 스케줄이었다.</li>
      <li>
        <p>그러한 긴 기간동안, 적지 않은 명수의, 아주 다각화된 배경을 가지고 있는 다섯명의 구성원들과 함께했던 시간들을 떠올려 보면 정말 후회없다. 의견 충돌이 있을 때에도 서로 충분히 근거에 빗대어 설명했고 그 합치된 의견에 대해서는 함께 나아갔다. 피땀흘려 함께했던 시간들이 대학생활 중 따스했던 추억으로 남아있다. 상을 수상할 수 있어 좋았지만, 좋은 친구들과 열심히 협업했던 스물셋의 소중한 기억으로도 충분했다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/26.png" alt="26" /><em>동아리 자기소개 페이지에서도 이루어진 빅콘자랑 ~</em></p>
      </li>
    </ul>
  </li>
  <li><strong>진로로서의 고민 해결</strong>
    <ul>
      <li>소프트웨어 엔지니어로서의 꿈은 초등학생 때부터 <strong>스티브 잡스</strong>를 동경하며 지속적으로 바라 온 목표였고, 고등학생 때 부터는 <strong>딥러닝 엔지니어</strong>의 꿈을 위해 노력하고 있습니다. 대학에서도 데이터를 다루는 역량과 더불어 이로부터 인사이트를 창출하는 작업으로부터 다양한 방법론을 효율적으로 적용할 수 있으리라 느껴 INSIGHT 동아리에 합류했다.</li>
      <li>INSIGHT, 특히 데벤져스에서 빅콘을 준비하며 정말 다양한 배경과 도메인을 가지고, 각자의 목표를 향해 나아가는 열정적인 학회원들과 교류하며 깊은 리스펙은 물론 서로로부터 좋은 에너지와 시너지를 낼 수 있었다. 데이터 분석 뿐만 아니라 개발, 딥 러닝에 이르기까지 많은 분야로부터 열정적으로 참여할 기회 그 자체였다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/27.png" alt="27" /></p>

<h2 id="신한카드월드뱅크-그린인덱스-워크샵">신한카드&amp;월드뱅크 그린인덱스 워크샵</h2>

<ul>
  <li>빅콘테스트 사무국에서 오랜만에 정현이누나를 통해서 연락이 왔다. 탄소 데이터 관련하여 대학생 대회 프로젝트를 발표하는 자리였다. 이전 피피티로부터 부족한 부분을 채운 이후, 어색할 수 있는 부분들을 영어로 모두 수정했다. 큰 자리에서 발표하는 기회가 많이 있을 것 같지는 않으리라 생각했기에 내가 발표를 진행했다.</li>
</ul>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/28.png" alt="28" /><em>또다시 울린 정현이누나의 버스터콜</em></p>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/29.png" alt="29" /></p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="경험" /><category term="Reminiscent" /><category term="대회" /><summary type="html"><![CDATA[의미없는 경험은 없다!]]></summary></entry><entry><title type="html">[ALG] 4.3. Misc.</title><link href="http://localhost:4000/ALG-4.3.-Misc" rel="alternate" type="text/html" title="[ALG] 4.3. Misc." /><published>2022-09-30T00:00:00+09:00</published><updated>2022-09-30T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.3.-Misc</id><content type="html" xml:base="http://localhost:4000/ALG-4.3.-Misc"><![CDATA[<h1 id="alg-huffman-1">[ALG] Huffman (1)</h1>

<p>Huffman Correctness Proof</p>

<p>Proof by Induction</p>

<p>if the set of trees obtained in the ith step are branches in a binary tree corresponding to an optimal code, then the set of trees obtained i+1 th step</p>

<h1 id="alg-intractable-problem-and-approximation-alg-1">[ALG] Intractable Problem and Approximation Alg (1)</h1>

<p>Millenium problems</p>

<p>NP Hard</p>

<ul>
  <li>0-1 knapsack
    <ul>
      <li>문제 size n에 대해서 솔루션 찾지도, 증명도 못하였지만 상수시간에 못 푸리라 생각한 NP</li>
      <li>1,2, …, n번 물건 중 몇 개만 훔칠건데, 훔친 것들 무게의 합이 가방 용량보다는 같거나 작으면서 내가 훔쳤을 때 얻을 수 있는 이득의 총합</li>
    </ul>
  </li>
  <li>subset sum
    <ul>
      <li>양의 정수 n개가 있는데, n개 중 몇 개를 뽑을 건데 해당 조건을 만족하면서 뽑은 것들의 총 합이 주어진 조건보다 작거나 같으면서 뽑은 것들의 무게를 최대화하는것</li>
      <li>뽑은 것들의 무게의 합을 최대화 : $\Sigma_{i \in A} w_i$</li>
    </ul>
  </li>
  <li>뭐가 더 어려울까?
    <ul>
      <li>둘 다 아무도 n에 대해서 효율적인 알고리즘 (polynomial time)을 찾지 못했고 없다고 증명도 못했고 단지 없을 것이라고 생각함.</li>
    </ul>
  </li>
</ul>

<h1 id="polynomial-and-exponential-time-function">Polynomial and Exponential Time Function</h1>

<ul>
  <li>$n^k$까지가 Polynomial time - $2^n$ 은 exponential time</li>
  <li>polynomial solution이 존재하면 효율적인 알고리즘이 존재한다.</li>
</ul>

<p>intractable problem = hard problem</p>

<ul>
  <li>무궁무진하게 많으나 아무런 솔루션을 찾지 못했음</li>
</ul>

<p>polynomial</p>

<p>없다고 증명할 수 있으면 해라</p>

<p>효율적인 알고리즘을 못 찾았는데 - 내가 못해서 그런가보다</p>

<p>효율적인 알고리즘을 못 찾았는데 - 실제로 가능하지도 않다</p>

<p>효율적인 알고리즘을 못 찾았는데 - 그런데 알고 봤더니 이것이 np complete이다.</p>

<ul>
  <li>→ 그 많은 알고리즘 하는 사람이 못 찾았고 나도 못 찾았다.</li>
</ul>

<p>np complete, hard일 가능성이 큼</p>

<ul>
  <li>→ Approximation alg, Heuristic alg를 통해
    <ul>
      <li>최대화, 극대화해주지는 못하지만 그에 대한 근사치를 찾아주는, 그렇지만 효율적으로 polynomial time 안에 돌아가는 solution을 찾아주는 알고리즘</li>
    </ul>
  </li>
</ul>

<h1 id="다양한-문제들">다양한 문제들</h1>

<h2 id="hamiltonian-path">Hamiltonian Path</h2>

<ul>
  <li>가급적 지나간 곳은 지나가지 않는다.</li>
</ul>

<h2 id="longest-path">Longest path</h2>

<h1 id="how-do-you-bp">How do you BP~~</h1>

<p>&lt; 시험 무조건 나옴&gt;</p>

<h1 id="0-1-knapsack-problem">0-1 Knapsack Problem</h1>

<ul>
  <li>optimization 문제 : 0-1 knapsack, subset sum
    <ul>
      <li>무언가를 최대로 최적화하는 문제</li>
      <li>Ex. 훔친 물건의 무게, 가격, 가방의 용량 → 내 가방에 담을 수 있는 선에서 해당 profit을 maximize해주는 selection을 찾아라.</li>
    </ul>
  </li>
  <li>이에 대응되는 ‘Decision problem’
    <ul>
      <li>Ex. 훔친 물건의 무게, 가격, 가방의 용량, ‘T’</li>
      <li>T : decision problem이니까 답이 Yes or No로 나뉘어 나옴 : 이런 무게와 profit, W가 주어졌을 때 허용된 용량 안에서 물건을 훔치며 관련 주어진 T보다 큰 것이 가능한가가 문제
        <ul>
          <li>가방에 담으려하는데, 담은 가격의 합이 주어진 값 T보다 많을 수 있느냐 (Ex. 5000원보다 더 훔쳐올 수 있느냐)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>→ optimization이 어려움</li>
</ul>

<h1 id="subset-sum-problem">Subset Sum Problem</h1>

<ul>
  <li>Decision Problem
    <ul>
      <li>Given a set of positive integers ${s_1, s_2, … s_n}$ of size n and a positive integer T, does there exist a suset A of {1,2,…,n} such that $S_i = \Sigma_{i \in A} s_i$?</li>
      <li>훔칠 것들의 무게 s,</li>
      <li>이중에 몇 개를 뽑는다. 뽑은 것들의 합이 주어진 s와 같게 해줄 수 있느냐?
        <ul>
          <li>S라는 집합이 있고 T가 주어졌을 때, 몇 개를 뽑아 T값이 나오도록 하는 선택이 가능하냐 (T보다 더 많이 훔쳐낼 수 있냐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>knapsack이 조금 더 어렵다
    <ul>
      <li>$subset sum \leq_p 0-1 knapsack$ (polynomial time에 transform이 가능하다)</li>
      <li>Polynomial Reduction: from suset sum to 0-1 knapsack
        <ul>
          <li>0-1 knapsack만  polynomial time에 풀 수 있으면 subset sum도 풀 수 있다.</li>
        </ul>
      </li>
      <li>둘 다 정답 Yes or No</li>
    </ul>
  </li>
</ul>

<p>언제 n, s_1, s_2, ..n에서 합이 정답이 S가 나올까? 넘으면 Yes, 아니면 No</p>

<p>문제의 답이 No면 정답도 No를 출력해 줌.</p>

<p>해당 답을 가지고 transform을 통해 parameter를 만들어 냄 : n은 그대로 n으로 가고, w1..wn과 p1,,, pn을 만들어냄. 어떻게 하면 될까? →</p>

<p>n은 그대로 집어넣고,  s1_… sn은 w1…wn에 그대로 넣고 T값을 W, T에도 넣어줌</p>

<ul>
  <li>0-1 knapsack에서 w1, w2, .. wn - p1, p2, … pn → 뽑은 것들의 $\Sigma s_i \geq T, \Sigma s_i \leq T \rightarrow \Sigma s_i = T$</li>
  <li>이 중에 몇개를 뽑아서 합이 T가 되도록 하는 것이 가능하냐
    <ul>
      <li>문제를 transform : 언제 Yes를 출력할까? 우리가 이 문제에서 (가방 용량 허용하는 선에서 물건을 훔치는데 훔친 가격의 합이 T보다 크면 Yes.) (profit, 무게를 subset sum에서의 값으로 바꾸었으니까 $\Sigma s_i \geq T, \Sigma s_i \leq T \rightarrow \Sigma s_i = T$가 가능한가.</li>
    </ul>
  </li>
  <li>Transform
    <ul>
      <li>집어넣는 과정 : linear time에 가능</li>
    </ul>
  </li>
  <li>0-1 knapsack
    <ul>
      <li>Polynomial time</li>
    </ul>
  </li>
  <li>subset sum
    <ul>
      <li>0-1 knapsack으로 polynomial reduction으로 전환</li>
      <li>np hard라고 증명 = polynomial에 찾는 게 사실 말이 안됨
        <ul>
          <li>찾지도 못했고 없다고 증명도 못했고</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Fact 2읽어보기</p>

<ul>
  <li>knapsack을 polynomial에 대해 풀수 있으면 subset problem도 polynomial 시간안에
    <ul>
      <li>np complete : very hard</li>
      <li>polynomial solution을 찾아오던지, 없다고 증명하던지</li>
    </ul>
  </li>
</ul>

<p>$B,C  \in NP-Comlete$ 이면 $C \leq_p B \leq_p A$</p>

<p>Polynomial reduction을 해서 C도 NP Complete임을 증명 … 줄줄이 증명</p>

<ul>
  <li>→ 원조 문제 $X \leq_p … \leq_p B \leq_p A$
    <ul>
      <li>이미 알고 있던 np complete문제를 가지고 reduction : 태초에 문제가 하나 있어야 Polynomial reduction하여 np-complete</li>
      <li>Subset sum가지고 0-1 knapsack, …</li>
      <li>원조 문제는 무엇일까:
        <ul>
          <li>Proof by Cook</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CNF Conjunctive normal form
    <ul>
      <li>formula
        <ul>
          <li>$(p \lor q \lor s) \land (\bar q \lor r ) \land () \land () \land (\bar p \lor \bar s \lor \bar q)$</li>
          <li>or들의 and로 되어 있음</li>
          <li>신호니까 0 or 1이 input으로 들어감</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>SAT Satisfiability Problem
    <ul>
      <li>각각의 input에다가 0 or 1을 assign해서 CNF formula 결과가 true가 나오는 truth assignment가 존재하는가?</li>
      <li>실제 회로를 설계햇을 때 True로</li>
    </ul>
  </li>
  <li>3- SAT
    <ul>
      <li>CNF Formula에서 식을 3개로 제한하여 놓음 → polynomial 시간에 불가능</li>
      <li>모든 경우를 따져보면 $2^n, n!$ solution은 쉽게 나온다.</li>
    </ul>
  </li>
  <li>Cook’s Theorem
    <ul>
      <li>SAT 문제를 가지고 Clique \leq_p vertex cover \leq_p …  → NP Complete</li>
      <li>어려운 정도가 동등함 (증명되어 있음)</li>
      <li></li>
    </ul>
  </li>
  <li>NP Complete
    <ul>
      <li>이들을 모아둔 것이 ‘NP Complete’</li>
      <li>P : polynomial time algorithm 문제를 모두 모아둔 것</li>
      <li>NP Complete = $NP \cap NP Hard$
        <ul>
          <li>polynomial solution을 찾아오던지 or 없다고 증명하던지</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>BP</p>

<ul>
  <li>동영상에 넣어 출력하자</li>
</ul>

<p>Independent Set</p>

<ul>
  <li>알고 봤더니 1,2번이 싸웠더라 - 3,6,7은 3각관계라서 서로 마주치면 안된다 - 내일 파티를 하는데 싸운 애들은 나타나지 않게 한다. 모든 구성원과 서로의 관계를 줄 때, 최대로 인원을 뽑은 경우</li>
  <li>Ex.
    <ul>
      <li>1,4,5,6 → 싸우지 않은 괜찮은 사람들의 조합</li>
    </ul>
  </li>
  <li>sol : Exponential time algorithm</li>
</ul>

<p>→ 이런 문제들에 대해서 어덯게 대처할 것인가</p>

<ul>
  <li>Approximation Algorithm for BP : FFD Approach</li>
  <li>최대 solution은 못 찾지만 어느정도의 범위는 보장되는 알고리즘
    <ul>
      <li>애매한 89% 정도까지는 최적의 솔루션이 보장되는 polynomial time solution</li>
      <li>heuristic algorithm은 페이던스?케이던스라는 미국 회사에서 제공해주는 알고리즘 사용 (실제 반도체 회로에서의 유효성을 검증하기 위한 heuristic)</li>
    </ul>
  </li>
</ul>

<h1 id="bin-packing">Bin Packing</h1>

<p>Examples</p>

<ul>
  <li>제한된 용량의 CD에다 파일을 저장하는데, CD에다 굽고싶은 경우.</li>
  <li>2^n 알고리즘으로 쉽게 생각할 수 있음 → 그러나 np-hard로서 없을 것이라고 추정만 하는 상태</li>
</ul>

<h2 id="why-bp-is-a-hard-problem">why bp is a hard problem?</h2>

<ul>
  <li>
    <partition prob="">
</partition>
    <ul>
      <li>A의 부분집합인 A’과 A에서 A’ 뺀 차집합이 가능하냐 가능하지 않느냐.</li>
    </ul>
  </li>
  <li>if we have a polynomial time algorithm for the bin packing problem,
    <ul>
      <li>집합이 있을 때 이를 두 부분으로 나누어 각자 맞</li>
    </ul>
  </li>
  <li>$PARTITION \leq_p BP$
    <ul>
      <li>문제들 간 어떻게 연결이 되어있느냐 이해하기</li>
    </ul>
  </li>
</ul>

<h2 id="3-sat">3 SAT</h2>

<h2 id="vertex-cover-vc">Vertex Cover (VC)</h2>

<ul>
  <li>Vertex 와 Edge로 구성된 graph가 있을 때, 꼭짓점 중 몇 개를 뽑을 것인가 : 해당 graph의 어떤 edge를 가지고 와도 빨간 애가 항상 연결되어 있는 - 어떤 애를 가져와도 최소한 빨간 애가 항상 연결되어 있는 경우</li>
  <li>간단해 보이나 쉽지 않다 :
    <ul>
      <li>exponential alg르 푸는건 쉽지 않을 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="set-cover">Set Cover</h2>

<p>S라는 집합이 있는데, 그들의 부분집합이 존재한다. 그 m개의 부분집합에서 많아야 k개를 뽑아서 그들의 합집합이 S가 되게 함이 가능한가? → Yes or No</p>

<p>많아야 최대 k개까지 뽑아서 그들의 합집합이 S가 되게 하는 것이 가능한가?</p>

<ul>
  <li>Example</li>
  <li>$VC \leq_p SC$
undefined
$S = {S_1, S_2, … S_n}$</li>
</ul>

<p>NP, NP Complete</p>

<h1 id="alg-lps-1">[ALG] LPS (1)</h1>

<details>
  <summary>17</summary>


![0](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/0.png)



  </details>
<details>
  <summary>21</summary>


![1](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/1.png)


![2](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/2.png)


![3](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/3.png)


![4](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/4.png)



  </details>
<ol>
  <li>다음과 같은 문제를 고려하자.</li>
</ol>

<h1 id="17">17</h1>

<p>“NURSESRUN” 처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열을 회문 (palindrome)이라고 한다. 어떤 문자열의 부분 문자열은 원래의 문자열에서 일부 문자만 뽑아 순서를 유지하면서 나열한 문자열으로서, “ABDGI”는 “ABCDEFGHIJ”의 부분 문자열이다. 한 문자열의 부분 문자열 중 회문이면서 길이가 가장 긴 것을 Longest Palindromic Subsequence (LPS)라 한다 (예를 들어, “BBABCBCAB”의 LPS는 “BABCBAB” 임). 이제 주어진 문자열의 LPS를 찾는 문제를 생각하자.</p>

<p>입력 문자열 X[1],X[2], XOX1X2…X-1의 각 문자들이 배열 X[0], x[n-1] 에 저장되어 있다고 하자.조건0 ≤i≤j≤n-1을 만족하는 모든 i, j에 대해 L[i][j]를 X[i]에서 X[j]까지의 연속한 문자열, 즉 XiXi1Xi-2…Xj의 부분 문자열 중 가장 길이가 긴 회문의 길이를 나타낸다고 하자.</p>

<p>가. L[i][i] 값은 무엇인가?</p>

<p>→ L[i][i] = 1</p>

<p>나, i&lt;j인 모든 i, j에 대해 L[i][j] 값은 dynamicprogramming 기법의 원리를 고려하여 다음과 같이 구할 수 있다. 이때 빈칸에 들어갈 내용을 정확히 기술하라. (힌트: 주어진 문자열에 대해 가급적 앞에서나 뒤에서 문자를 한 개씩 제거하여 문제의 크기를 줄일 것)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
<span class="c1">//      L[i][j] = max(L[i+1][j], L[i][j-1]);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// X[i] == X[j]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">//          L[i][j] = L[i+1][j-1] + 2;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h1 id="21">21</h1>

<p>다음과 같은 Longest Palindromic Subsequence 문제를 고려하자.</p>

<p>“NURSESRUN” 처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열을 회문 (palindrome)이라고 한다. 어’떤 문자열의 부분 문자열은 원래의 문자열에서 일부 문자만 뽑아 순서를 유지하면서 나열한 문자열으로서, “ABDGI”는 “ABCDEFGHIJ”의 부분 문자열이다. 한 문자열의 부분 문자열 중 회문이면서 길이가 가장 긴 것을 Longest Palindromic Subsequence (LPS)라 한다(예를 들어, “BBABCBCAB” 의 LPS는 “BABCBAB” 임). 이제 주어진 문자열의 LPS를 찾는 문제를 생각하자.</p>

<p>입력 문자열 X0X1X2…X-1의 각 문자들이 배열 X[0], X[1], X[2], …, x[n-1] 에 저장되어 있다고 하자. 조건 0≤i≤j≤n-1 을 만족하는 모든 i, j에 대해 L[i][j]를X[i]에서 X[j]까지의 연속한 문자열, 즉 XiXi+1Xi+2…X의 부분 문자열 중 가장 길이가 긴 회문의 길이를 나타낸다고 하자. 이제 다음과 같은 코드에 대하여 dynamic programming 기법에 기반을 두어 위 문제를 해결해주는 두 함수 Fillup_L_M_Tables()와 Print_LPS()를 구현하려고 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="cp">#define L(i, j) *(T_L+ (j)-(i))*n - ((j)-(i)-1)*((j)-(i))/2+i)
#define M(i, j) *(T_M+ (j)-(i))*n - ((j)-(i)-1)*((j)-(i))/2+i)
</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">T_L</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">lps</span><span class="p">,</span> <span class="o">*</span><span class="n">T_M</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Find_LPS</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T_L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">T_M</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">lps</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">Fillup_L_M_Tables</span><span class="p">();</span>
    <span class="n">Print_LPS</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input_O.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)))</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error in reading the file %s. Wn"</span><span class="p">,</span> <span class="s">"input_0.txt"</span><span class="p">);</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">WO</span><span class="err">'</span><span class="p">;</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"^^^Input size is %d.Wn"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"^^^Input sequence is %s. WnWn"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">Find_LPS</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>먼저 함수 Fillup_L_M_Tables()의 구현을 보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'L': remove left end, 'R': remove right</span>
<span class="c1">// 'B': remove both ends, 'U': use it</span>
<span class="kt">void</span> <span class="nf">Fillup_L_M_Tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">가</span><span class="p">);</span>
        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'U'</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>

                <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">나</span><span class="p">);</span>
                <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'B'</span><span class="p">;</span>

                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'R'</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">dist</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="n">dist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dist</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">다</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">라</span><span class="p">);</span>
                        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'R'</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">마</span><span class="p">);</span>
                        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'L'</span><span class="o">:</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>가. (6점)이 코드의 Li,i)는 L[i][i]를 나타내는데, (가)에 부분에 들어갈 값은 무엇인지 그 이유는 무엇인지 설명하라.</p>

<p>나. (6점)다음 (나)에 부분에 들어갈 값을 기술하라.</p>

<p>다. (8점)이 코드의 문맥을 볼 때 (다)에 부분에 들어갈 문자는 무엇인지 기술하라.</p>

<p>라. (12점)이 코드의 문맥을 볼 때 (라)와 (마)에 부분에 들어갈 내용을 C/C++ 문법에 맞게 정확히 기술하라.</p>

<p>다음 함수 Print_LPS()의 구현을 보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Print_LPS</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"The length of a LCS is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
            <span class="p">(</span><span class="err">바</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'L'</span><span class="p">:</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'U'</span><span class="p">:</span>
            <span class="n">lps</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="err">사</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">kk</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">kk</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">kk</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">kk</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">lps</span><span class="p">[</span><span class="mi">2</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"***The found LPS is %s.WnWn"</span><span class="p">,</span> <span class="n">lps</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>마. (8점)이 코드의 문맥상 (바)에 부분에 들어갈 내용을 C/C++ 언어 문법에 맞게 정확히 기술하라.</p>

<p>바. (8점)이 코드의 문맥상 (사)에 부분에 들어갈 내용을 C/C++ 언어 문법에 맞게 정확히 기술하라.</p>

<p>사. (8점) 다음과 같은 내용의 입력 파일에 대하여.</p>

<p>9</p>

<p>BBABCBCAB</p>

<p>이 프로그램 수행 결과 구한 L 테이블의 내용은 다음과 같다.</p>

<p><img src="/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/5.png" alt="5" /></p>

<p>이때 L[1][8] 값을 구하는데 필요했던 L 테이블의 원소 L[x][y]의 인덱스를 기술하라.</p>

<p>(주의: 답은 (1, 8)-&gt; (2, 4)와 같이 기술하며, 두 개 이상의 원소가 필요하였다면 각 원소의 인덱스를 기술할 것)</p>

<p>아. (8점) (위 문제에 이어서) 이때 L[1][7] 값을 구하는데 필요했던 L 테이블의 원소 L[x][y]의 인덱스를 기술하라. (주의: 답은 (1, 7) -&gt; (2, 4)와 같이 기술하며, 두 개 이상의 원소가 필요하였다면 각 원소의 인덱스를 기술할 것)</p>

<p>자. (15점) 동일한 내용의 입력 파일에 대하여, 이 프로그램 수행 결과 구한 M 테이블의 내용은 아래와 같다.</p>

<p><img src="/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/6.png" alt="6" /></p>

<p>이때 Print_LPS() 함수의 while 문장에서 Ips[] 배열을 구축하는 과정에서 방문한 이 테이블의 인덱스는 다음과 같은데 아래의 빈칸을 메꾸어라.</p>

<p>(0, 8)-&gt; (?, ?) -&gt; (?, ?)-&gt; (?, ?)-&gt; (?, ?) -&gt; (4,4)</p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] Huffman (1)]]></summary></entry><entry><title type="html">[ALG] 4.2. DP Application</title><link href="http://localhost:4000/ALG-4.2.-DP-Application" rel="alternate" type="text/html" title="[ALG] 4.2. DP Application" /><published>2022-09-29T00:00:00+09:00</published><updated>2022-09-29T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.2.-DP-Application</id><content type="html" xml:base="http://localhost:4000/ALG-4.2.-DP-Application"><![CDATA[<h1 id="alg-45-응용1-longest-common-subsequence-lcs-1">[ALG] 4.5. [응용1] Longest Common Subsequence (LCS) (1)</h1>

<h1 id="longest-common-subsequences-lcs">Longest Common Subsequences LCS</h1>

<blockquote>
  <p>💡 공동으로 갖는 common subsequence의 길이가 얼마나 긴가</p>
</blockquote>

<ul>
  <li><strong>[T. Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009. 16.3]</strong></li>
  <li>Definitions
    <ul>
      <li>Given a sequence $X = &lt;x_1, x_2, …, xm &gt;$ another sequence $Z = &lt;z_1, z_2, …, zk &gt;$ is a <strong>subsequence</strong> of X if there exists a strictly increasing sequence $&lt;i_1, i_2, …, i_k &gt;$ of indices of <em>X</em> such that $\forall j = 1, 2, …, k$, we have $x_{ij} = z_j$
        <ul>
          <li>A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out.</li>
          <li>sequence : 나열한 것 / subsequence : 해당 sequence에서 순서를 유지하며 뽑아낸 형태
            <ul>
              <li>Ex. ABCDEFGHI → ABD, AEFGH, AFI, … 등이 있다.
                <ul>
                  <li>(단, 앞에서부터가 아니라 순서가 뒤바뀐 IHE, BIDEHF 와 같은 문자열은 부분 문자열이 될 수 없다)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>empty sequence : 0개의 element로 구성된 것</li>
          <li>Ex: $\ X=&lt;A,B,C,B,D,A,B&gt;, \ Z=&lt;B,C,D,B&gt;(&lt;2,3,5,7&gt;)$
undefined	- Given two sequences <em>X</em> and <em>Y</em>, we say that a sequence <em>Z</em> is a <strong>common subsequence</strong> of <em>X</em> and <em>Y</em> if <em>Z</em> is a subsequence of both <em>X</em> and <em>Y</em>.</li>
          <li>
            <p>Ex:</p>

            <p>$X = &lt;A, B, C, B, D, A, B&gt;, \ Y = &lt;B, D, C, A, B, A&gt;,\ Z_1 = &lt;B, C, A&gt;,\ Z_2 = &lt;B, C, B, A&gt;,\ Z_3 = &lt;B, D, A, B&gt;$</p>
          </li>
        </ul>
      </li>
      <li>Given a sequence $X = &lt;x_1, x_2, …, x_m &gt;, X_i = &lt;x_1, x_2, …, x_i &gt;$ is the ith <strong>prefix</strong> of <em>X</em>, for $i = 0, 1, …, m$
        <ul>
          <li>prefix 접두사 :
            <ul>
              <li>sequence가 있을 때 앞에서 네개 뽑은 X4가 prefix of sequence</li>
            </ul>
          </li>
          <li>Ex: $X = &lt;A, B, C, B, D, A, B&gt;, \ X_4 = &lt;A, B, C, B&gt;,\ X_0 =$null sequence</li>
          <li>empty vs null : 두 용어 모두 같은 맥락으로 활용됨
undefined- Problem</li>
        </ul>
      </li>
      <li>생물 DNA 염기서열 : 얼마나 둘이 유사한가 비교한다
        <ul>
          <li>metric 정의 : 문제에 따라서, 상황에 따라서 어떻게 결정하느냐에 따라서 알고리즘을 만들어 문제를 해결한다.</li>
          <li>Longest common subsequence를 찾아서, 얼마나 긴가 확인하는 문제</li>
        </ul>
      </li>
      <li>Given two sequences $X = &lt;x_1, x_2, …, x_m &gt;$ and $Y = &lt;y_1, y_2, …, y_n &gt;$
        <ul>
          <li>m, n만큼의 두 개 sequence가 주어졌을 때 가장 긴 common sequence를 찾아서 얼마나 긴가를 가지고 판단할 것이다.</li>
        </ul>
      </li>
      <li>
        <p>find a <strong>longest common subsequence</strong> of <em>X</em> and <em>Y</em>.</p>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/0.png" alt="0" /></p>

        <ul>
          <li>optimal substructure : 어떻게든지 문제 하나 사이즈를 조금씩 줄여서, optimal solution을 찾는다. 가장 긴 것 - maximization problem와 일맥 상통</li>
          <li>problem input size : $(m,n)$
            <ul>
              <li>m : X sequence의 길이, n : Y Sequence의 길이</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Naïve approach
    <ul>
      <li>x의 모든 Subsequence에 대하여 y의 subsequence인지 확인</li>
      <li>Enumerate all subsequences of X and check each subsequence to see if it is also a subsequence of Y, keeping track of the longest subsequence found.
        <ul>
          <li>→ Exponential algorithm!
            <ul>
              <li>$\Theta(n \cdot 2^m)$ :  x의 원소개수 m, y 원소개수 n
                <ul>
                  <li>$2^m$ : x의 모든 Subsequence 개수</li>
                  <li>$\Theta(n)$ : n개의 Element check time</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>The LCS problem can be solved efficiently using dynamic programming.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 중요한 내용 !!</p>
</blockquote>

<ul>
  <li><strong>Optimal substructure of the LCS</strong>
    <ul>
      <li>Let $X = &lt;x_1, x_2, …, x_m &gt;$ and $Y = &lt;y_1, y_2, …, y_n &gt;$ be sequences, and let $Z = &lt;z_1, z_2, …, z_k &gt;$ be any LCS of <em>X</em> and <em>Y</em>.
        <ol>
          <li>If $x_m = y_n$, then $z_k = x_m = y_n$, and $Z_{k-1}$ is an LCS of $X_{m-1}, Y_{n-1}$</li>
          <li>If $x_m \neq y_n$, then an LCS of <em>X</em> and <em>Y</em> is
            <ol>
              <li>either an LCS of $X_{m-1}$ and <em>Y</em></li>
              <li>or an LCS of <em>X</em> and $Y_{n-1}$
       - → pink the longer sequence!</li>
            </ol>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>앞의 것을 하나 빼던지, 뒤에서 하나 빼던지, 앞 뒤에서 각각 하나 빼던지</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![1](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/1.png)
</code></pre></div></div>

<ul>
  <li>Let <em>c</em>[<em>i</em>,<em>j</em>] be the length of an LCS of the sequences <em>Xi</em> and <em>Yj</em></li>
  <li>Optimal substructure for computing $c[i, j]$
    <ul>
      <li>base case : 0 (empty sequence)</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/2.png" alt="2" /></p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">==</span><span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">else</span> 
    <span class="n">retrun</span> <span class="nf">max</span><span class="p">(</span><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="451omnalgorithm">4.5.1. $O(mn)$ Algorithm</h2>

<ul>
  <li>Filling the table
    <ul>
      <li>b, c table 계산 : $\Theta(mn)$</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/3.png" alt="3" /></p>
  </li>
  <li>Printing the LCS
    <ul>
      <li>$\Theta(m+n)$</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/4.png" alt="4" /></p>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/5.png" alt="5" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/6.png" alt="6" /></p>

<h2 id="452-c-implementation">4.5.2. C Implementation</h2>

<ul>
  <li>
    <p>Courtesy of <a href="http://www.bioalgorithms.info/downloads/code/">link</a></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/** Copyright (C) 2005 Neil Jones. **/</span>
  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="kt">char</span> <span class="o">*</span><span class="nf">LCS</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
  <span class="cp">#define NEITHER 0
</span>  <span class="cp">#define UP 1
</span>  <span class="cp">#define LEFT 2
</span>  <span class="cp">#define UP_AND_LEFT 3
</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
  <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">LCS</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
  <span class="p">}</span>
	
  <span class="kt">char</span> <span class="o">*</span><span class="nf">LCS</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
      <span class="kt">int</span> <span class="o">**</span><span class="n">S</span><span class="p">;</span>
      <span class="kt">int</span> <span class="o">**</span><span class="n">R</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">lcs</span><span class="p">;</span>
	
      <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
      <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
          <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">jj</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">jj</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP_AND_LEFT</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span>
              <span class="p">{</span>
	
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">NEITHER</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span><span class="p">];</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>
              <span class="p">}</span>
	
              <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
	
      <span class="n">ii</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">jj</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">];</span>
      <span class="n">lcs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
      <span class="n">lcs</span><span class="p">[</span><span class="n">pos</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
	
      <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">jj</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">UP_AND_LEFT</span><span class="p">)</span>
          <span class="p">{</span>
	
              <span class="n">ii</span><span class="o">--</span><span class="p">;</span>
              <span class="n">jj</span><span class="o">--</span><span class="p">;</span>
	
              <span class="n">lcs</span><span class="p">[</span><span class="n">pos</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">UP</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ii</span><span class="o">--</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">LEFT</span><span class="p">)</span>
          <span class="p">{</span>
	
              <span class="n">jj</span><span class="o">--</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">]);</span>
          <span class="n">free</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]);</span>
      <span class="p">}</span>
	
      <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">lcs</span><span class="p">;</span>
  <span class="p">}</span>
	
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-46-응용2-the-gapped-alignment-problem-1">[ALG] 4.6. [응용2] The Gapped Alignment Problem (1)</h1>

<h1 id="gapped-alignment-problem">Gapped Alignment Problem</h1>

<ul>
  <li>Problem
    <ul>
      <li>Given two sequences, find a gapped alignment that maximize the score!</li>
      <li>Compare two sequences if they are similar (related).</li>
      <li>Gapped alignment
        <ul>
          <li>Example:
            <ul>
              <li>실험을 하다보면 불완전하기 때문에 Gap을 넣는 것을 허용하고 align하자.</li>
              <li>수치적으로 얼마나 유사한지 밝히기 : mismatch가 일어나면 안되니까</li>
              <li>
                <p>Gap에 대해서는 penalty를 크게 준다</p>

                <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/7.png" alt="7" /></p>
              </li>
            </ul>
          </li>
          <li>A possible alignment scoring scheme
            <ul>
              <li>Ex: match score = 2, mismatch penalty = -1, gap penalty = -2</li>
              <li>이러한 점수 기준으 들어갔을 때, 점수를 최대화해주는 Gap Alignment를 찾아라
                <ul>
                  <li>Ex. 각각 Gap을 집어넣으면 1점, 7점인데 이러한 점수를 최대화해주는 Gap 정렬방법 찾기</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/8.png" alt="8" /></p>
      </li>
      <li>
        <p>case : 위치를 일치시키고 / A에다 Gap을 집어넣어 정렬/ B에다 Gap을 집어넣어 정렬</p>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/9.png" alt="9" /></p>
      </li>
    </ul>
  </li>
  <li>경우에 따라 문제 사이즈 줄이기
    <ul>
      <li>$A = a_1 a_2 a_3 … a_m$, $B = b_1 b_2 b_3 … b_m$</li>
      <li>recursive한 구조 구축 : 제일 끝 부분의 character가 $a_i b_j$</li>
      <li>두 sequence의 가장 끈 부분을 어떻게 처리할 것인가</li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/10.png" alt="10" /></p>
      </li>
      <li>$S(i, j)$ : maximize했을 때의 score</li>
      <li>basis :
        <ul>
          <li>$i=0$ → b의 길이에다가 -2배</li>
          <li>$j=0 $ → a의 길이에다가 -2배</li>
        </ul>
      </li>
      <li>a쪽에다가 gap을 집어넣을 수밖에 없다.</li>
      <li>$S(i,j-1)-2 $
        <ul>
          <li>Gap을 넣어 - 이점 받고 b i-1로 maximize하자</li>
        </ul>
      </li>
      <li>$S(i-1,j)-2$
        <ul>
          <li>Gap을 넣어 - 이점 받고 a i-1로 maximize하자</li>
        </ul>
      </li>
      <li>$s(a_i, b_j) $
        <ul>
          <li>a_i, b_j 넣었을 때 나오는 score</li>
          <li>같으면 2점, mismatch하면 -1점, gap penalty -2점</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DP
    <ul>
      <li>recursive top down이면 답을 못보고 문제 작은 것부터 차근차근 풀어내면 얻어낼 수 있음</li>
      <li>table 구성, 초기화, table fill 을 통해 큰 문제의 정답 찾기,
        <ul>
          <li>어디에다가 Gap을 넣어 정보를 정렬할 것인지 : 점수 table이 필요하고, maximum 구했을 때 max(S, S,S)에서 정보를 취했는지 저장하고 어디에 몇번째에 gap을 저장했는지 출력하기</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="alg-47-응용3-longest-increasing-subsequence-lis-1">[ALG] 4.7. [응용3] Longest Increasing Subsequence (LIS) (1)</h1>

<h1 id="problem">Problem</h1>

<ul>
  <li>Given a sequence $A=(a[0], a[1],…,a[n-1])$, find the length of the longest subsequence such that all elements of the subsequence are sorted increasing order.
    <ul>
      <li>순서를 유지한 subsequence : 값이 증가하는 속성을 가진</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>$(10, 22, 9, 33, 21, 50, 41, 60, 80)→(10, 22, 33, 50, 60, 80)$
        <ul>
          <li>(22, 9, 50, 41)은 increasing subsequence가 아님</li>
          <li>80으로 끝나는 LIS</li>
          <li>→ 직전으로 끝나는게 60이었고, 다시 60으로 끝나는 LIS</li>
          <li>→ ..</li>
        </ul>
      </li>
      <li>$(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)\→(0, 2, 6, 9, 11, 15), \(0, 4, 6, 9, 11, 15) …$</li>
    </ul>
  </li>
  <li>Algorithm
    <ul>
      <li>Let $d[i]$ be the length of the LIS that ends in the element at index <em>i</em>. Then, the answer to the LIS problem is the maximum value of $d[i], i=0,1,…,n-1$
        <ul>
          <li>(a[1], a[2] … a[i]) 까지만 생각했을 때 a[i]로 끝나는 LIS 를 생각해보자</li>
        </ul>
      </li>
      <li>increasing subsequence중 가장 길이가 긴 것을 찾아라</li>
    </ul>
  </li>
</ul>

<h1 id="optimal-substructure">Optimal substructure</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$$
d[i] = \max(1, \max_{j=0,...,n-1/ a[j]&lt;a[i]}{(d[j]+1)})
$$


$i=0,1,..., n-1$

- 가장 큰 것 : 그 길이가 가장 긴 것이 좋음
- d[i] : 5로 끝나는 longest increasing subsequence의 길이로 정의 → 각각의 위치에서 해당하는 d[i]의 길이를 정의한 다음 maximum을 취한다. 모든 d[i]를 구해 maximum을 구하는데 그 lis 길이 구하기
- $(0, 8, 4, 12, 2, 10, 6, 14, 1, 9)$
	- a[i]로 끝나는 lis의 바로 전에 오는 애가 되려면 1은 9보다 값이 작아야 함.
	- 나보다 앞에있는 애들 중에 나보다 작은 애들만 고려해야 함 : 9로 끝나는 LIS가 있을 때 바로 앞에 있는 애는
	- 거기에 있는 애들 중에 나보다 값이 작은 애들이 그 앞에 올 대상이 되어야 함
		- 9보다 작은 0, 8, 4, 2, 6, 1
		- ~~~ 4, 9 / ~~~~ 0, 9 / ~~~ 1, 9
		- 복잡해 보이지만 경우의 수를 찾다보면 자연스럽게 나오는 과정
	- recursive하게 1로 끝나는 LIS를 계산한 다음, 1을 더해 위치를 옮기면 9로 끝나는 위치가 됨. - base step : 1
- d[i]를 i=0~n-1에서 계산하는데 max(d[j]+1)을 계산하기 위한 for loop - table 구성
- 2dim table을 많이 봤지만 이 문제에서는 1dim table로 정의
- 1 dim table 원소 n개 : d[0] - d[1] - … d[n-1] - 알고리즘의 시간복잡도 추정
- 각각의 d[i]에 대해서 값을 계산할 것인데, table을 채울 time complexity는 input size n
- $O(n^2)$
- 나보다 작은 아이들가지고 훑기 : a[i]보다 작은 애들을 가지고 훑음. 그럼 해당 element의 비용은 나보다 앞에 잇는 애들이고 모든 element에 대해서 계산하는 것이므로 - code

```c
int LIS(int *a, int N)
{

    int *best, *prev, i, j, max = 0;

    best = (int *)malloc(sizeof(int) * N);
    prev = (int *)malloc(sizeof(int) * N);
    for (i = 0; i &lt; N; i++)
        best[i] = 1, prev[i] = i;

    for (i = 1; i &lt; N; i++)
        for (j = 0; j &lt; i; j++)
            if (a[i] &gt; a[j] &amp;&amp; best[i] &lt; best[j] + 1)
                best[i] = best[j] + 1, prev[i] = j;
    for (i = 0; i &lt; N; i++)
        if (max &lt; best[i])
            max = best[i];

		// Print the LIS using prev[] here. 
		free( best ); 
		free( prev );
		return max;
}
```
</code></pre></div></div>

<ul>
  <li>best array
    <ul>
      <li>= d table</li>
    </ul>
  </li>
  <li>prev array
    <ul>
      <li>= e table : 같은 size</li>
      <li>찾아가는 table</li>
      <li>LIS의 길이가 얼마인가 출력</li>
    </ul>
  </li>
  <li>주어진 input sequence가 있을 때, 길이가 같은데 서로 다른게 있을 수 있음
    <ul>
      <li>같은 길이인데 서로 다른 increasing sequence</li>
      <li>→ unique하진 않더라도, 분명히 최소 하나는 존재한다.</li>
    </ul>
  </li>
</ul>

<p>LIS의 직전의 element를 찾아가면 해당 나머지 subsequence에서 optimal substructure를 찾아라. 지금까지 한 거랑은 약간 달라서 확 와닿지 않겠지만 반복적으로 이해해보자</p>

<h1 id="minimal-triangulation">Minimal Triangulation</h1>

<ul>
  <li><strong>[A. Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983. 10.2]</strong></li>
  <li>Problem
    <ul>
      <li>Given a set of <em>n</em> vertices for <strong>convex</strong> polygon, find a triangulation such that no two chords cross each other, and the total length of the chords selected is a minimum.</li>
    </ul>
  </li>
  <li>
    <p>Counting all possible selections of chords in an inefficient way results in an exponential algorithm.</p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/11.png" alt="11" /></p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/12.png" alt="12" /></p>
  </li>
</ul>

<h1 id="alg-48-응용4-the-0-1-knapsack-problem-1">[ALG] 4.8. [응용4] The 0-1 Knapsack Problem (1)</h1>

<ul>
  <li>Problem
    <ul>
      <li>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \leq W$
        <ul>
          <li>이러한 index 집합의 부분집합을 선택하라, 이 중에 몇 개를 뽑아라</li>
          <li>$\Sigma_{i \in A} p_i$ 을 최대화하면서,  $\Sigma_{i \in A} w_i \leq W$의 조건 만족
            <ul>
              <li>훔친 물건들의 무게를 가방이 허용해야 하고, 조건 하에 물건을 훔쳐서 벌 수 있는 물건들의 가격들을 maximize</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>${w_1, w_2, …, w_n}$ - 0-1 : binary - 훔치지 않을 것인지, 훔칠 것인지</li>
      <li>${p_1, p_2, …, p_n}$ - 선택할 것인지, 말 것인지</li>
      <li>fractional : 물건을 훔칠 것인지 안 훔칠 것인지</li>
    </ul>
  </li>
  <li></li>
</ul>

<p>문제가 이해가 되지 않는다면 이해한 후 다시 들어볼 것을 추천.</p>

<ul>
  <li>Example
    <ul>
      <li>${w_1, w_2, …, w_5} = {6,5,10,3,4}$
        <ul>
          <li>1, 2, 5 weight의 합은 15</li>
        </ul>
      </li>
      <li>${p_1, p_2, …, p_5} = {9,7,11,6,8}, W=15$</li>
      <li>$\rightarrow {1,2,5}$
        <ul>
          <li>각각 1번, 2번, .. , 5번 부분집합을 선택하면 1,2,5 뽑힌것의 w합은</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>An intuitive interpretation
    <ul>
      <li>There are <em>n</em> items in a store. 가 게에 N개의 물건이 있는데</li>
      <li>The <em>i</em> th item weighs <em>wi</em> kilograms and is worth <em>pi</em> wons, where <em>wi</em> and <em>pi</em> are positive integers.
        <ul>
          <li>i번째 물건은 Wi kg이고 Pi원이다.</li>
        </ul>
      </li>
      <li>A thief has a knapsack that can carry at most <em>W</em> kilograms, where <em>W</em> is a positive integer.
        <ul>
          <li>도둑이 W까지만 담을 수 있는 배낭을 가지고 왔다.</li>
        </ul>
      </li>
      <li>What items should the thief take to maximize his “profit”?
        <ul>
          <li>최대한 이윤을 얻을 수 있게 물건을 훔치는 방법</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="0-a-0-1-knapsack-problem-in-real-life">0. A 0-1 Knapsack Problem in Real Life</h1>

<p><a href="http://standardwisdom.com/softwarejournal/2010/03/bang-for-the-buck-knapsacks-in-real-life/">ref</a></p>

<ul>
  <li>Problem
    <ul>
      <li>
        <p>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \leq W$</p>

        <p>각각의 다른 value, weight를 갖는 item 여러 개기 있다. knapsack은 W kg까지 수용 가능할때, knapsack에 담을 최대 value는 얼마인가</p>
      </li>
      <li>You have a marketing budget of 5 million dollars. (500만 불이라는 홍보비)</li>
      <li>You have the following marketing options and their paybacks in new potential customers:</li>
    </ul>
  </li>
  <li>Which marketing campaigns would you choose to <strong>maximize the total expected reach</strong> under the condition that, for each of these marketing campaigns, you either select it or you don’t?
    <ul>
      <li>많은 사람들에게 노출</li>
      <li>내가 지불한 비용의 합이 500만보다 작거나 같게 : 1,2,3, …, N번</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/13.png" alt="13" /></p>

<ul>
  <li>cost (dollar) - expected reach (people)
    <ul>
      <li>노출되는 사람들의 수</li>
    </ul>
  </li>
</ul>

<h1 id="1-how-to-solve-the-0-1-knapsack-problem">1. How to Solve the 0-1 Knapsack Problem</h1>

<ul>
  <li>Naïve approach
    <ul>
      <li>There are $2^n$ subsets of ${1, 2, …, n}!$</li>
      <li>아이템중에 선택할 수 있는 모든 경우의 수는 2^n : 각 경우에 대해서 profit들의 합이 제일 큰 것 선택</li>
      <li>모든 경우를 따져보는 경우 - 순서대로 넣을지 말지를 결정하기 때문에</li>
    </ul>
  </li>
  <li>Dynamic programming approach
    <ul>
      <li>Let $P(i,w)$ be the <strong>maximized profit</strong> obtained when choosing items *<em>only from the first ii</em> items under the restriction that <strong>the total weight cannot exceed w</strong><em><strong>w</strong></em>.
        <ul>
          <li>parameter 2개 :
            <ul>
              <li>i : 1번부터 2번, 3번, … i번까지만 앞의 i개 item중에 선택</li>
              <li>w : 현재 남은 가방의 허용하는 무게 - 나한테 남은 가방의 용량이 w만큼 남았다.</li>
            </ul>
          </li>
          <li>1번부터 i번까지 선택한 것들 중 weight 합이 W보다 같거나 작게 하는 조건에서 최대 profit의 값</li>
        </ul>
      </li>
      <li>If we let <em>A</em>∗ be an optimal subset of ${1, 2, …, n}$
        <ol>
          <li>$n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$
            <ol>
              <li>dynamic programming 내용 집어넣기 : 인자 두개를 집어넣어서 문제 사이즈를 줄여야 함</li>
              <li>이 값을 계산해야하는데, 값을 선택했을 때 profit들의 합을 maximize
                <ul>
                  <li>선택 각각가장 미지막 i번 의 무게
      - 분명히 값을 maximize하는 최적의 선택이 있는데, 가장 마지막의 n번 Item을 선택하던지 안하던지
      - $P(n,W)$ : n번 물체를 선택했다면</li>
                  <li>$p_n $ : n번 item의 Profit이 더해지고</li>
                  <li>$P(n-1, W-w_n)$ :
                    <ul>
                      <li>나머지 상황에서 maximize : 고려할 Item은 n-1개, 최대 W까지 담을 수 있는데 wn을 뺀 남은 용량</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ol>
          </li>
          <li>$n \notin A* : P(n,W) = P(n-1, W)$
            <ol>
              <li>n번 물체는 선택하면 안 되니까 P(n-1,W)</li>
              <li>recursion : 같은 형태로 표현하는데 문제 사이즈가 작아짐
                <ol>
                  <li>n번 item을 선택하든지, 말든지 + 한 물체에 대해서 나머지 item을 고려</li>
                  <li>(작아진 문제 사이즈) recursive formulation</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Optimal substructure
        <ul>
          <li>$P(i,w)=$
            <ul>
              <li>임의의 i : 0부터 n까지 간다
                <ul>
                  <li>0 : 내가 선택할 수 있는 item이 하나도 없을 때</li>
                  <li>i : 내가 선택할 수 있는 item이 1번부터 i번까지 앞의 i개
                    <ul>
                      <li>i=3 →1,2,3중에 선택할 수 있다.</li>
                      <li>i=0 → 선택할 아이템이 없다</li>
                    </ul>
                  </li>
                  <li>w: 남은 용량 - 0부터 대문자 W까지, 대문자 W는 아직 아무것도 안들어갔을 때</li>
                </ul>
              </li>
              <li>
                <table>
                  <tbody>
                    <tr>
                      <td>0 if $i=0</td>
                      <td> </td>
                      <td>w = 0$</td>
                    </tr>
                  </tbody>
                </table>
                <ul>
                  <li>선택할 아이템이 없다</li>
                  <li>or 가방에 담을 수 없다 (용량이 0)</li>
                </ul>
              </li>
              <li>$P(i−1,w)$
                <ul>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>if $i&gt;0</td>
                          <td> </td>
                          <td>w_i &gt;w$</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                  <li>가장 마지막 물건의 무게인 w_i가 w보다 무거운 경우 자격 미달 (담을 수 없음)</li>
                  <li>i개 물체까지 선택하는 것에 대해서 마지막 것을 선택할것인지
                    <ul>
                      <li>남아있는 가방 무게에 대해서 : I번째 물체는 선택할 요건이 안된다</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>$\max {(P(i-1,w), p_i+P(i-1,w-w_i))}$
                <ul>
                  <li>I&gt;0 : 1,2,…i번 item 중에 선택
                    <ul>
                      <li>i번째 item을 담지 않을 경우 i-1개중에 잘 선택한 ,</li>
                      <li>p_i를 얻고 나머지 i-1개에 대해서 맨 마지막 item을 제외한 무게</li>
                    </ul>
                  </li>
                  <li>담을 수 있는데, 안 담을건지 vs 담을 것인지에 대한 차이
                    <ul>
                      <li>요건은 되는데 i번째 물품을 선택하지 않는게 좋다</li>
                      <li>i번 Item을 선택하는 게 이윤 극대화에 더 좋다.</li>
                    </ul>
                  </li>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>$i&gt;0</td>
                          <td> </td>
                          <td>w_i \geq w$</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>i : 0~4</li>
      <li>w : 0~W(6)</li>
      <li>${w_1, w_2, …, w_4} = {4,3,2,3}$</li>
      <li>${p_1, p_2, …, p_4} = {3,2,4,4}, W=6$</li>
      <li>어떤 순으로 방문해서 채울 것인가
        <ul>
          <li>값을 계산하는데 필요한 게 얼마나 많은지</li>
          <li>i가 하나 빠지고, 하나를 계산하기 위해서는 위에 것이 계산되면 됨
            <ul>
              <li>i-1의 식이 핵심적으로 작용하니까</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/14.png" alt="14" /></p>

<ul>
  <li>0부터 N까지 : 첫 번째 행과 열은 다 0으로 setting하고 좌에서 우로 가면서 setting</li>
  <li>Ex.
    <ul>
      <li>$P(2,4) = \max{(P(1,4), p_2 + P(1, 4-w_2))} = \max{(P(1,4), 2+P(1,1))}=3$
        <ul>
          <li>2 : 1,2중에 선택함, 2번을 담을 자격이 되는지, 안 되는지</li>
          <li>w2=3이니까 가방 용량에는 4니까 담을 수 있음 → (iii)</li>
          <li>P(1,4) : 2번 물체를 담지 않으면 값이 더 커질 것이다
            <ul>
              <li>P(2,4) 위의 줄 : 3</li>
            </ul>
          </li>
          <li>p2+ : 2번을 담겠다 + 2번을 담을 경우 1번을 선택하는 상황에서 w2를 제외한 것 = P(1,1)
            <ul>
              <li>P(1,1) = 3</li>
              <li>P_2 = 2</li>
            </ul>
          </li>
          <li>2번을 담지 않겠다.</li>
        </ul>
      </li>
      <li>$P(4,2) = P(3,2) = 4$
        <ul>
          <li>1,2,3,4중에 선택하는 것인데 4번은 선택할지말지 optimal substructure 중 선택</li>
          <li>남아있는 용량 2 : 4번은 고려 대상도 아님 → 4번은 빼버리고 1,2,3중에 선택하자</li>
        </ul>
      </li>
      <li>$P(3,5) = \max{(P(2,5), p_3 + P(2,5-w_3))} = 6$
        <ul>
          <li>3번 Item의 Weight가 2이니까 담을 수는 있는데 진짜 담을 것인지, 안 담을건지</li>
          <li>p3 =4, P(2, 5-w3) = P(2,3) = 2이므로 6</li>
          <li>두 개중에 뒤에 것이 크다 : 3번을 선택할 것이다라는 의미</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="3-how-to-reconstruct-the-solution">3. How to Reconstruct the Solution</h1>

<ul>
  <li>${w_1, w_2, …, w_4} = {4,3,2,3}$</li>
  <li>${p_1, p_2, …, p_4} = {3,2,4,4}, W=6$</li>
</ul>

<p>i번째 item을 선택할 자격도 안됨 : Weight가 더 큰 경우</p>

<p>i번째 item을 선택할 자격은 되지만: 비교</p>

<ul>
  <li>$P(4,6) = \max{(P(3,6), p_4 + P(3, 6-w_4))} = 8$
    <ul>
      <li>4번의 weight가 3이기 때문에 선택할 자격은 됨 → 4번 선택</li>
      <li>이러한 계산을 통해서 8이 나옴</li>
    </ul>
  </li>
  <li>$P(3,3) = \max{(P(2,3), p_3 + P(2, 3-w_3))} = 4$
    <ul>
      <li>3번의 item은 Weight=2라서 선택할수 있음</li>
      <li>P(2,3-2) = P(2,1) = P(1,1) = P(0,1) = 0 → i는 한 칸씩 올라가면서 선택했는지 아닌지에 대한 번호를 출력함</li>
    </ul>
  </li>
  <li>$P(2,1) = P(1,1) = 0$
    <ul>
      <li>2 X</li>
    </ul>
  </li>
  <li>$P(1,1) = P(0,1) = 0$
    <ul>
      <li>1 X</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/15.png" alt="15" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/16.png" alt="16" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/17.png" alt="17" /></p>

<h1 id="4-implementation-and-time-complexity">4. Implementation and Time Complexity</h1>

<ul>
  <li>
    <p>$O(nW)$ Time</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">zero_one_knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ww</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ww</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">ww</span><span class="o">++</span><span class="p">)</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">ww</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ww</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">ww</span><span class="o">++</span><span class="p">)</span> <span class="c1">//bottleneck - W번 수행</span>
          <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ww</span><span class="p">)</span>
              <span class="p">{</span>
                  <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
   <span class="o">&gt;</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">])</span>
                      <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                  <span class="k">else</span>
                      <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">W</span><span class="p">];</span>
  <span class="p">}</span>
	
	
</code></pre></div>    </div>

    <ul>
      <li>어떤 값이 상수인지 아닌지의 판단 근거는 N이 커지건 작아지건 고정되는게 상수</li>
      <li>지금 time complexity가 nW가 됨은 명확한데 이는 linear time인가?
        <ul>
          <li>table 하나당 $\Theta (1)$씩 계산</li>
          <li>$(n+1) (w+1)$ table : $\Theta(nw)$</li>
          <li>최종 solution은 table 맨 밑 행부터 하나씩 탐색 : $\Theta (n)$</li>
          <li>→ Theta(nw)</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5-0-1-knapsack-ex-1n--6-w--10n6w10">5. 0-1 Knapsack Ex. 1: n = 6, W = 10<em>n</em>=6,<em>W</em>=10</h1>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/18.png" alt="18" /></p>

<ul>
  <li>쫓아가는 방법 생각해보기</li>
  <li>Selected items: i = 2, 3, 4, 6</li>
  <li>Obtained profit: 19</li>
  <li>Is the time-complexity $O(nW)$ an efficient one?
    <ul>
      <li>efficient : polynomial 시간에 bound 될 때 효율적.
        <ul>
          <li>inefficient : exponential, factorial, // n^4, n^3은 비효율적 practical하게</li>
        </ul>
      </li>
      <li>This is not a linear-time algorithm!
        <ul>
          <li>variable :
            <ul>
              <li>n : 도둑이 물건을 훔칠 때 훔칠 수 있는 물건 개수</li>
              <li>W: 도둑의 가방이 허용하는 가방의 총 용량</li>
            </ul>
          </li>
          <li>→ N에 대해서 상수라면,w를 제거하면 이 알고리즘은 linear time - polynomial이므로 효율적
            <ul>
              <li>n의 크기가 얼마든지 커져도 w가 불변?</li>
              <li>n과 w는 독립적 : w가 n에 대해서 bound가 되어야 하는데, 여기서는 독립적이라고 볼 수 있다. N도 w도 문제 상황에 따라 지정된다.</li>
            </ul>
          </li>
          <li>A problem is that <em>W</em> is not bounded with respect to <em>n</em>.
            <ul>
              <li>Ex. What if <em>n</em>=20 and <em>W</em>=20!? → $O(n∗n!)$
                <ul>
                  <li>factorial time algorithm : 더 비효율적으로 만들 수 있음.</li>
                </ul>
              </li>
              <li>When <em>W</em> is extremely large in comparison with <em>n</em>, this algorithm is worse than the brute-force algorithm that simply considers all subsets.
                <ul>
                  <li>n에 대해서도 linear, w에 대해서도 linear. n에 대해서 Polynomial하지 않다.</li>
                </ul>
              </li>
              <li>This algorithm can be improved so that the worst-case number of entries computed is $O(2^n)$</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>No one has ever found an algorithm for the 0-1 Knapsack problem whose worst-case time complexity is better than exponential, yet no one has proven that such an algorithm is not possible!
        <ul>
          <li>polynomial time alg 는 얻지도 못했고, 증명도 못함</li>
          <li>문제 size n에 대해서 증명도 찾지도 못함 — 아마 Polynomial solution이 없을 것이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>np complete, np hard, …
    <ul>
      <li>아무도 증명하지 못한 문제</li>
      <li>n의 몇승이라는 poly sol도 못 찾았고,</li>
    </ul>
  </li>
</ul>

<h1 id="6-a-variation-of-the-0-1-knapsack-problem">6. A Variation of the 0-1 Knapsack Problem</h1>

<ul>
  <li>Problem
    <ul>
      <li>Decision Problem</li>
      <li>Given <em>n</em> items of length $l_1, l_2, …, l_n$, is there a subset of these items with total length exactly <em>L</em>?
undefined- Example</li>
      <li>${ 1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993 }, \ L = 138457{1,2,7,14,49,98,343,686,2409,2793,16808,17206,117705,117993},L=138457 → {1, 2, 7, 98, 343, 686, 2409, 17206, 117705}{1,2,7,98,343,686,2409,17206,117705}$</li>
    </ul>
  </li>
  <li>Dynamic programming approach
    <ul>
      <li>Let $P(i,w)$ be the <strong>maximized profit</strong> obtained when choosing items *<em>only from the first ii</em> items under the restriction that <strong>the total weight cannot exceed w</strong><em><strong>w</strong></em>.
undefined	- If we let <em>A</em>∗ be an optimal subset of ${1, 2, …, n}$
        <ol>
          <li>$n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$</li>
          <li>$n \notin A* : P(n,W) = P(n-1, W)$
            <ul>
              <li>$\rightarrow fill (i, j)$</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h1 id="7-a-divide-and-conquer-approach">7. A Divide-and-Conquer Approach</h1>

<ul>
  <li>
    <p>Let <code class="language-plaintext highlighter-rouge">fill(i,j)</code> return TRUE ⟺ ∃ subset of the first <em>i</em> items that has total length <em>j</em>.</p>

    <p>When <code class="language-plaintext highlighter-rouge">fill(i,j)</code> returns TRUE,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1. If the ith item is used, `fill(i - 1, j -` _`li`_`)` must return TRUE.
  2. If the ith item is not used, `fill(i - 1, j)` must return TRUE.
</code></pre></div>    </div>
  </li>
  <li>
    <p>To solve <code class="language-plaintext highlighter-rouge">fill(int n, int L)</code>,</p>
    <ul>
      <li>$T(n)≥c $if $n=0$</li>
      <li>$T(n) \geq 2T(n-1) +d$ if $n&gt;0$</li>
      <li>$\rightarrow T(n) = \Theta(2^n)$</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fill</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// l[i]: global variable </span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-dynamic-programming-approach">A Dynamic Programming Approach</h2>

<ul>
  <li>The optimal substructure :
    <ul>
      <li>F(i,j)=<em>F</em>(<em>i</em>,<em>j</em>)= <code class="language-plaintext highlighter-rouge">FALSE</code> if <em>i</em>=0,<em>j</em>!=0</li>
      <li>F(i,j)=<em>F</em>(<em>i</em>,<em>j</em>)= <code class="language-plaintext highlighter-rouge">TRUE</code> if <em>i</em>=0,<em>j</em>=0</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$F(i,j)= F(i-1,j)</td>
              <td> </td>
              <td>((l_i \geq j)</td>
              <td> </td>
              <td>F(i-1, j-l_i))$ if <em>i</em>&gt;0</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>O(nL) time implementation</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ll</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ll</span><span class="o">++</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ll</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ll</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ll</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="err">–</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">||</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ll</span><span class="o">-</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">L</span><span class="p">]);</span>
	
	
</code></pre></div>    </div>
  </li>
  <li>
    <p>Example</p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/19.png" alt="19" /></p>
  </li>
</ul>

<h1 id="8-subset-sum">8. Subset Sum</h1>

<p>n에 대해서 polynomial sol도 찾지 못함</p>

<ul>
  <li>Problem
    <ul>
      <li>Given a set of positive integers ${w_1, w_2, …, w_n}$ of size <em>n</em> and a postivie integer <em>W</em>, Find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i\in A}{w_i}$ subject to $\Sigma_{i\in A}{w_i} \leq W$</li>
      <li>양의 정수 n개, 어떤 양의 정수 W가 주어졌을 때 몇 개를 뽑을 것이다. a라는 집합이 뽑은 애들의 index 집합이다. 뽑은 애들의 합을 maximize하라.</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>${w_1, …, w_9} = {20,30,14,70,40,50,15,25,80,60,10,95}, W=99 \\rightarrow {20,14,40,25}$</li>
    </ul>
  </li>
  <li>Application
    <ul>
      <li>There are <em>n</em> jobs, each of which takes <em>wi</em> time.</li>
      <li>Now we have a CPU with <em>W</em> free cycles, and want to choose the set of jobs that minimizes the number of idle cycles.
        <ul>
          <li>w cycle동안에 내가 scheduling해 주어 CPU를 잘 활용해야 한다.</li>
          <li>여러 user들이 들어왔을 때, w1 cycle만큼 소요되고, 2번 user에서 들어오면 w2만큼의 cycle이 필요하고 … n번 user에서 job을 scheduling하면 wn cycle이 필요함</li>
          <li>system을 가장 최적으로 활용하기 위해, w1,, wn 중 몇 개를 뽑아서 scheduling 진행할 것</li>
          <li>뽑은 애들의 합이 W보다 작으면서 maximize : 몇번, 몇번, 몇번 해서 끝에 무수리가 남을 것인데 이 곳에서는 CPU가 idle하는 cycle 발생 : minimize가 목표</li>
        </ul>
      </li>
      <li>→ CPU Cycle이라는 귀한 resource를 낭비하지 않도록 minimize하자</li>
      <li>논외) exact algorithm는 아무도 풀지 못했다. → approximation algorithm, heuristic algorithm</li>
    </ul>
  </li>
  <li>Relation to the 0-1 Knapsack problem
    <ul>
      <li>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \geq W$</li>
      <li>⟺
        <ul>
          <li>Given a set of positive integers ${w_1, w_2, …, w_n}$ of size <em>n</em> and a postivie integer <em>W</em>, Find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i\in A}{w_i}$ subject to $\Sigma_{i\in A}{w_i} \geq W$</li>
        </ul>
      </li>
      <li>0-1 knapsack을 polynomial time에 풀 수 있으면, subset sum도 풀 수 있다</li>
    </ul>
  </li>
  <li>참고
    <ul>
      <li>If it is possible to solve the <strong>0-1 knapsack</strong> problem in <strong>polynomial time</strong>, the <strong>subset sum</strong> problem can be solved in <strong>polynomial time</strong> too.</li>
      <li>Somebody has already proven that the subset sum problem is very hard.</li>
      <li>In other words, the subset sum problem is <strong>NP</strong>complete. → Hence, the 0-1 knapsack problem is also a very hard problem. In other words, the 0-1 knapsack problem is also <strong>NP</strong>complete.
undefined</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] 4.5. [응용1] Longest Common Subsequence (LCS) (1)]]></summary></entry><entry><title type="html">[ALG] 4.1. DP - Concepts</title><link href="http://localhost:4000/ALG-4.1.-DP-Concepts" rel="alternate" type="text/html" title="[ALG] 4.1. DP - Concepts" /><published>2022-09-28T00:00:00+09:00</published><updated>2022-09-28T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.1.-DP---Concepts</id><content type="html" xml:base="http://localhost:4000/ALG-4.1.-DP-Concepts"><![CDATA[<ul>
  <li>divide and conquer: top - down
    <ul>
      <li>효율적이기도 하나 매우 비효율적이 되기도 함</li>
      <li>splitted된 사례들이 서로 관련 없는 문제를 풀때 잘 통함</li>
    </ul>
  </li>
  <li>dynamic programming : bottom -up
    <ul>
      <li>아래에서 위로 올라가며 효율을 추구하자는 방식</li>
    </ul>
  </li>
  <li>NOW
    <ul>
      <li>Divide-and-Conquer Method</li>
      <li><strong>Dynamic Programming Method</strong></li>
      <li>Greedy Method</li>
      <li>Backtracking Method</li>
      <li>Local Search Method</li>
      <li>Branch-and-Bound Method</li>
      <li>Etc.</li>
    </ul>
  </li>
  <li>From <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Wikipedia</a>: Dynamic programming is both a
    <ul>
      <li><u>mathematical optimization method and a computer programming method.</u></li>
    </ul>
  </li>
  <li>A complicated problem is <strong>broken down into simpler sub-problems in a recursive manner</strong>.</li>
  <li>Overlapping subproblems
    <ul>
      <li>A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.</li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.</li>
    </ul>
  </li>
  <li>When applicable, the method <u>**takes far less time than other methods**</u> that don’t take advantage of the subproblem overlap <strong>like the divide- and-conquer technique</strong>.</li>
</ul>

<p>→ 문제 몇개 풀어보고, 이 고상한 말들이 별 것 아닌 자연스러운 원리임을 체득하자!</p>

<h1 id="alg-42-approaches-for-recursive-formulation-1">[ALG] 4.2. Approaches for Recursive Formulation (1)</h1>

<p>Two Approaches for Recursive Formulation</p>

<ul>
  <li>Top Down Approach</li>
  <li>Bototm up Approach</li>
</ul>

<h2 id="421-top-down-approach">4.2.1. Top Down Approach</h2>

<ul>
  <li>$T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j \geq 1$</li>
  <li>$T(i,0) = T(0,j) = 1$ for $i,j≥0$</li>
  <li>recursive하게 똑같이 문제 두개를 푼다 : 빨간 것 하나, 녹색 하나. 그리고 그 결과를 combine하여 원래 문제를 푼다. 문제가 겹치는게 보인다.
    <ul>
      <li>divide and conquer : 상당히 많이 overlap됨을 확인할 수 있다.</li>
      <li>undefined- Easily becomes exponential!</li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/0.png" alt="0" /></p>
  </li>
</ul>

<p>recursive function call : 내려갔다 올라갔다 depth first search하다가 하염없이 돌아오는 것을 의미한다.</p>

<h2 id="422-bottom-up-approach">4.2.2. Bottom Up Approach</h2>

<ul>
  <li>$T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j≥1$</li>
  <li>$T(i,0) = T(0,j) = 1$ for $i,j \geq 0$</li>
  <li>
    <p>Often much more efficient!</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/1.png" alt="1" /></p>
  </li>
  <li>그러나 bottom up은 Top Down과 대비하여 쭉 쭉 쭉 한 줄로 내려가며 잘 풀리게 된다.
    <ul>
      <li>bottom up으로 올라오면서, 그리고 모든 경우에 divide n conquer에 비효율적이고 dp가 효율적인건 아니다.</li>
    </ul>
  </li>
  <li>Bottom up vs. Top down 공통: 둘다 어떤 문제가 재귀적인, recursive한 형태로 문제가 풀리게 된다.
    <ul>
      <li>작게 똑같이 풀어서 합치자 : recursion 한 solution이 나타나게 된다</li>
      <li>solution을 만드는데 재귀적으로 나타난다.</li>
    </ul>
  </li>
  <li>몇 개 안 되는 것을 풀면 되는데, 똑같은것을 반복적으로 보나?
    <ul>
      <li>이를 계산하는 프로그램: 이를 풀기 위해서 필요한 것은 왼쪽 하부, 오른쪽 하부</li>
      <li>거꾸로 생각해보면 : 왼쪽 아래 + 오른쪽 아래 활용해서 그 위 가운데 노드를 구할 수 있다. (아래에서 위로)</li>
    </ul>
  </li>
  <li>아무리 부정하려고 하더라도 인정할 수밖에 없는 원리.</li>
</ul>

<h2 id="423-examples">4.2.3. Examples</h2>

<h3 id="4231-ex1-world-series-odds">4.2.3.1. [ex1] World Series Odds</h3>

<ul>
  <li>Problem
    <ul>
      <li>Dodgers and Yankees are playing the World Series in which either team needs to win <em>n</em> games first.</li>
      <li>Suppose that each team has a $50%$ % chance of winning any game.</li>
      <li>Let <em>P</em>(<em>i</em>,<em>j</em>) be the probability that if Dodgers needs <em>i</em> games to win, and Yankees needs <em>j</em> games, Dodgers will eventually win the Series.
        <ul>
          <li>i번을 더 이겨야 다저스는 우승할 수 있구 양키스는 세번 이기는데 이 때 다져스기 우승할 확률은
  ?</li>
        </ul>
      </li>
      <li>Ex: $P(2, 3) = \frac {11}{16}$야
        <ul>
          <li>키스는 두번, 다저스는 3번</li>
        </ul>
      </li>
      <li>
        <p>Compute $P(i,j) 0≤i,j≤n ∀n$</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/2.png" alt="2" /></p>

        <ul>
          <li>임의의 n에 대해서 확률을 계산하라 : 그림을 보고, recursion 구조가 떠오르는가?
            <ul>
              <li>문제 사이즈 $( i,j) = (i-1,j) + (i, j-1)$</li>
              <li>0.5, 0.5 : dodgers이거나 yankees인데 dodgers가 이기면 $(i-1,j)$</li>
              <li>조건부 확률 : $P(i,j) = 0.5 P(i-1,j) + 0.5P(i, j-1)$ rl기본적인수식</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/3.png" alt="3" /></p>

<h3 id="4232-worse-a-divide-and-conquer-approach">4.2.3.2. [Worse] A Divide-and-Conquer Approach</h3>

<ul>
  <li>Recursive formulation
    <ul>
      <li>$P(i,j) =1 if i=0,j&gt;0$</li>
      <li>$P(i,j) =0 if i=0,j=0$</li>
      <li>
        <p>$P(i,j)= \frac{P(i-1,j)+P(i,j-1)}{2}=2P(i−1,j)+P(i,j−1)$</p>

        <p>if $i&gt;0, j&gt;0$</p>
      </li>
    </ul>
  </li>
  <li>overlap subproblem : overlapping하지 않으면서 size가 줄었던 dnc와 달리 overlapping된다. 굉장히 안 좋은 상황. 그래서 이를 recursive fn call 함수를 짜서 $P(100,100), P(50,50)$짜보라
    <ul>
      <li>→ 사실 돌려지지도 않는다. 시간이 너무 걸려 컴퓨터가 죽어버린다.</li>
    </ul>
  </li>
  <li>If we solve this recurrence relation in the divide-and-conquer way,
    <ul>
      <li>Let <em>T</em>(<em>n</em>) be the maximum time taken by a call to <em>P</em>(<em>i</em>),where <em>i</em>+<em>j</em> =<em>n</em>.</li>
      <li>Then we can prove that <em>T</em>(<em>n</em>) is exponential!</li>
      <li>$T(1)=1, T(n) = 2T(n-1) + c \rightarrow O(2^n)$</li>
    </ul>
  </li>
  <li>What is the problem of this approach?</li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/4.png" alt="4" /></p>

<h3 id="4323-better-a-dynamic-programming-approach">4.3.2.3. [Better] A Dynamic Programming Approach</h3>

<ul>
  <li>핵심 개념 Table
    <ul>
      <li>1D, 2D, 3D</li>
    </ul>
  </li>
  <li>$T(4,4) $: table setup 후 이를 채워나가서 (fill)
    <ul>
      <li>단ㄷ순하게 생각하면 2 중 for loop 활용하여 진행한다.</li>
      <li>0,0은 양쪽 다 우승한 것이기에 고려할 필요 없다.</li>
    </ul>
  </li>
  <li>한칸 여펴 왼쪽에 있는 애와, 한칸 아래 밑쪽에 잇는 애를 통해 계싼할 수 있다.</li>
  <li>$P(i,j) = 1 $ if $i=0, j&gt;0$</li>
  <li>$P(i,j) = 0$ if $i&gt;0, j=0$</li>
  <li>$P(i,j) = \frac{P(i-1,j) + P(i, j-1)}{2}$ if $i&gt;0, j&gt;0$</li>
  <li>fill 하는 방식
    <ul>
      <li>좌→우 (밑에서 위로): 가능</li>
      <li>밑→위 (좌에서 위로) : 가능</li>
      <li>기존의 플로우는 대각선 우상향이기때문에 가능!</li>
      <li>기교를 부리고 싶으면 ㄹor loop을 복잡하게 해서 구현할 순 있다.
        <ul>
          <li>그러나 단순하면서 잘 작동하는것이 더 중요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$T(n,n) = O(n^2)$d임을 바로 확인해야한다.
    <ul>
      <li>table 원소가 가로 n, 세로 n일 때</li>
      <li>n+1, n+1개가 있고</li>
      <li>상수시간이므로 시간 복잡도는 n자승이 된다. → 시간복잡도는</li>
    </ul>
  </li>
  <li>Instead of computing the same repeatedly, fill in a table as suggested below:
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/5.png" alt="5" /></p>
      </li>
    </ul>
  </li>
  <li>Time Complexity
    <ul>
      <li>For input size $(m, n)$, computing $P(m, n)$ takes $O(mn)$-time.</li>
      <li>
        <p>By far better than the Divide-and-Conquer approach.</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/6.png" alt="6" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>undefined
<img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/7.png" alt="7" /></p>

<ul>
  <li>DP 문제를 푸는데 이러한 recursive structure가 존재하고, 이를 divide and conquer 로 top down으로 풀어야 한다면 overlapping subproblem의 문제가발생한다.
    <ul>
      <li>상당한 양의 문제가 있다 : divide and conquer로 가지 말고 dp로 가는건 어떨까?</li>
      <li>어떤 문제를 subproblem을 통해 recursive하게 풀려 하는데 문제가 어떻게 풀리더라: dnc가 아니라 bottom up 방식으로 풀도록 생각하고</li>
      <li>table을 1차-3ㅏ차원으로 구성하고, 초기화하고, 일반화된 공식으로부터 fill 하느 방식을 알아 원소를 채워 나간다</li>
    </ul>
  </li>
  <li>각각의 subproblem
    <ul>
      <li>문제를 각각 한 번씩만 푼다 : bottom up 방식으로 table을 채워나가서 목적을 달성하는 것 : DP의 시작과 끝이다</li>
      <li>overlapping substructure 등 복잡한 거 생각할 필요 없이, 이것이 전부!</li>
    </ul>
  </li>
</ul>

<h1 id="alg-43-concepts-of-dynamic-programming-1">[ALG] 4.3. Concepts of Dynamic Programming (1)</h1>

<h1 id="dynamic-programming">Dynamic Programming</h1>

<blockquote>
  <p>Top-down → Bottom-up</p>
</blockquote>

<ul>
  <li>When the <strong>divide-and-conquer</strong> approach produces an <strong>exponential algorithm</strong> where <strong>the same sub-problems are solved iteratively</strong>,
    <ul>
      <li>Take the recursive relation from the divide-and-conquer algorithm, and</li>
      <li>replace <strong>the recursive calls with table lookups</strong> by recording a value in a table entry instead of returning it.</li>
    </ul>
  </li>
  <li>master theorem과도 연계
    <ul>
      <li>overlapping 나쁜거 (a&gt;c)</li>
    </ul>
  </li>
  <li>Three elements to consider in designing a dynamic programming algorithm
    <ul>
      <li>Recursive relation
        <ul>
          <li>Optimal substructure</li>
        </ul>
      </li>
      <li>Table setup</li>
      <li>Table fill order</li>
      <li>$B(i,j)=B(i-1,j-1) + B(i-1,j)$ if $0&lt;j&lt;i$</li>
      <li>$B(i,j)=1$ if $j=0$ or $j=i$</li>
    </ul>
  </li>
  <li>[Neapolitan] DP Procedure
    <ul>
      <li>input case에 대해 solution을 계산하는 recursive property 세우기</li>
      <li>작은 input case부터 먼저 해결하는 bottom up을 통한 전체 Input에 대해 Solution 구축</li>
    </ul>
  </li>
</ul>

<h1 id="application-of-dp">Application of DP</h1>

<h1 id="431-the-manhattan-tourist-problem">4.3.1. The Manhattan Tourist Problem</h1>

<ul>
  <li>
    <p>Courtesy of [Jones &amp; Pevzner 6.3]</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Problem:</p>
    <ul>
      <li>Given two street corners in the borough of Manhattan in New York City, find the path between them with the maximum number of attractions, that is, a path of maximum overall weight.</li>
      <li>Assume that a tourist may <u>**move either to east or to south only**</u></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>🏝️ 어떻게 하면 많은 관광지를을 최대로 방문할 수 있겠는가?</p>
</blockquote>

<ul>
  <li>(1) A <u>brute force</u> approach
    <ul>
      <li>모든 경로 다 따져보기 : 몇개 나올까? 각각 n, m칸이라고 할때(세로, 가로)
        <ul>
          <li>이를 따져보면 : $2^n, 2^m, n!, m!$이 나온다 → 모든 경우를 따지면 exponential, factorial time이 나오기에 풀 수 없다.</li>
        </ul>
      </li>
      <li>Search among all paths in the grid for the longest path!</li>
      <li>n이 조금 커도 알 수 있다.</li>
    </ul>
  </li>
  <li>(2) A greedy approach
    <ul>
      <li>다음 강의 주제</li>
    </ul>
  </li>
  <li><u>A formal description of this problem</u>
    <ul>
      <li>Given a weighted graph (grid) <em>G</em> of size (<em>n</em>,<em>m</em>) with two distinguished vertices, a source (0,0) and a sink (<em>n</em>,<em>m</em>), <u>**find a longest path between them**</u> in its weighted graph. (0,0)
        <ul>
          <li>find ‘a’ : 하나만 찾기</li>
        </ul>
      </li>
      <li>graph : vertex-vertex 간 관계를 나타내주는 edge로 edge는 directional/nondirectional일 수 있다
        <ul>
          <li>undirected / directed edge : arc
            <ul>
              <li>directed graph : digraph</li>
              <li>edge에 방향성이 있는가 없는가는 vertex 관계를 나타낸다.</li>
              <li>directed : ex. a는 b를 좋아하고, b는 c를 좋아하고,, : 방향성 존재</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>weighted : 각 edge에 값이 잇는경우</li>
      <li>→ weighted digraph</li>
    </ul>
  </li>
  <li>
    <p>원래 문제에 대해서 두 개의 subproblem 으로 푸는 것</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/9.png" alt="9" /></p>
  </li>
  <li>경로는 달라도 길이는 같은 longest path는 존재할 수 있다.
    <ul>
      <li>둘중에 하나로 출발하거나 도착함
        <ul>
          <li>1) 아래로 출발하거나</li>
          <li>2) 오른쪽으로 출발하거나</li>
        </ul>
      </li>
      <li>알고리즘을 어떻게 생각해냈을까에 대하여 접근해보자!</li>
      <li>둘 중에 하나인데, 오른쪽에서 오는 것이 최종 longest path라면
        <ul>
          <li>(4,4) 까지 이르는 방법에는 (4,3) - (3,4)이므로 각각에 대한 ㅣongest path를 구해보면 된다</li>
          <li>→ divide and conquer로 풀이</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>생각의 흐름
    <ul>
      <li>divide and conquer를 썼을 때, overlapping subproblem을 활용햇기에 worse 됨</li>
      <li>recursive top-down 이면 똑같은 식으로 (4,2) 혹은 (3,3)의 형태의 longest path를 찾아야 한다</li>
      <li>→ 심각해지는 overlapping problem</li>
    </ul>
  </li>
  <li>solution : DP (bottom up)
    <ul>
      <li>0,0 에서 4,3 에 이르기까지의 문제를 한 번씩만 풀고 밑에서부터 위로 올라가자.</li>
    </ul>
  </li>
  <li>divide and conquer의 overlapping subproblem으로 상당히 매칭
    <ul>
      <li>top down: overlapping subproblem → 상당히 많이 겹치는 포인트</li>
      <li>bottom up : 서로 서로를 계싼하며 결괏값 산출</li>
    </ul>
  </li>
  <li>An example grid of size (4,4)
    <ul>
      <li>
        <p>GRID : 특수한 형태의 격자처럼 생긴 graph</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/10.png" alt="10" /></p>
      </li>
    </ul>
  </li>
  <li>shortest path가 아닌 longest path 문제
    <ul>
      <li>DP 문제와 어떤 관계가 있을까?</li>
      <li>recursive solution이 보이는가?</li>
    </ul>
  </li>
  <li>A possible selection determined by a greedy approach</li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/11.png" alt="11" /></p>

<ul>
  <li><u>**Basic idea**</u>
    <ul>
      <li>How can you use the solutions of smaller problems to build a solution of a problem?
        <ul>
          <li>

            <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/12.png" alt="12" /></p>
          </li>
        </ul>
      </li>
      <li>$s_{i,j} = \max{s_{i-1,j}+ w_{i,j} , }$</li>
      <li>directed edge = arc</li>
      <li>위에서 i,j로 내려올 때의 weight,</li>
      <li>왼쪽에서 i,j로 올 때의 weight</li>
      <li>A given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
        <ul>
          <li>최적화 문제
            <ul>
              <li>리턴값을 최대로 해 주는 solution을 찾아라,</li>
              <li>solution을 극대화해주는/극소화해주는 solution을 찾아라</li>
            </ul>
          </li>
          <li>최적화가 아니나 DP를 활용
            <ul>
              <li>다저스 문제 : 최적화 문제가 아니지만 DP를 사용함</li>
            </ul>
          </li>
          <li>최적의 solution을 얻기 위해 문제를 풀어감</li>
          <li>→ optimal substructure</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/13.png" alt="13" /></p>

<ul>
  <li>Optimal substructure : $S_{n,m} =?$
    <ol>
      <li>$i,j \geq 1$
        <ul>
          <li>$S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$</li>
        </ul>
      </li>
      <li>$i=0, j=1,2,…,n$
        <ul>
          <li>$S_{0,j} = S_{0,j-1}+W({(0,j-1)},{(0,j)})$</li>
        </ul>
      </li>
      <li>$j=0, i=1,2,…,m$
        <ul>
          <li>$S_{i,0} = S_{i-1,0}+W({(i-1,0)},{(i,0)})$</li>
        </ul>
      </li>
      <li>$i=j=0$
        <ul>
          <li>$S_{0,0} = 0$</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>💡 Induction, Base step에 관한 것들도 정확하게 기술해주어야 함.</p>
</blockquote>

<ul>
  <li>Table setup and fill
    <ul>
      <li>맨 위, 맨 옆 line에서는 unique한 path cost가 나옴</li>
      <li>divide and conquer = top down → 큰 문제부터 작은 문제로 (merge sort : 큰 것을 반으로 반으로 쪼개가며 merge) ↔ DP</li>
      <li>정보의 흐름 : 내 값을 계산하기 위해서 j 인덱스가 작은 것, i 인덱스가 작은 것을 계산해두면 됨</li>
      <li>각각의 Node가 subproblem을 나타낸다.</li>
      <li>어떻게 각각의 원소를 채울 것인가: 한 원소 값을 계산하기 위해서는 나보다 왼쪽에 있는 애와 위쪽에 잇는 애의 값을 알고 있어야 함.</li>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/14.png" alt="14" /></p>
      </li>
    </ul>
  </li>
  <li>Pseudocode
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/15.png" alt="15" /></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">MANHATTANTOURIST</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
		
		
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Given a (<em>n</em>,<em>m</em>) grid, what is the time complexity T(n, m)?
undefined- So far, we have found the <strong>cost of the longest path</strong> from source to each vertex in the grid.</li>
  <li>길이가 34인 longest path는 어떻게 출력할 수 있을까?
    <ul>
      <li>조금만 더 노력하면 longest path 길이 + 대각선 까지의 거리를 출력할 수 있는 정보를 추출해낼수 있음</li>
      <li>알고리즘에서 정보를 더 끄집어 낼 수 있는 부분 :
        <ul>
          <li>$S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$
            <ul>
              <li>둘 중에 큰 것을 선택하는 statement</li>
              <li>왼쩍 것이 더 크다면 → 위에서부터 내려온 것</li>
              <li>오른쪽 것이 더 크다면 → 왼쪽에서 내려온 것</li>
            </ul>
          </li>
          <li>optimal substructure와 연관
            <ul>
              <li>나의 optimal solution은 나보다 작은 subproblem들의 optimal solution을 통해 출력</li>
              <li>거기서로부터 수식이 나타난다:이를 program화하여 각 table 원소를 계산할 때 선택됨에 따라서 각 또 다른 table 하나를 기록해두면 +1, -1 등을 줄줄 쫓아가면 됨</li>
            </ul>
          </li>
          <li>recursion : 굉장히 compact하게 표현해주는 좋은 방식
            <ul>
              <li>물론 overlapping subproblem의 경우 개념을 compact하게 햐해주지만 조심하면서 써야지 안 복잡해짐</li>
            </ul>
          </li>
          <li>최종 것까지 가는 길 : (-1→ 1) + (이전 노드까지의 최단거리)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time complexity
    <ul>
      <li>Input size (m,n)</li>
      <li>Time Complexity : O(mn)
        <ul>
          <li>각 노드마다 계산하는데 걸리는 상수시간</li>
          <li>node의 복잡도가 시간 복잡도</li>
        </ul>
      </li>
      <li>Space Complexity : O(mn)
        <ul>
          <li>50.50으로 divide and conquer하면, 과연 실행의 끝을 볼 수 있을가 모르겠다!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Then, how can you print out the <strong>actual optimal path</strong> from source to sink?
undefined
      <img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/16.png" alt="16" /></li>
</ul>

<h1 id="432-chained-matrix-multiplication">4.3.2. Chained Matrix Multiplication</h1>

<p>[Neapolitan 3.4] dp의 대표적인 문제</p>

<ul>
  <li>In general, to multiply an <em>a</em> x <em>b</em> matrix with a <em>b</em> x <em>c</em> matrix using the standard method, it is necessary to do <em>abc</em> elementary multiplications.
    <ul>
      <li>a<em>b, b</em>c 행렬을 곱하면 a<em>c 행렬이 나오는데 가장 단순하게 연산하면 a</em>b*c만큼의 곱셈이 수행</li>
      <li>matrix multplication
        <ul>
          <li>$A_1 \times A_2 \times … \times A_n$
            <ul>
              <li>1번, 2번 곱셈, … n-1번 곱 : 누구를 제일 마지막에 연산할것인가?</li>
              <li>최소비용으로 곱한 다음 곱하는 데 활용된 비용을 더하면 결과 비용
                <ul>
                  <li>3번 이전 + 3번 이후</li>
                </ul>
              </li>
              <li>이 중에 제일 작은 것을 선택한다.</li>
              <li>matrix multiplication에는 결합법칙 성립 : 어떤 것을 먼저 곱해도 상관 없으나 비용이 달라짐</li>
            </ul>
          </li>
          <li>$A_i = d_{i-1} \times d_i$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/17.png" alt="17" /></p>

<ul>
  <li>Problem
    <ul>
      <li>Determine the minimum number of elementary multiplications, needed to multiply $n$ matrices where $A_i \in R^{d_{i-1} \times d_i}$</li>
      <li>optimal substructure를 통해 최적의 solution을 도출</li>
    </ul>
  </li>
  <li>Examples:  $A_1 (20 \times 2) \cdot A_2 (2 \times 30) \cdot A_3 (30 \times 12) \cdot A_4 (12 \times 8)$해
    <ul>
      <li>행렬의 곱셈에서는 결합법칙이 성립한다
        <ul>
          <li>$(a+b)+c = a+(b+c) $: a+b+c</li>
          <li>binary operation (이진 연산 : 두 피연산자에 대해 연산하면 한 연ㅅ나)</li>
          <li>빼기는 결합법칙 성립 x → 어떤 빼기를 먼저 하느냐에 따라 결과 달라짐</li>
          <li>행렬의 곱셈의 교환법칙 성립 X, 결합법칙은 성립 O</li>
        </ul>
      </li>
      <li>제일 먼저 곱하는 게 몇 번이냐고 생각할 수 있고,</li>
      <li>최소 횟수를 구하는 것이니 minimization problem : 최소 횟수의 곱셈 → 최적화 문제로 대입</li>
      <li>어떤 친구를 제일 먼저 곱할 것인가 생각할 수 있다.</li>
      <li>곱셈을 곱하는 순서 : 곱셈을 순서대로 나열한 것과 동일
        <ul>
          <li>최적의 해 : 곱셈의 개수가 작은 것으로 선택할 것이다.</li>
        </ul>
      </li>
      <li>$A_1: 20 \times 2, A_2: 2 \times 30$</li>
      <li>$A_1(A_2(A_3 A_4)) : 30 \times 12 \times 8 + 2 \times 30 \times 8 + 20 \times 2 \times 8 = 3,680$ multiplications
        <ul>
          <li>3, 2, 1</li>
        </ul>
      </li>
      <li>$(A_1 A_2)(A_3 A_4) : = 8,880$ multiplications</li>
      <li>$A_1((A_2 A_3 )A_4) : = 1,232$ <u>multiplications</u>
        <ul>
          <li>2, 3, 1</li>
        </ul>
      </li>
      <li>$((A_1 A_2)A_3 )A_4 := 10,320$ multiplications</li>
      <li>$(A_1(A_2 A_3 ))A_4 := 3,120$ multiplications</li>
      <li>The order of multiplication is very important!
        <ul>
          <li>$(a \times b) \times c = a \times (b \times c)$</li>
        </ul>
      </li>
      <li>$O((n-1)!)=O(n!)$ : 프로그램 열심히 설계하는 데에는 얼마 안 걸릴지 모르지만 n factorial만큼 기다려야 결과가 나온다
        <ul>
          <li>곱셈을 할 수 있는게 $(n-1)!$의 경우의 수인데 이들을 어떻게 분류해서 exponential보다 무시무시한 factorial을 polynomial time으로 변환하여 어떻게 잘 분리해 판단할것인가?</li>
          <li>분류 방법 : Ex. $A_1 \cdot A_2 \cdot A_3 \cdot A_4 \cdot A_5 \cdot A_6 \cdot A_7$
            <ul>
              <li>(1) 어떤 애를 가장 먼저 나눌 것인가
                <ul>
                  <li></li>
                </ul>
              </li>
              <li>(2) 어떤 애를 가장 나중에 나누어 곱할 것인가
                <ul>
                  <li>최소 곱셈을 하고자 하는데, 만일 제일 마지막에 곱하는 것이라면 앞의 것을 다 곱하고 뒤의 것을 나중에 곱해야 하는데 우리의 목적이 최소 곱셉을 원하는 것이므로 각각의 partition에 대해서 최소 횟수로 곱하게 됨
                    <ul>
                      <li>→ 자연스로운 recursive 사고방식</li>
                    </ul>
                  </li>
                  <li>$(A_1 \cdot A_2 \cdot A_3) \cdot (A_4 \cdot A_5 \cdot A_6 \cdot A_7) = A_{13} \cdot A_{37}$</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/18.png" alt="18" /></p>
  </li>
  <li>Divide and Conquer, Dynamic Programmping
    <ul>
      <li>problem → <u>**recursive structure**</u> → optimal substructure → dynamic programming</li>
      <li>~를 최대로 해 주는 최적화 문제에 많이 쓰이는 DP</li>
      <li>최적의 구조 이런 것들이 있을 경우, 경우에 따라서는 divide and conquer가 유리할 수 있다</li>
      <li>exponential alg이 나오기 때문에 dp를 한 번 써보자.</li>
    </ul>
  </li>
  <li>Divide and Conquer → Top-down</li>
  <li>Dynamic Programming → Bottom-up</li>
  <li>Recursive : 나랑 같이 생겼는데, 나보다 사이즉 작은 문제를 해결한다.
    <ul>
      <li>작은 문제부터 풀 것인가 (Bottom Up), 큰 문제부터 내려올 것인가 (Top Down)</li>
    </ul>
  </li>
  <li>directed graph라고 봤을 때, 최소 횟수로 건너가는 문제
    <ul>
      <li>n에서 1까지의 shortest path 찾는 문제</li>
      <li>분명 shortest path는 존재하는데, 6→ 5,3,2</li>
      <li>$P_n = \min{ P_{n-1}, P_{\frac n 2}, P_{\frac n 3}}+1$
        <ul>
          <li>if $n\%2 ==0$ → $P_{\frac n 2}$</li>
          <li>if $n\%3 ==0$ → $P_{\frac n 3}$</li>
        </ul>
      </li>
      <li>나보다 사이즈 작은 것들의 최적의 solution을 찾느다 : optimal substructure</li>
      <li>문제 사이자 즉은 거부터 값을 계산해본다. 이러한 P_n의 식을 통해서 계산
        <ul>
          <li>n을 k로 대치하여 생각</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/19.png" alt="19" /></p>
  </li>
</ul>

<h1 id="433-dynamic-programming-approach">4.3.3. Dynamic programming approach</h1>

<ul>
  <li>Definition
    <ul>
      <li>$M(i, j)$
        <ul>
          <li>the minimum number of multiplications needed to multiply $A_i$ through $A_j (i \leq j )$</li>
          <li>랑 같이 행렬 i부터 j까지 최소 횟수를 곱할 때, 그 때 필요한 곱셈의 홋수를 M(i,j)로 정의</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Optimal subtructure
    <ul>
      <li>지금까지 본 것이랑 조금 다른 형태의 substructure가 나오더라</li>
      <li>최적화 문제의 경우 dp 느낑인데 그렇지 않을수도 있더라 : 경우의 수를 따지고 recursive한 개념이 들어가는 경우
        <ul>
          <li>i, j가 같으면 곱셈이 필요 없다.</li>
          <li>i&lt;j이면
            <ul>
              <li>i에서 k까지 최소횟수 → $M(i,k) = d_{i-1} \cdot d_k $</li>
              <li>k에서 j까지 최소횟수 → $M(k+1, j) = d_k \cdot d_j$</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>→ $M(1,n) = ?$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/20.png" alt="20" /></p>

<ul>
  <li>Example: $M(2, 7)$
    <ul>
      <li>
        <p>$M(2,7) = \min_{2\leq k \leq 6}{{ M(2,k) + M(k+1,7)+d_1 d_k d_7}}$</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/21.png" alt="21" /></p>
      </li>
      <li>dp : 작은 문제부터 풀어감</li>
      <li>table을 만들어서 동일한 subproblem을 딱 한 번만 푸는 것: table을 어떻게 만들 것인가?</li>
      <li>우리가 필요한 것 : 세로 i, 가로 j → 필요한 subproblem을 다 모아두면, M(i,j)이다. $M(i,j) i\leq j$
        <ul>
          <li>대각선 우하향으로 내려갈수록 작은 문제이다</li>
          <li>table을 어떻게 훑으며 작은 문제에서 큰 문제로 변환할 것인가?</li>
          <li>optimal substructure의 구조가 어떻게 table을 쫓아갈 것인가 고민해보는 문제</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>M(2,7)
    <ul>
      <li>가로로 시작하면 안 됨 : 가로의 M(2,2,) M(2,3) .. 은 다 되지만 세로의 것들은 한번에 못 채우기 때문</li>
      <li>세로로 시작하면 될까? : 세로로 순서대로 이 식을 활용해 계싼할 것인데 왼쪽의 것들과 밑의 쪽의 것들이 계산될 것 같다.</li>
    </ul>
  </li>
  <li>
    <p>Table fill order</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/22.png" alt="22" /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">g</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">g</span><span class="o">++</span><span class="p">){</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">g</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                          <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">g</span><span class="p">;</span>
                          <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">BIG_NUM</span><span class="p">;</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
          		        <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
              				        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                      				<span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                          <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Time complexity
    <ul>
      <li>$n + (n-1) \cdot 1 + (n-2) \cdot 2 + … + (n-(n-1))\cdot (n-1)n+(n−1)⋅1+(n−2)⋅2+…+(n−(n−1))⋅(n−1)\= n + \Sigma_{g=1}^{n-1}{(n-g)g} \= O(n^3)$
undefined- Chained matrix multiplication problem</li>
      <li>$O(n^3)$ by Godbole (1973)</li>
      <li>$O(n^2)$ by Yao (1972)</li>
      <li>$O(n \log n)$ by Hu and Shing (1982, 1984)</li>
    </ul>
  </li>
  <li>Printing optimal order
    <ul>
      <li>$M(2,7) = \min_{2\leq k \leq 6}{{ M(2,k) + M(k+1,7)+d_1 d_k d_7}}$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">order</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">A_</span> <span class="o">%</span> <span class="n">d</span><span class="err">”</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="k">else</span>
      <span class="p">{</span>
          <span class="n">k</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"("</span><span class="p">);</span>
          <span class="n">order</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
          <span class="n">order</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">")"</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/23.png" alt="23" /></p>
  </li>
</ul>

<p>→ $O(n)$ time</p>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/24.png" alt="24" /></p>

<h1 id="alg-44-principles-of-dynamic-programming-1">[ALG] 4.4. Principles of Dynamic Programming (1)</h1>

<h1 id="44-principles-of-dynamic-programming">4.4. Principles of Dynamic Programming</h1>

<ul>
  <li>$C_{ij}$ = the cost of the shortest path from (0,0) to (<em>i</em>,<em>j</em>)
    <ul>
      <li>각 directed edge에서 shortest path를 찾아라</li>
      <li>
        <p>Then $C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$rkr</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/25.png" alt="25" /></p>
      </li>
    </ul>
  </li>
  <li>Recursive formulation</li>
  <li>Optimal substructure
    <ul>
      <li>나의 최적의 해를 구하기 위해서 나보다 크기가 작은 subproblem들의 optimal solution을 통해서 최적의 해를 구하는 과정을 가능케해주는 구조</li>
    </ul>
  </li>
  <li>Overlapping subproblems
    <ul>
      <li>굉장히 안 좋은 형태로 풀이될수 있음(무한 loop)</li>
      <li>subproblem의 개수는 각 node만큼 있으니가</li>
    </ul>
  </li>
  <li>Bottom-up approach
    <ul>
      <li>작은 문제부터 풀자</li>
    </ul>
  </li>
  <li>Table Fill-up
    <ul>
      <li>각 node에 대한 최단 거리를 table에 계산해두고 기록되어 있는 것들에 대해 채워가며 수행하자</li>
    </ul>
  </li>
</ul>

<h2 id="441-optimal-substructurewiki">4.4.1. Optimal Substructure <a href="https://en.wikipedia.org/wiki/Optimal_substructure">(wiki)</a></h2>

<p>쭉 읽고 아는척 해봐자 !! (dynamic programming)</p>

<ul>
  <li>문제에 대해서 DP를 적용하기 위해서는 optimal substructure를 찾아내야 한다
    <ul>
      <li>나의 optimal solution을 찾는 구조 : recursion이 들어가 있음</li>
      <li>recursion을 divide and conquer로 top-down으로 하던가, bottom-up으로 올라가던가</li>
    </ul>
  </li>
  <li>Dynamic programming algorithms are often <strong>used for optimization</strong>.
    <ul>
      <li>~를 최대로 해 주는 optimal problem을 푸는 데에 주로 쓰인다</li>
    </ul>
  </li>
  <li>A problem is said to have <strong>optimal substructure</strong>
    <ul>
      <li>if a solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.</li>
    </ul>
  </li>
  <li>Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.
    <ul>
      <li>Such optimal substructures are <strong>usually described by means of recursion</strong>.</li>
      <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
    </ul>
  </li>
</ul>

<h2 id="442-overlapping-subproblemswiki">4.4.2. Overlapping Subproblems <a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">(wiki)</a></h2>

<blockquote>
  <p>💡 큰 문제를 푸는데, recursive하게 작은 문제를 계속해서 top down식으로 풀 때 같은 식으로 반복적으로 나오는 경우 : overlapping problem 문제가 심각할 때</p>
</blockquote>

<ul>
  <li>To solve a problem, we often need to <strong>solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution</strong>.</li>
  <li>A problem is said to have <u>**overlapping subproblems**</u> if
    <ul>
      <li>the problem can be broken down into subproblems which are reused several times or</li>
      <li>a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.</li>
      <li>한 번만 풀고 이를 table에 집어넣어 점차 size를 키워 문제 원래 것을 푸는 방식</li>
      <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
    </ul>
  </li>
  <li>The dynamic programming approach seeks to <strong>solve each subproblem only once</strong>, thus reducing the number of computations:
    <ul>
      <li>(i) once the solution to a given subproblem has been computed, it is stored or “<strong>memoized</strong>”:</li>
      <li>(ii) the next time the same solution is needed, it is simply <strong>looked up</strong>.</li>
    </ul>
  </li>
  <li>This approach is <strong>especially useful when the number of repeating subproblems grows exponentially</strong> as a function of the size of the input.</li>
  <li><strong>If a problem can be solved by combining optimal solutions to non-overlapping sub-problems</strong>, the strategy is called “divide-and- conquer” instead. This is why merge sort and quick sort are not classified as dynamic programming problems.
    <ul>
      <li>overlapping subproblem이 거의 발생하지 않음 : merge sort, selection
        <ul>
          <li>merge sort : 큰 문제를 반으로 반으로 나누고 해당 subproblem들이 overlap되지 않음</li>
          <li>selection : 큰 부분들에 대해서 부분을 선택하고 한 부분은 다른 것과 겹치지 않음</li>
          <li>quick sort : pivot을 제외한 나머지 부분들은 overlap하지 않음
            <ul>
              <li>굳이 DP로도 갈 필요 없이 divide and conquer로 쉬이 풀리게 됨</li>
              <li>이분법적 사고 지양 :
                <ul>
                  <li><u>위에서 아래로 내려가는데 subproblem이 반복적으로 나타나는 경우 exponentially 한 시간 복잡도가 걸릴 수 있기에 이럴 때는 dp를 써라</u></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
</ul>

<h2 id="443-the-checkerboard-problem">4.4.3. The Checkerboard Problem</h2>

<p>[Courtesy of Wikipedia]</p>

<ul>
  <li>체스판</li>
  <li>Restrictions
    <ul>
      <li>A checker can start at any square on the first row (i= 1).</li>
      <li>It can move only diagonally left forward, diagonally right forward, or straight forward.
        <ul>
          <li>내려가는 방법 제한 : 남서쪽으로만 내려가던가, 남쪽으로 내려가던가, 남동쪽으로 내려가던가</li>
        </ul>
      </li>
      <li>It must pay the cost <em>c</em>[i] when visiting the (i, j)-position.</li>
    </ul>
  </li>
  <li>
    <p>Cost table $c [i] [j]$</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/26.png" alt="26" /></p>
  </li>
  <li>Problem
    <ul>
      <li>Given a checkerboard with $n \times n$ squares, and a cost function <code class="language-plaintext highlighter-rouge">c[i][j]</code>, <strong>find the minimum-cost path from the first row to the last row</strong>.</li>
      <li>내가 어떤 지점을 방문했을 때에는 화살표가 지나간 cost를 summation한 것
        <ul>
          <li>가장 길이가 짧은 적은 비용의 path 찾는것이 목표</li>
        </ul>
      </li>
      <li>recursive 구조, optimal substructure을 찾아보자
        <ul>
          <li>가장 작게 해주는 minimization problem</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Ex. 1 까지의 최소비용 [4][4]
    <ul>
      <li>최소 비용의 path는 셋 중 하나 : 남쪽으로 오거나, 남서쪽에서 오거나, 남동쪽에서 오거나</li>
      <li>내가 최소 비용을 찾고자 하는 것이니 각각에 이르기까지의 최소 비용 path의 총 비용의 계산
        <ul>
          <li>각각 상황에 대한 총 비용을 안다면, ㅐptimal substructure로 어떻게 나타낼까?</li>
          <li>minimum cost path에 대한 총 비용은 올 수 있는건 세 가지 경로인데 가장 작은 것에다가 이를 선택해서</li>
          <li>나를 방문할 때 1을 더하면 되더라</li>
        </ul>
      </li>
      <li></li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>$q(i,j) = \min { q(i-1, j-1), q(i-1,j), q(i-1, j+1)} + c(i,j)$
        <ul>
          <li>$c(i,j)$ :</li>
          <li>table size는 어떻게 할 것인가 : 각 subproblem마다 원소에 대응되게 table을 잡으면 됨</li>
          <li>총 비용에 해당하는 q(i,j) : (i,j) 까지 위치 까지의 총 비용 계산
            <ul>
              <li>min (남쪽으로 내려오는, 남동쪽, 남서쪽)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>$q(i,j) = c(i,j)$
        <ul>
          <li>i=1일 때 : 자기 자신 - 맨 윗줄
            <ul>
              <li>그 지점까지 오는 최소 비용은 자기 자신 cost만 지불하면 됨</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>dummy
        <ul>
          <li>수학적으로 무한대 값을 설정해 둠</li>
          <li>이런식으로 설정하고 programming하면 각 끝에 값들에 선택되지 않음</li>
          <li>사실 수학적으로 쓸 때 필요는 없지만, dummy값을 넣어주는 게 편리
            <ul>
              <li>boundary 체크해도 상관은 없지만 각 왼쪽, 오른쪽 끝에서 boundary로부터 오는 값들을 계산하기 곤란함</li>
            </ul>
          </li>
          <li>각 cost table 위치마다 subproblem이 하나 생성됨</li>
        </ul>
      </li>
      <li>table setup &amp; table fill
        <ul>
          <li>어떤식으로 loop을 돌면서 할까</li>
        </ul>
      </li>
      <li>(if) 수직으로 for loop를 돌겠다고 하면
        <ul>
          <li>남동, 남서로 내려오는 것들에 대해서는 고려하지 못하므로 안됨</li>
        </ul>
      </li>
      <li>(if) 수평으로 for loop를 돌겠다고 하면
        <ul>
          <li>특정 원소를 계산하고자 할 때, 나에게 필요한 정보가 미리 준비되어 있음</li>
          <li>q table이 계산되더라</li>
        </ul>
      </li>
      <li>q table이 계산된 후 할일 : 아무데서나 시작해도 상관없으니 위에서 내려와서 최소비용으로 가게하자
        <ul>
          <li>아무데서나 시작해서 가는 minimum cost path</li>
          <li>→ 8</li>
        </ul>
      </li>
      <li>q table을 계싼함과 동시에 p table 계산
        <ul>
          <li>어느 방향에서 왔는지
            <ul>
              <li>가장 작은 것을 선택하는 경우</li>
            </ul>
          </li>
          <li>-1 : 북서에서 내려온거다 / 0 : 북에서 내려온거다 / 1 : 북동에서 내려온거다</li>
        </ul>
      </li>
      <li>optimal substructure를 찾은 다음 table을 setup하고 base step 정보를 가지고 initialize하고 table을 적당한 순서로 정리한 다음 적정한 최단 optimal path를 찾는다.</li>
      <li>이후 table fill을 할 때 table을 하나 잡아서 어떤 node를 선택해서 내려왔음을 표기함 (p table)</li>
      <li>→ shortest path를 알게 된다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/27.png" alt="27" /></p>

    <ul>
      <li>나보다 사이즈가 작은 최적의 솔루션들로 표현하는 것</li>
      <li>code
        <ul>
          <li>c/c++는 recursion이 좋은 tool이지만 보편적으로 굉장히 개념을 compact하게 잘 표현해준다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#define N 5
</span>  <span class="cp">#define INFTY 100000
</span>  <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	
  <span class="kt">int</span> <span class="nf">min3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="nf">ComputeCBCosts</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFTY</span><span class="p">;</span>
          <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFTY</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                      <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
              <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">else</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">PrintShortestPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">imin</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">" (%d, %d) &lt;-"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">" (%d, %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imin</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
      <span class="k">else</span>
          <span class="n">PrintShortestPath</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imin</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">ComputeCBShortestPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
      <span class="n">ComputeCBCosts</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="n">imin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">imin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"*** The cost of the shortest path is %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
      <span class="n">PrintShortestPath</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
      <span class="n">ComputeCBShortestPath</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[divide and conquer: top - down 효율적이기도 하나 매우 비효율적이 되기도 함 splitted된 사례들이 서로 관련 없는 문제를 풀때 잘 통함 dynamic programming : bottom -up 아래에서 위로 올라가며 효율을 추구하자는 방식 NOW Divide-and-Conquer Method Dynamic Programming Method Greedy Method Backtracking Method Local Search Method Branch-and-Bound Method Etc. From Wikipedia: Dynamic programming is both a mathematical optimization method and a computer programming method. A complicated problem is broken down into simpler sub-problems in a recursive manner. Overlapping subproblems A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems. Optimal substructure A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems. When applicable, the method **takes far less time than other methods** that don’t take advantage of the subproblem overlap like the divide- and-conquer technique.]]></summary></entry><entry><title type="html">[ALG] 3.2. Selection Algorithm</title><link href="http://localhost:4000/ALG-3.2.-Selection-Algorithm" rel="alternate" type="text/html" title="[ALG] 3.2. Selection Algorithm" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-09-26T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.2.-Selection-Algorithm</id><content type="html" xml:base="http://localhost:4000/ALG-3.2.-Selection-Algorithm"><![CDATA[<h1 id="1-selection-of-both-maximum-and-minimum-elements">1. Selection of Both Maximum and Minimum Elements</h1>

<ul>
  <li><strong>Problem</strong>
    <ul>
      <li>Find both the maximum and the minimum elements of a set containing n elements (assume $n = 2m$ for some integer $m$).</li>
    </ul>
  </li>
  <li>
    <p>[Aho 2.6]</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">begin</span>
      <span class="n">MAX</span> <span class="o">&lt;-</span> <span class="n">any</span> <span class="n">element</span> <span class="n">in</span> <span class="n">S</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">all</span> <span class="n">other</span> <span class="n">elements</span> <span class="n">x</span> <span class="n">in</span> <span class="n">S</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">MAX</span> <span class="n">then</span> <span class="n">MAX</span><span class="o">&lt;-</span> <span class="n">x</span>
    <span class="n">end</span>
</code></pre></div>    </div>

    <ul>
      <li>$T(n) = (n-1) + (n-2) = 2n-3$ comparisons</li>
    </ul>

    <p>$T(n) = 2T(n/2) + 2$ for $n &gt; 2$, $T(n) = 1$ for $n=2$</p>

    <p>$→ T(n) = (3/2)n - 2$ comparisons</p>

    <ul>
      <li>This is the minimum!</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">MAXMIN</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span>
	<span class="k">if</span> <span class="o">|</span><span class="n">S</span><span class="o">|</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">then</span>	
		<span class="n">begin</span>	
			<span class="n">let</span> <span class="n">S</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">};</span>	
			<span class="k">return</span> <span class="p">(</span><span class="n">MAX</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span> <span class="n">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>	
		<span class="n">end</span>
	<span class="k">else</span>	
		<span class="n">begin</span>	
			<span class="n">divide</span> <span class="n">S</span> <span class="n">into</span> <span class="n">two</span> <span class="n">subset</span> <span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span> <span class="n">each</span> <span class="n">with</span> <span class="n">the</span> <span class="n">half</span> <span class="n">of</span> <span class="nf">elements</span>	
			<span class="p">(</span><span class="n">max1</span><span class="p">,</span> <span class="n">min1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">MAXMIN</span><span class="p">(</span><span class="n">S1</span><span class="p">);</span>	<span class="p">(</span><span class="n">max2</span><span class="p">,</span> <span class="n">min2</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">MAXMIN</span><span class="p">(</span><span class="n">S2</span><span class="p">);</span>	
			<span class="k">return</span><span class="p">(</span><span class="n">MAX</span><span class="p">(</span><span class="n">max1</span><span class="p">,</span> <span class="n">max2</span><span class="p">),</span> <span class="n">MIN</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">min2</span><span class="p">))</span>	
		<span class="n">end</span>
</code></pre></div></div>

<h1 id="2-multiplication-of-two-n-bit-numbers">2. Multiplication of Two n-bit Numbers</h1>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/0.png" alt="0" /></p>

<ul>
  <li>The traditional method requires $O(n^2)$ bit operations.</li>
  <li>A divide-and-conquer approach</li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/1.png" alt="1" /></p>

<ul>
  <li>$n=2m$
    <ul>
      <li>$xy = (a2^{\frac n 2} + b)(c2^{\frac n 2} + d) = ac2^n + (ad+bc)2^\frac n 2 + bd$</li>
      <li>divide하면 여기까지는 자연스럽게 감</li>
    </ul>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u = (a+b)*(c+d);
  v = a*c, w = b*d;
  z = v * pow(2,n) + (u-v-w) * pow(2, n/2) + w;
</code></pre></div>    </div>
  </li>
  <li>[Aho 2.6]
    <ul>
      <li>$T(n) = 1$ for $n=1$</li>
      <li>$T(n) = 3T( \frac n 2) + cnT(n)=3T(\frac n 2)+cn$for $n&gt;1 → T(n)=O(n\log3)$</li>
      <li>$O(n^2) → O(n^{1.59})$</li>
    </ul>
  </li>
  <li>Read [Neapolitan 2.6].</li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/2.png" alt="2" /></p>

<h1 id="alg-322-selection-of-the-k-th-smallest-element-1">[ALG] 3.2.2. Selection of the k-th Smallest Element (1)</h1>

<h1 id="selection-of-the-k-th-smallest-element">Selection of the k-th Smallest Element</h1>

<ul>
  <li><em>ref</em>. [A. Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974. 3.6]</li>
  <li>Problem
    <ul>
      <li>Given a <u>sequence of</u> <u>_S_</u> of <em>n</em> elements and an integer $k (1 &lt;= k &lt;= n)$, find the $k^{th}$ smallest element of <em>S</em>.</li>
    </ul>
  </li>
</ul>

<p>당장 해결하라고 하면 어떻게 해결하려고 할까?</p>

<ul>
  <li><strong>Solution 1:</strong>
    <ul>
      <li>Choose the smallest element repeatedly k times.
  반복적으로 1, 2, … k번째로 작은 수를 찾는다.
        <ul>
          <li>효율성을 떠나서 가장 빠르게 생각나는 풀이 방법</li>
          <li>$C = c(n-1)+c(n-2)+c(n-3)+…+c(n-k) = c \cdot k \cdot n - c \cdot \frac {k(k+1)} 2$
            <ul>
              <li>1번째 작은것 뽑는 시간, 2번째, …, k번째 작은 것 뽑는 시간의 합 → Linear Time Algorithm</li>
              <li>$O(n) ?$ : 아님
                <ul>
                  <li>input size : n, k</li>
                  <li>k : 어떤 값이느냐에 따라서 천차만별인 time complexity
                    <ul>
                      <li>k = 1 → linear time (n-1번 비교)</li>
                      <li>n = 100, k = 100</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>if $k= \frac n 2$ then $C = c \cdot \frac {n^2} 2 - c \cdot \frac {n^2 + 2n} 8 = O(n^2)$
            <ul>
              <li>시간 복잡도가 k=1에서 n까지 가는데 $O(c) \rightarrow O(n) \rightarrow O(n^2)$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/3.png" alt="3" /></p>

<ul>
  <li><strong>Solution 2:</strong>
    <ul>
      <li>Build a min-heap, and then extract the smallest element repeatedly <em>k</em> times.
        <ul>
          <li>임의의 데이터 n개의 sequence로부터 min(max) heap을 구성할 때 Linear Time 소요</li>
          <li>$C = c \cdot n + d \cdot k \cdot log n $</li>
          <li>if $k= \frac n 2$ then $C = c \cdot n + d \cdot \frac n 2 \cdot \log n = O(n \log n)$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/4.png" alt="4" /></p>

<ul>
  <li><strong>Can we design an</strong> $O(n)$<strong>-time algorithm?</strong></li>
</ul>

<p>어떻게 linear time algorithm을 만들기 위해서 노력했을까?</p>

<ul>
  <li>생각의 흐름에 따른 추적</li>
</ul>

<h1 id="1-observation">1. Observation</h1>

<p>divide and conquer : 지금까지 배운 것</p>

<ul>
  <li>At least $O(n)$ time is necessary.</li>
  <li>If we use a divide-and-conquer scheme like the merge sort,</li>
  <li>$T(n) = 2T(\frac n 2) + cn =&gt; O( n\log n)$
    <ul>
      <li>n개 짜리의 문제를 2개로 나누고 linear time의 bound가 되는 그런 상황</li>
      <li>n개 짜리 문제가 $\frac n 2$개 두 개로 나누어지고 이것이 또 $\frac n 4$로 나누어짐</li>
      <li>두 개를 쪼개서, 알아서 conquer해서 찾아와라</li>
      <li>→ level마다 $cn$ 개의 stage, binary tree의 height $cn \cdot \log n$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/5.png" alt="5" /></p>

<ul>
  <li>What about $T(n) = 3T(\frac n 3) + cn$?
    <ul>
      <li>$n \rightarrow \frac n 3+\frac n 3+\frac n 3$</li>
      <li>subproblem들의 합</li>
    </ul>
  </li>
  <li>What about $T(n) = 100T(\frac n {100}) + cn$?
    <ul>
      <li>$n \rightarrow \frac n {100} \cdot  100$</li>
      <li>subproblem들의 합</li>
    </ul>
  </li>
  <li>$T(n) = T(0.4n) + T(0.6n) + cn \rightarrow T(n) = O (n \log n)$
    <ul>
      <li>subproblem 합이 원래 문제</li>
      <li>cn이 linear time일 때 총 시간복잡도는 $O (n \log n)$</li>
    </ul>
  </li>
  <li>$T(n) = T(0.39n) + T(0.6n) + cn \rightarrow T(n) = O (n)$
    <ul>
      <li>$n &gt; (0.39 + 0.6)n$</li>
      <li>$n = 2^{20} = 1048576$ 의 경우 유의미한 차이가 존재함</li>
    </ul>
  </li>
  <li>Can we design an O(n)-time algorithm for this selection problem?
    <ul>
      <li>
        <p>What about $T(n) = T(an) + T(bn) + cn$ with $a + b &lt; 1$?</p>

        <p>n개짜리 문제를 두 개로 푸는데</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 그 때 subproblem의 합이 원래 것보다 작고
  - 나머지 부가비용은 $cn$
</code></pre></div>        </div>
      </li>
      <li>
        <p>ex. $a = 0.43, b=0.37 \rightarrow?$ㅉ
undefined	- Pascal’s Triangle</p>
        <ul>
          <li>무한등비수열</li>
        </ul>

        <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/6.png" alt="6" /></p>

        <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/7.png" alt="7" /></p>
      </li>
    </ul>
  </li>
  <li>cost : $cn{1+(a+b)+(a+b)^2+…} \leq cn \frac 1 {1-a+b}$
    <ul>
      <li>so $O(n)$</li>
    </ul>
  </li>
</ul>

<h1 id="2-algorithm">2. Algorithm</h1>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Step 1: Divide S into $\lfloor \frac {</td>
          <td>S</td>
          <td>} 5 \rfloor$ sequence of 5 elements each with up to four leftover elements.</td>
        </tr>
      </tbody>
    </table>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/8.png" alt="8" /></p>

    <ul>
      <li>정렬이 안 된 임의의 데이터들을 5개씩 묶음</li>
    </ul>
  </li>
  <li>Step 2: Sort each 5-element sequence.
    <ul>
      <li>다섯개 묶음까지만 하는것 같은데 나머지 세개에 대해서는 어떻게 할까?
        <ul>
          <li>ex. T(43) : 43개가 쭉 있는데 거기에 두 개 집어넣음. 무한대 두개 넣어도 똑같음</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/9.png" alt="9" /></p>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/10.png" alt="10" /></p>
  </li>
  <li>Step 3: Let M be the sequence of medians of the 5-element sets. Then, let m be the median of the elements in <em>M</em>.
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>M</td>
              <td>= \frac n 5$</td>
            </tr>
          </tbody>
        </table>

        <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/11.png" alt="11" /></p>
      </li>
    </ul>
  </li>
  <li>Step 4: Let _S_1,_S_2, and _S_3 be the sequences of elements in S less than, equal to, and greater than m, respectively.
S를 세 부분집합으로 나눈 후 : 작거나 / 같거나 / 크거나
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>If $</td>
              <td>S1</td>
              <td>&gt;= k$, then find the k-th smallest element of S1.</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>else if $(</td>
              <td>S1</td>
              <td>+</td>
              <td>S2</td>
              <td>&gt;= k)$, then m is the $k^{th}$ smallest element of S.</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>else find the $(k –</td>
              <td>S1</td>
              <td>-</td>
              <td>S2</td>
              <td>)^{th}$ smallest element of _S_3.</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/12.png" alt="12" /></p>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/13.png" alt="13" /></p>
  </li>
</ul>

<blockquote>
  <p>💡 - size n인 배열에서 몇 번째로 작은 element인지 찾아라 :</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- size n인 배열에서 몇 번째로 작은 element인지 찾아라 :
	- step 3에서 m집합을 구성한 다음 median을 찾아라
	- $|M| = \frac n 5$ : divide and conquer - 27개보다 더 작은 것을 찾으니까 s1에서 작은 것을 찾으면 됨
- 어떤 m보다 작은 애들 다 구해논 것, 같은 것, 더 큰 것을 구해둔 것
- if) s1 = 100, s2 = 5, s3 = 200일 때
	- 27번째 작은 것을 찾고자 한다면, S1에 존재
	- 103번을 찾고자 한다면, S2에 존재
		- 103 - 100 = 3 →
	- 120번째 작은 것을 찾는다면, S3에 존재
		- 120 - 100 - 5 = 15번째로 작은 원소 선택 - 각 subproblem에서 똑같은 방식으로 풀어보려고 한다. 정말 절실하게 subproblem의 tc가 원래 문제 사이즈 n보다 작게 하려고 하는데, 어떤 문제를 푸는가
- 내가 풀고자 하는 문제와 똑같은 방식으로 풀고자 함
- $T(n) \rightarrow T(\frac n 5)$ : - 왜 $T(\frac 3 4 n)$로 bound가 되는가 생각해보자 : m을 잘 선택해서 → size가 적당
- 앞서 정렬한 다음 가운데 것을 모아서 m을 찾아냄
- m보다 작은 애들, 같은 애들, 큰 애들을 묶음 → m을 잘 선택했기 때문에 S1, S2, S3 각각에 어느 정도 원소가 존재하도록 쪼갠 것
- $T(|S_1|) $ or $T(|S_3|) $
	- $|S_1| \leq \frac 3 4 n$
	- 도대체 어떻게 했길래 각각 작거나 같은 것이 적당히 뽑힌 것인가 : m을 적당히 잘 선택했기에!
</code></pre></div></div>

<h2 id="pseudocode">pseudocode</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">SELECT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="o">:</span>
<span class="k">if</span> <span class="o">|</span><span class="n">S</span><span class="o">|&lt;</span><span class="mi">50</span> <span class="n">then</span>
	<span class="n">begin</span>
		<span class="n">sort</span> <span class="n">S</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">kth</span> <span class="n">smallest</span> <span class="n">element</span> <span class="n">in</span> <span class="n">S</span>
	<span class="n">end</span>
<span class="k">else</span>
	<span class="n">begin</span>
		<span class="n">divide</span> <span class="n">S</span> <span class="n">into</span> <span class="o">|</span><span class="n">S</span><span class="o">|/</span><span class="mi">5</span> <span class="n">sequences</span> <span class="n">of</span> <span class="mi">5</span> <span class="n">elements</span> <span class="n">each</span> <span class="n">with</span> <span class="n">up</span> <span class="n">to</span> <span class="n">four</span> <span class="n">leftover</span> <span class="n">elements</span><span class="p">;</span>
		<span class="n">sort</span> <span class="n">each</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sequence</span><span class="p">;</span>
		<span class="n">let</span> <span class="n">M</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">medians</span> <span class="n">of</span> <span class="n">the</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sets</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">&lt;-</span> <span class="n">SELECt</span> <span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
		<span class="n">let</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="n">and</span> <span class="n">s3</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequences</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">in</span> <span class="n">S</span> <span class="n">less</span> <span class="n">than</span><span class="p">,</span> <span class="n">equal</span> <span class="n">to</span><span class="p">,</span> <span class="n">and</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">m</span><span class="p">,</span> <span class="n">respectively</span><span class="p">;</span>
		<span class="k">if</span> <span class="o">|</span><span class="n">s1</span><span class="o">|&gt;=</span> <span class="n">k</span>
			<span class="n">then</span> <span class="k">return</span> <span class="n">m</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">SELECT</span> <span class="p">(</span><span class="n">k</span><span class="o">-|</span><span class="n">s1</span><span class="o">|-|</span><span class="n">s2</span><span class="o">|</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span>
	<span class="n">end</span>


</code></pre></div></div>

<ul>
  <li>
    <p>Pseudocode Analysis</p>

    <p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/14.png" alt="14" /></p>
  </li>
  <li>
    <p>A divide-and-conquer strategy</p>
  </li>
</ul>

<h2 id="facts">Facts</h2>

<ul>
  <li>(A) At least one-fourth of the elements of S are less than or equal to <em>m</em>.</li>
  <li>(B) At least one-fourth of the elements of S are <u>greater than or equal to</u> <u>_m_</u><u>.</u>
    <ul>
      <li>m보다 같거나 큰 애들</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>S_1</td>
              <td>&lt;= \frac {3n} 4$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$</td>
              <td>S_3</td>
              <td>&lt;= \frac {3n} 4$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>S1: the set of all elements less than m</li>
  <li>S2: the set of all elements equal to m</li>
  <li>S3: the set of all elements greater than m</li>
</ul>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/15.png" alt="15" /></p>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/16.png" alt="16" /></p>

<h1 id="33-time-complexity">3.3. Time Complexity</h1>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Input size $n =</td>
          <td>S</td>
          <td>$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>M</td>
          <td>&lt;= \lceil( \frac n 5)\rceil$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>S_1</td>
          <td>&lt;= \frac {3n} 4$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>S_3</td>
          <td>&lt;= \frac {3n} 4$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>for $n \leq 49$</li>
  <li>7이 아니라 5, 7, 9, 100001</li>
  <li>n보다 더 작아지니까 더 좋을 것 같은데, 이 값이 커지다 보면, 대략 n/100이 된다.
    <ul>
      <li>5개보다는 7개가 더 좋고, … :$n/1001 + 3n/4$«n이면 더 좋으므로</li>
      <li>→ 10001개 짜리를 sorting하는데 과연 이 10001개 sorting하는 시간이 상수 시간이냐 : 그렇게 볼 순 없다.</li>
    </ul>
  </li>
  <li>이 시간이 상수시간이 안 된다.
    <ul>
      <li>n이 어느정도 변해도 변하지 않는, n/100과는 어느정도 큰 것이기 때문에 미묘한 차잉가 있음을 명심하자.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">procedure</span> <span class="n">SELECT</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="o">:</span>
<span class="k">if</span> <span class="o">|</span><span class="n">S</span><span class="o">|&lt;</span><span class="mi">50</span> <span class="n">then</span>
	<span class="n">begin</span>
		<span class="n">sort</span> <span class="n">S</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">kth</span> <span class="n">smallest</span> <span class="n">element</span> <span class="n">in</span> <span class="n">S</span>
	<span class="n">end</span>
<span class="k">else</span>
	<span class="n">begin</span>
		<span class="n">divide</span> <span class="n">S</span> <span class="n">into</span> <span class="o">|</span><span class="n">S</span><span class="o">|/</span><span class="mi">5</span> <span class="n">sequences</span> <span class="n">of</span> <span class="mi">5</span> <span class="n">elements</span> <span class="n">each</span> <span class="n">with</span> <span class="n">up</span> <span class="n">to</span> <span class="n">four</span> <span class="n">leftover</span> <span class="n">elements</span><span class="p">;</span>
		<span class="n">sort</span> <span class="n">each</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sequence</span><span class="p">;</span>
		<span class="n">let</span> <span class="n">M</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">medians</span> <span class="n">of</span> <span class="n">the</span> <span class="mi">5</span><span class="o">-</span><span class="n">element</span> <span class="n">sets</span><span class="p">;</span>
		<span class="n">m</span> <span class="o">&lt;-</span> <span class="n">SELECt</span> <span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
		<span class="n">let</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="n">and</span> <span class="n">s3</span> <span class="n">be</span> <span class="n">the</span> <span class="n">sequences</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">in</span> <span class="n">S</span> <span class="n">less</span> <span class="n">than</span><span class="p">,</span> <span class="n">equal</span> <span class="n">to</span><span class="p">,</span> <span class="n">and</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">m</span><span class="p">,</span> <span class="n">respectively</span><span class="p">;</span>
		<span class="k">if</span> <span class="o">|</span><span class="n">s1</span><span class="o">|&gt;=</span> <span class="n">k</span>
			<span class="n">then</span> <span class="k">return</span> <span class="n">m</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">SELECT</span> <span class="p">(</span><span class="n">k</span><span class="o">-|</span><span class="n">s1</span><span class="o">|-|</span><span class="n">s2</span><span class="o">|</span><span class="p">,</span> <span class="n">s3</span><span class="p">)</span>
	<span class="n">end</span>

</code></pre></div></div>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/17.png" alt="17" /></p>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p><img src="/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/18.png" alt="18" /></p>

<h1 id="alg-323-selection-algorithm-complexity-analysis-1">[ALG] 3.2.3. Selection Algorithm: Complexity Analysis (1)</h1>

<ul>
  <li>Theorem
    <ul>
      <li>$\forall c, d \in \mathbb{R^+}$, if the following recurrence relation holds:</li>
      <li>$T(n) \leq d$ for $n≤49$</li>
      <li>$T(n) \leq T(\frac n 5) + T (\frac {3n} 4) + cn, n \geq 50$</li>
      <li>then $T(n) = O(n)$</li>
    </ul>
  </li>
  <li>Proof
    <ul>
      <li>We want to prove that $T(n) \leq kn$ for some constant $k,∀n≥1$
        <ol>
          <li>Base case
            <ul>
              <li>$T(n) \leq d \leq dn, ∀n≥1$</li>
              <li>Therefore, $T(n)≤kn ∀1≤n≤49 $ if we select k such that $k \geq d$</li>
            </ul>
          </li>
          <li>Inductive step
            <ul>
              <li>assume that $n≥5$ and $T(m) \leq km, \forall m &lt; n$
                <ul>
                  <li>Then, $T(n) \leq T(\frac n 5) + T (\frac {3n} 4) + cn$</li>
                </ul>
              </li>
              <li>$T(n)\leq k \frac n 5 + k \frac {3n} 4+ cn = \frac {19}{20}kn +cn$</li>
              <li>$T(n)= kn + (c-\frac k {20})n \leq kn$
                <ul>
                  <li>if $k \geq 20c$</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
      </li>
      <li>So if we choose <em>k</em> s.t. $k=\max(d,20c), T(n)≤kn$ for all $n≥50.$</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[1. Selection of Both Maximum and Minimum Elements]]></summary></entry><entry><title type="html">[ALG] 3.3. Master Theorem</title><link href="http://localhost:4000/ALG-3.3.-Master-Theorem" rel="alternate" type="text/html" title="[ALG] 3.3. Master Theorem" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-09-26T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.3.-Master-Theorem-</id><content type="html" xml:base="http://localhost:4000/ALG-3.3.-Master-Theorem"><![CDATA[<h1 id="master-theorem-1">Master Theorem 1</h1>

<p>[Neapolitan 2.8]</p>

<ul>
  <li>Let a, b, and c be nonnegative constants.</li>
  <li>The solution to the recurrence $T (1)=1$, and $T(n)=aT(\frac n c)+bn$, for <em>n</em>&gt;1 for <em>n</em> a power of <em>c</em> is
    <ul>
      <li>$T(n)=O(n)$, if $a&lt;c$
        <ul>
          <li>a=3, b=4 → n ⇒ $\frac n 3, \frac n 3$</li>
        </ul>
      </li>
      <li>$T(n)=O(n \log n)$ if $a=c$
        <ul>
          <li></li>
        </ul>
      </li>
      <li>$T(n) = O(n \log_c a)$ if a &gt; c
        <ul>
          <li>$a=4, c=2$면? → $O(n^{\log_2 4})$</li>
          <li>a&gt;c이면 log_c a &gt; 1이게 됨
            <ul>
              <li>$O(n \log n)$ vs $O(n^{1.00000000001})$</li>
              <li>$\lim_{n\rightarrow \infty}{\frac {f(n)}{g(n)}} = \infty, c, 0$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>o(n) &lt; O(n \log n) &lt; O(n \log_c a)</p>

<p>$T(n) = T(\frac n 5) + T(\frac 3 4 n) + bn$</p>

<p>Prove this by induction!</p>

<ul>
  <li>Avoid divided-and-conquer if, for example–
    <ul>
      <li>An instance of size n is divided into two or more instances each almost of size <em>n</em>.</li>
      <li>An instance of size n is divided into almost <em>n</em> instance of size $\frac n c$, where <em>c</em> is a constant.</li>
    </ul>
  </li>
  <li>The divide-and-conquer strategy often leads to efficient algorithms, although not always!</li>
</ul>

<h1 id="master-theorem-2">Master Theorem 2</h1>

<p>212p</p>

<p>Theorem</p>

<p>if $T(n) \leq a \cdot T(\frac n b) + O(n^d) $ for $a \geq 1, b&gt;1$ and $d \geq 0$</p>

<p>→ then</p>

<p>$T(n) = O(n^d \log n) $ if $a = b^d$</p>

<p>$T(n) = O(n^d) $ if $a &lt; b^d$</p>

<p>$T(n) = O(n^d \log n) $ if $a &gt; b^d$</p>

<p>divide and conquer : linear time이라는 보장은 없다.</p>

<p>스스로 한번 이해해보고, 이해가 안 됐을 때 또 다시 생각해보기 (숙제!)</p>

<ul>
  <li>직관적으로, 논리적으로 맞느지 스스로 이해를 해보라,</li>
</ul>

<h1 id="alg-34-miscellaneous-1">[ALG] 3.4. Miscellaneous (1)</h1>

<h1 id="finding-the-closest-pair-of-2d-points">Finding the Closest Pair of 2D Points</h1>

<h2 id="1-내용">1. 내용</h2>

<p><strong>[J. Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005. 5.4]</strong></p>

<ul>
  <li>Problem
    <ul>
      <li>
        <p>Given <em>n</em> points in the plane, find the pair that is closest together.</p>

        <p>n</p>
      </li>
    </ul>
  </li>
  <li>Notation</li>
  <li>Naïve algorithm
    <ul>
      <li>Compute the distance between each pair of points</li>
      <li>take the minimum → $O(n^2)$ time
undefined
        <h2 id="2-applying-the-divide-and-conquer-strategy">2. Applying the Divide-and-Conquer Strategy</h2>
      </li>
    </ul>
  </li>
  <li>[Shamos and Hoey]</li>
  <li>Simple assumption for an easy explanation
    <ul>
      <li>No two points in <em>P</em> have the same _x_coordinate or the same _y_coordinate.</li>
    </ul>
  </li>
  <li>General idea
    <ul>
      <li>[Preprocessing]
        <ul>
          <li>Build a list <em>Px</em> in which all the points in <em>P</em> have been sorted by increasing _x_coordinate→ $O(n \log n)$</li>
          <li>Build another list <em>Py</em> in which all the points in <em>P</em> have been sorted by increasing _y_coordinate→ $O(n \log n)$</li>
        </ul>
      </li>
      <li>[Recursion for <em>P</em> with $∣P∣=n$]
        <ul>
          <li>[Divide] Partition <em>P</em> into two subsets <em>Q</em> and <em>R</em> → <em>O</em>(<em>n</em>)</li>
          <li>[Conquer] Find the closest pairs in <em>Q</em> and <em>R</em>, respectively→ $2T(\frac n 2)$</li>
          <li>[Combine] Use this information to get the closest pair in P→ <em>O</em>(<em>n</em>)</li>
          <li>Time-complexity
            <ul>
              <li>$O(n \log n) + T(n)$ where $T(n) = cn +2T(n/2) → O(n \log n)$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The stage [Divide]: Partition <em>P</em> into two subsets <em>Q</em> and <em>R</em>.
    <ul>
      <li>Create <em>Q</em> and <em>R</em>, where
        <ul>
          <li>Q: the set of points in the first  $\lceil(\frac n 2)\rceil$positions of the list $P_x$ (the “left half”),</li>
          <li>R_R_: the set of points in the final $\lfloor(\frac n 2) \rfloor$positions of the list $P_x$ (the “right half”).</li>
        </ul>
      </li>
      <li>Furthermore, create $Q_x, Q_y, R_x$, and $R_y$, where
        <ul>
          <li>$Q_x$ consisting of the points in <em>Q</em> sorted by increasing _x_coordinate,</li>
          <li>$Q_y$ consisting of the points in <em>Q</em> sorted by increasing _y_coordinate,</li>
          <li>$R_x$ consisting of the points in <em>R</em> sorted by increasing _x_coordinate,</li>
          <li>$R_y$ consisting of the points in <em>R</em> sorted by increasing _y_coordinate.</li>
        </ul>
      </li>
      <li>✓ Can be done in $O(n)$</li>
    </ul>
  </li>
  <li>The stage [Conquer]: Find the closest pairs in <em>Q</em> and <em>R</em>, respectively.
    <ul>
      <li>Recursively determine a closest pair $(q_0, q_1)$ of points in <em>Q</em></li>
      <li>Recursively determine a closest pair $(r_0, r_1)$ of points in <em>R</em>.
        <ul>
          <li>Can be done in $2T(\frac n 2)$.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The stage [Combine]: Use the obtained info. to get the closest pair in <em>P</em>.
    <ul>
      <li>Question : are there points $q \in Q, r \in R$ for which $d(q,r)&lt;\delta$?
        <ul>
          <li>How can we answer this question in linear time?</li>
        </ul>
      </li>
      <li>[Fact 1] (Why?)
        <ul>
          <li>if there $∃q∈Q,r∈R $for which $d(q,r)&lt;\delta$</li>
          <li>then each of <em>q</em>,<em>r</em> lies within a distance $\delta$ of $L$</li>
        </ul>
      </li>
      <li>[Fact 2]
        <ul>
          <li>$∃q∈Q,r∈R$ for which $d(q,r)&lt;\delta⟺ ∃s,s′∈S$ for which $ d(s,s′)&lt;δ$</li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/0.png" alt="0" /></p>
          </li>
          <li>$x^*$: the x-coordinate of the rightmost point in <em>Q</em></li>
          <li>$\delta=min(d(q_0^<em>,q_1^</em>),d(r_0^<em>,r_1^</em>))$</li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/1.png" alt="1" /></p>
          </li>
        </ul>
      </li>
      <li>[Fact 3]
        <ul>
          <li>if $s, s^{‘ } \in S$ have the property that $d(s, s^{‘})&lt;\delta$, then $s, s^{‘}$ re within 15 positions of each other in the sorted list $S_y$
            <ul>
              <li>$S_y$ : the list consisting of the points in <em>S</em> sorted by increasing _y_coordinate.</li>
              <li>Each box contains at most one point of <em>S</em>. (Why?)</li>
              <li>If two points in <em>S</em> are at least 16 positions apart in $S_y$ , …</li>
            </ul>
          </li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/2.png" alt="2" /></p>
          </li>
        </ul>
      </li>
      <li>
        <p>[merge] : <em>O</em>(<em>n</em>)</p>

        <p>O(n)</p>

        <ol>
          <li>For each $s \in S_y$ , compute its distance to each of the next 15 pts in $S_y$</li>
          <li>Let $s, s^{‘}$ be the pair achieving the minimum of these distances</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>Compare $d(s, s^{‘})$ with $δ$</p>

<p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/3.png" alt="3" /></p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[Master Theorem 1]]></summary></entry><entry><title type="html">[ALG] 3.0. Algorithm Design</title><link href="http://localhost:4000/ALG-3.0.-Algorithm-Design" rel="alternate" type="text/html" title="[ALG] 3.0. Algorithm Design" /><published>2022-09-19T00:00:00+09:00</published><updated>2022-09-19T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.0.-Algorithm-Design</id><content type="html" xml:base="http://localhost:4000/ALG-3.0.-Algorithm-Design"><![CDATA[<h1 id="the-divide-and-conquer-approach">The Divide-and-Conquer Approach</h1>

<p>각각을 나누어 conquer해서 정복하다 : 원래 문제를 푸는 것과 같은 방식으로 combine해서 원래 문제의 해를 찾는 문제 해결 방식. 여러가지 부류의 변형이 존재한다.</p>

<ul>
  <li>(1) <strong>Divide</strong> an instance of a problem into one or more smaller instances
    <ul>
      <li>문제의 인스턴스를 하나 이상의 작은 인스턴스로 나눕니다.</li>
    </ul>
  </li>
  <li>(2) <strong>Conquer</strong> (Solve) each of the smaller instances. Unless a smaller instance is sufficiently small, use recursion to do this.
    <ul>
      <li>각 작은 인스턴스를 정복합니다. 작은 인스턴스가 충분히 작지 않으면 재귀적을 사용하여 이 작업을 수행합니다.</li>
    </ul>
  </li>
  <li>(3) If necessary, <strong>combine</strong> the solutions to the smaller instances to obtain the solution to the original instance.
    <ul>
      <li>필요한 경우 작은 인스턴스에 대한 솔루션을 결합하여 원래 인스턴스에 대한 솔루션을 확보합니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design.md/0.png" alt="0" /></p>

<h1 id="recursion">Recursion</h1>

<ul>
  <li>Tower of Hanoi
    <ul>
      <li><a href="https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/">Geeksforgeeks</a></li>
      <li>
        <p>작은거 위에 큰 거 올리지 않는 연산</p>

        <p><img src="/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design.md/1.png" alt="1" /></p>
      </li>
    </ul>
  </li>
  <li>$T(n) = 2T(n-1) +1, n&gt;1$</li>
  <li>$T(1)=1$</li>
  <li>Recursive thinking!
    <ul>
      <li><a href="https://introcs.cs.princeton.edu/java/23recursion/">princeton</a></li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design.md/2.png" alt="2" /></p>

<ul>
  <li>recursion의 묘미 - compact하게 recursion하게 표현
    <ul>
      <li>3개 옮기는 데도 복잡하게 가지만 이를 compact하게 바꾸어주는 작업</li>
    </ul>
  </li>
  <li>전체를 옮기는데 하나를 옮긴다 : n개의 disk를 옮기는 비용
    <ul>
      <li>n개의 비용은 어떻게 될까 : $T(n) = 2 T(n-1) + 1 (n \geq 2)$</li>
      <li>작은 것 두 번 옮기고 마지막 하나 가야하므로 → 정확하게는 $1 (n=1)$</li>
    </ul>

    <p>→ $O(2^n)$</p>
  </li>
  <li>$T(n) = $
    <ul>
      <li>$a_n = 2a_{n-1} +1 (n \geq 2), a_1 = 1$ → $a_n = ?$</li>
    </ul>
  </li>
  <li>recursion을 잘 다루면 매우 효율적으로 되고, 대표적으로 divide and conquer 방법론</li>
</ul>

<h1 id="sorting">Sorting</h1>

<blockquote>
  <p>💡 A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.<br />
Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐</p>

  <p>일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐


일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)
</code></pre></div></div>

<ul>
  <li>Problem:
    <ul>
      <li>Given a list of n items, arrange them <strong>in a certain order.</strong>
        <ul>
          <li>Ex: non-increasing, non-decreasing, or etc. : 크기순서대로 정렬한다</li>
          <li>이론적, 알고리즘적으로 문제 해결하는 측면이 있고, practical하게 하는거랑</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Some criteria for choosing a sorting algorithm
    <ul>
      <li>How many items will you be sorting? 얼마나 많은 원소를 정렬할 것인가?</li>
      <li>Will there be duplicate items in the data? 데이터에 중복 항목이 있습니까?</li>
      <li>What do you know about the data? 데이터에 대해 알고 계십니까?
        <ul>
          <li>Is the data already partially sorted?데이터는 이미 부분적으로 정렬되어 있는가?</li>
          <li>Do you know the distribution of the items?품목의 분포를 알고 있습니까?</li>
          <li>Are the keys of items very long or hard to compare?항목 키가 매우 길거나 비교하기 어렵습니까?
            <ul>
              <li>정수 데이터를 sorting하는 건가, 여러 string을 비교하는것인가에 따라 사용하는 알고리즘이 접근 방식이 달라질 수 있다.</li>
              <li>이에 괘념치 않고 sorting alg를 좋다더니 쓰자 하면 버벅되는 꼴이 일어날 것.</li>
            </ul>
          </li>
          <li>Is the range of possible keys very small? 가능한 키의 범위가 매우 작습니까?</li>
        </ul>
      </li>
      <li>Do you have to worry about disk accesses? 디스크 액세스에 대해 염려해야 합니까?</li>
      <li>Do you need a <u>**stable**</u> sorting algorithm? 안정적인 정렬 알고리즘이 필요한가?
        <ul>
          <li>stable한 알고리즘 15 31 2 7 6 7 9 ⇒ 2 6 7 7 9 15 13</li>
          <li>같은 값이 있을 때 그 순서가 유지 - 같은 7, 7의 순서가 변하지 않음 (stable soritng alg)</li>
        </ul>
      </li>
      <li>How much time do you have to write and debug your routine? 루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?</li>
    </ul>
  </li>
  <li>ref. <a href="https://drive.google.com/drive/u/0/folders/1IyehEF9hz96cFu5js6ZWyfR4_Mvk1xb8">Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005</a>,
    <ul>
      <li>원래 <a href="http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK4/NODE148.HTM">링크</a> 깨짐</li>
    </ul>
  </li>
  <li>정수처럼 4byte 저장되는건지 등 어떤 data를 정렬하느냐에 따라서 sw 개발자로서의 approach가 천차만별 : divide and conquer 이해가 ㅁ목적</li>
  <li>GPU Parallel Sorting</li>
</ul>

<h3 id="a-formal-definition-of-sorting">A Formal Definition of Sorting</h3>

<ul>
  <li>A <strong>partial order</strong> on a set S is a relation R such that for each a, b, and c in S:
    <ul>
      <li>$aRa$ is true (R is reflexive).</li>
      <li>$aRb$ and $bRc$ imply $aRc$ (R is transitive)</li>
      <li>$aRb$ and $bRa$ imply $a=b$ (R is antisymmetric)</li>
    </ul>
  </li>
  <li>A Linear Order or Total Older on a set <em>S</em> is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.</li>
  <li>The sorting problem
    <ul>
      <li>Given a sequence of <em>n</em> elements $a_1, a_2, …, a_n$ drawn from a set having a linear order $\preceq$</li>
      <li>find a permutation $Π=(π_1,π_2,…,π_n) $of $(1,2,…,n)$ that will map the sequence into a nondecreasing sequence $a_{\pi_1}, a_{\pi_2},…,a_{\pi_n}$,  such that $a_{\pi_1} \preceq a_{\pi_i+1}$,  for $1 \leq i &lt; n$</li>
    </ul>
  </li>
  <li>Ex: ≤ on $\mathbb{Z}, \subseteq$ on sets</li>
  <li>Sorting on data with partial order?</li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[The Divide-and-Conquer Approach]]></summary></entry><entry><title type="html">[ALG] 3.1. Sorting</title><link href="http://localhost:4000/ALG-3.1.-Sorting" rel="alternate" type="text/html" title="[ALG] 3.1. Sorting" /><published>2022-09-19T00:00:00+09:00</published><updated>2022-09-19T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.1.-Sorting</id><content type="html" xml:base="http://localhost:4000/ALG-3.1.-Sorting"><![CDATA[<h1 id="alg-311-merge-sort-1">[ALG] 3.1.1. Merge Sort (1)</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>divide and conquer 관점에서 - merge sort를 바라보면, 맨 위 임의로 주어진 배열 data를 아래처럼 정렬한다고 하자. 


divide and conqer가 자연스럽게 들어오면, 이제부터 몇 주가 편하게 갈 것이다.


# 1. Merge Sort

- **Problem**: Sort _n_ keys in nondecreasing sequence.
- **Inputs**: positive integer _n_, array of keys _S_ indexed from 1 to _n_.
- **Outputs**: the array _S_ containing the keys in nondecreasing order. 배열 S는 감소하지 않는 순서로 정렬된 key를 갖는다
	1. **Divide** the array into two subarrays each with $\frac n 2$ items.
		1. 전반부 후반부 한 덩어리씩 나눈다 : 절반으로 나누어서
	2. **Conquer** each subarray by sorting it recursively.
		1. 한 element만 남게 되면 정렬 끝
	3. **Combine** the solutions to the subarrays by merging them into a single sorted array.
		1. merge의 경우 크기 순서대로 되어 있는데 각 부분의 solution을 적절히 combine해서 찾는다
		2. 각 그룹중에 비교해서 더 작은 놈 나와 해서 sublist들을 merge하는 과정. : recursive하게 sort하여 정렬된 list로 merge하여 각 데이터를 총합하는 방식

![0](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/0.png)

- A simple implementation

	```c
	// Sort a list from A[left] to A[right].
	// Should be optimized for higher efficiency!!!
	void merge_sort(item_type *A, int left, int right)
	{
	    int middle;
	    if (left &lt; right)
	    {
	        // divide : O(1)
	        middle = (left + right) / 2;
	
	        // conquer : 2T(n/2) - subprogram들을 같은 방식으로 
					merge_sort(A, left, middle);
	        merge_sort(A, middle + 1, right);
	
	        // combine : O(n)
					merge(A, left, middle, right);
	    }
	}
	
	item_type *buffer;
	// extra space for merge sort, allocated beforehand
	void merge(item_type *A, int left, int middle, int right)
	{
	    int i, i_left, i_right;
	    memcpy(buffer + left, A + left, 
						 sizeof(item_type) * (right - left + 1));
	    // O(r-l+1), O(n)
	    i_left = left;
	    i_right = middle + 1;
	    i = left;
	
	    while ((i_left &lt;= middle) &amp;&amp; (i_right &lt;= right))
	    {
	        if (buffer[i_left] &lt; buffer[i_right])
	            A[i++] = buffer[i_left++];
	        else
	            A[i++] = buffer[i_right++];
	    }
	    while (i_left &lt;= middle)
	        A[i++] = buffer[i_left++];
	    while (i_right &lt;= right)
	        A[i++] = buffer[i_right++];
	}
	```


	![1](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/1.png)


	![2](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/2.png)

- Space Complexity
	- order of n만큼의 working space를 안 쓰고, input array의 n만 써서 활용할 때, 그런 알고리즘의 경우 O(n log n)만큼의 time complexity 이상이 찍힐 수 있겠구나.
	- 가능은 하다 : input array O, Working space X
		- inplace merge sort는 굉장히 복잡한 것으로 알고 있음.
	- 시간 복잡도를 증가시키지 않으면서, working space의 추가적인 memory를 안 쓰는 것 (상수 memory 사용)
	- 
</code></pre></div></div>
<details>
  <summary>In-place merge sort</summary>


[bookmark](https://www.geeksforgeeks.org/in-place-merge-sort/)

- stable을 유지하면서 working space는 linear space만 쓰는 것 → 어떤식으로 생각해서 접근할 것인가? 중요
- merge 할 때 추가적인 working space는 안 쓰고, 자연스럽게 생각할 수 있는 것들 :
	- 자연스러운 생각이 들 수 있게 길들여야만 복잡한 것을 하고 하나하나 자연스럽게 생각하는 습관 들이기
- Maintain two pointers that point to the start of the segments which have to be merged.
- Compare the elements at which the pointers are present.
- If _element1 &lt; element2_ then _element1_ is at right position, simply increase _pointer1_.
- Else shift all the elements between element1 and _element2(including element1 but excluding element2)_ right by 1 and then place the element2 in the previous place_(i.e. before shifting right)_ of element1. Increment all the pointers by _1_.

![3](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/3.png)

<details>
  <summary>C++ Code </summary>


```c
// C++ program in-place Merge Sort
#include <iostream>
using namespace std;

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
// Inplace Implementation
void merge(int arr[], int start, int mid, int end)
{
	int start2 = mid + 1;

	// If the direct merge is already sorted
	if (arr[mid] &lt;= arr[start2]) {
		return;
	}

	// Two pointers to maintain start
	// of both arrays to merge
	while (start &lt;= mid &amp;&amp; start2 &lt;= end) {

		// If element 1 is in right place
		if (arr[start] &lt;= arr[start2]) {
			start++;
		}
		else {
			int value = arr[start2];
			int index = start2;

			// Shift all the elements between element 1
			// element 2, right by 1.
			while (index != start) {
				arr[index] = arr[index - 1];
				index--;
			}
			arr[start] = value;

			// Update all the pointers
			start++;
			mid++;
			start2++;
		}
	}
}

/* l is for left index and r is right index of the
sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r)
{
	if (l &lt; r) {

		// Same as (l + r) / 2, but avoids overflow
		// for large l and r
		int m = l + (r - l) / 2;

		// Sort first and second halves
		mergeSort(arr, l, m);
		mergeSort(arr, m + 1, r);

		merge(arr, l, m, r);
	}
}

/* UTILITY FUNCTIONS */
/* Function to print an array */
void printArray(int A[], int size)
{
	int i;
	for (i = 0; i &lt; size; i++)
		cout &lt;&lt;" "&lt;&lt; A[i];
	cout &lt;&lt;"\n";
}

/* Driver program to test above functions */
int main()
{
	int arr[] = { 12, 11, 13, 5, 6, 7 };
	int arr_size = sizeof(arr) / sizeof(arr[0]);

	mergeSort(arr, 0, arr_size - 1);

	printArray(arr, arr_size);
	return 0;
}

// This code is contributed by shivanisinghss2110
```



  &lt;/details&gt;

  &lt;/details&gt;	- 

	## Worst Case Copmlexity of merge sort

	- $O(n^2) $:
	- 
	- An example of merging two arrays
		- left, right 각각 $
		\frac n 2$개

	→ 그림으로 바꾸기


		![4](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/4.png)


	## Worst-case time complexity


	![5](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/5.png)


	![6](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/6.png)


	![7](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/7.png)

	- 편의상 $n=2m$이라 할 경우 $(m \in Z^+ \cup \{0\}$)
		- $T(n) = 2T(\frac {n} {2}) + cn, n \geq 2$
			- 2 : Number of subproblems
			- $\frac n 2$ : Subproblem size
		- $T(1)=1 \rightarrow T(n) = O(nlogn)$
		- Merge Sort Complexity Analysis
	- n개의 원소를 k개와 l개로 나누어 진행한다고 가정하면 ($n=k+l$),
		- $T(n) = T(k) + T(l) + cn (k \approx l)$
		- $n = 2^m$ 이 아닌 일반적인 경우에도 같은 시간 복잡도를 가짐을 증명할 수 있음.

	## Solving Recurrence Equations

	- Solve the following recurrences $T(n)$ for given $T(1)=1$
		1. $T(n) = aT(n-1) + bn$
		2. $T(n) = T(\frac n 2) + bn \log n$
		3. $T(n) = aT(n-1) + bn^2$
		4. $T(n) = aT(n/2) + bn^2$
		5. $T(n) = T(\frac n 2) + c \log n$
		6. $T(n) = T(\frac n 2) + cn$
		7. $T(n) = 2T(\frac n 2) + cn$
		8. $T(n) = 2T(\frac n 2) + cn \log n$
		9. $T(n) = T(n-1) + T(n-2)$, for $T(1)=T(2)=1$
	- space complexity : embedded program 등 사실 제일 중요한 요소중에 하나로서, 현실 사회에서도 반드시 개발할 때 고려해야 함

	→ Space Complexity : $O(n)$

	- Space complexity : merge sort algorithm을 구현하는데 lienar space보다 더 적게 할수 있나?
		- 불가능: 데이터 input n개를 모두 저장해야하다
		- input array O(n)이 필요하고, 더 필요한건 O(n)이니가 알고리즘 관점에서 문제가 되지는 않음 : O(n)
		- 실제 구현한다고할 때, 심각한 문제가 될 수 있음.
	- Time complexity : time complexity가 나왔을 때 진짜 알고리즘 전공하거나 어느정도 수준이 되면 이거보다 더 빠른 알고리즘을 만들 수 있을까 싶을 것임. → $O(n \log n)$을 넘어설 수는 없다.
		- alg - implementation은 서로 다른 세상이다.

	## Some Derivations

	1. T(n) = 2 T(n/2) + cn, T(1) = 1
		- assume $n=2^m$, i.e., $m=\log_2m$ for some $m \geq 0, m \in \mathbb{Z}$
		- $T(2^m) 
		
		\\= 2T(2^{m-1})+c \cdot 2^mT(2m)
		\\ =2T(2m−1)+c⋅2m\\=2{2T(2m−2)+c⋅2m−1}+c⋅2m
		\\=2^2⋅T(2m−2)+2⋅c⋅2m\\=2^2{2⋅T(2m−3)+c⋅2m−2}+2⋅c⋅2m...\\=2m⋅T(20)+m⋅c⋅2m=n⋅1+(\log 2n)⋅c⋅n=O(n \log n)$

			$\\= 2 \{2T(2^{m-2})+c \cdot 2^{m-1} \}+c \cdot 2^m$


			$\\=2^2 \cdot T(2^{m-2})+2 \cdot c \cdot 2^m$


			$\\= 2^2 \{2 \cdot T(2^{m-3})+c \cdot 2^{m-2} \}+2 \cdot c \cdot 2^m$


			$\\ ... \\= 2^m \cdot T(2^0) + m \cdot c \cdot 2^m$


			$\\= n \cdot 1 + (log_2 n) \cdot c \cdot n = O(n \log n )$


		![8](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/8.png)

	2. $T(n) = T(n-1) + cn, T(1) = 1$
	3. $T(n) = 2 T(n/2) + cn^2, T(1) = 1$
		- Assume $n=2^m$ for some $m \in \mathbb{Z} - \mathbb {Z^-}$
undefined		- $2 \cdot T (2^{m-1}) + c \cdot 2 ^2m2⋅T(2m−1)+c⋅22m=2$

			$\\ = 2 \{ 2 \cdot T(2^{m-2}) + c \cdot 2 ^{2(m-1)} \} + c \cdot 2 ^2m$


			$\\= 2^2 \cdot T(2^{m-2}) + c \{ 2^{2m-1} + 2 ^{2m}\}$


			$\\ = 2 \{ 2 \cdot T(2^{m-3}) + c \cdot 2 ^{2(m-2)} \} + c \{ 2^{2m-1} + 2^{2m} \}$


			$\\= 2^3 \cdot T(2^{m-3})+ c \{ 2^{2m-2} + 2^{2m-1} + 2 ^{2m}\}$


			$\\ … \\= 2^m + 2 \cdot c \cdot 2^{2m} - 2 \cdot c \cdot 2^m$


			$\\ =2 \cdot c \cdot n^2 - (2 \cdot c -1) n = O(n^2)$


	## Another Implementation of Merge Sort

	- ref. [Horowitz 7.6.3]

		```c
		typedef struct {
		  int key;
		  int link;
		} element;
		```


		![9](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/9.png)

	- `rmerge` returns an integer that points to the start of the sorted list. start = rmerge(list, 0, n-1);

		```c
		int rmerge(element list[], int lower, int upper)
		{
		    /*sort the list, list[lower], ..., list[upper]. 
				// the link field in each record is initially set to -1*/ 
				// list[lower], …, list[upper]까지 오름차순으로 정렬.
				// 각 레코드의 link filed는 초기에 -1로 설정int middle;
		    if (lower &gt;= upper)
		        return lower;
		    else
		    {
		        middle = (lower + upper) / 2;
		        return listmerge(list, rmerge(list, lower, middle), rmerge(list, middle + 1, upper));
		    }
		}
		```

	- `listmerge` takes two sorted chains, first and second, and returns an integer that points to the start of a new sorted chain that includes the first and second chains.

		```c
		int listmerge(element list[], int first, int second)
		{
		    // first와 second가 가리키는 서브리스트들을 합병int start = n;
		    while (first != -1 &amp;&amp; second != -1)
		    {
		        if (list[first].key &lt;= list[second].key)
		        {
		            list[start].link = first;
		            start = first;
		            first = list[first].link;
		        }
		        else
		        {
		            list[start].link = second;
		            start = second;
		            second = list[second].link;
		        }
		    }
		    if (first == -1)
		        list[start].link = second;
		    else
		        list[start].link = first;
		    return list[n].link;
		    // 합병된 리스트의 시작 인덱스를 return
		}
		```

		- `listmerge` 함수 수행 예 start

			![10](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/10.png)


# [ALG] 3.1.2. Quick Sort (1)


	## 3.1.2. Quick Sort

	- comparison sort 중 하나
		- merge sort보다 worst case  : O(n^2)
		- 일반적으로 quick sort의 변형이 제일 빠르다고 실험을 통해 알려져 있음
	- Pivot strategy
		1. **Divide**
			- Select a **pivot element**, and then divide the array into two subarrays such that ....
				- 원소 중 하나를 뽑음
			- 비용 : $O(n)$ - 상수시간 안에 뽑고 쭉 n개를 보면서 15보다 크면 오른쪽으로 가고 15보다 작으면 왼쪽 그룹에 배치하여 모으는 작업 - 하나 씩 건드리는 작업이므로 n-1개를 보아야 함.
		2. **Conquer**
			- sort each subarray recursively.
			- $T(n_1) + T(n_2)  (n_1 + n_2+1 = n)$
		3. **Combine**
			- do nothing.
			- conquer 결과를 갖고 전체 결과를 만들어 냄.
			- merge sort: 각 subproblem을 해결해서 합쳐 원래 문제의 해답을 얻는 단계
			- quick sort : 이미 다 정렬된 케이스

		![11](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/11.png)


	![12](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/12.png)

	- merge sort : 계산 과정에서 binary tree가 만들어지는데, well-balanced binary tree가 만들어짐.
		- quick sort의 경우 well-balenced tree가 안될 수도있고, skewed (한 쪽으로 치우쳐진) tree
		- worst case의 경우 : 높이는 $O(n)$ + stack overflow의 가능성
			- 완전 정렬된 경우 맨 왼쪽 것을 pivot으로 삼았을 때
			- 거꾸로 정렬된 경우
		- 시간복잡도 등 여러 측면에서 well-balanced가 skewed보다 낫다.
		- 평균적으로 임의의 데이터가 들어왔을 때 quick sort가 빠르다.
	- Quick sort worst case Time Complexity : $O(n^2)$
		- $T(n) = T(n-1) + cn (n\geq 2)$
			- cn : divide cost
			- 한 쪽으로만 skewed된 tree
			- → $T(n) = O(n^2)$
		- $T(n) = 1 (n =1)$
	- average T.c. $O(n \log n)$, worst t.c. : $O(n^2)$
		- 일반적으로 quick sort가 구현하는데 있어서 빠르다
		- merge sort : average, worst - $O(n \log n)$
	- A simple implementation
		- $r-l&gt;0 → r-l+1 &gt;1$
			- 2개 이상의 개수 판별

		![13](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/13.png)


		```c
		// Sort a list from A[left] to A[right].
		// Should be optimized for higher efficiency!!!
		void quick_sort(item_type *A, int left, int right)
		{
		    int pivot;
		    if (right - left &gt; 0)
		    {
		        // divide
		        pivot = partition(A, left, right);
		        // conquer
						quick_sort(A, left, pivot - 1);
		        quick_sort(A, pivot + 1, right);
		    }
		}
		```


		```c
		#define SWAP(a, b) {
			item_type tmp;
			tmp = a;
			a = b;
			b = tmp;
		}
		
		int partition(item_type *A, int left, int right)
		{
		    int i, pivot;
		    pivot = left; //제일 왼 쪽에 있는 element를 pivot으로 설정
		    for (i = left; i &lt; right; i++)
		    {
		        if (A[i] &lt; A[right])
		        {
		            SWAP(A[i], A[pivot]);
		            pivot++;
		            // How is the pivot element chosen in this function?
		        }
		    }
		    SWAP(A[right], A[pivot]);
		    return (pivot);
		}
		```


		![14](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/14.png)

		- → 스스로 이해해볼 것

		&gt; ☀️ 첫 벉재 프로그래밍 과제  
		&gt; - 구현과 이론 사이 간극, 성능 검정


	# 직관적인 시간 복잡도 추정

	- skewed보다는 well-balanced가 더 나음
	- $T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1)$ if $n&gt;1$
	- $T(1) = 1$
	- → $O(n \log n) \leq T(n) \leq O(n^2)$

	![15](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/15.png)

	- node에 붙은 것을 다 더하면 n^2
	- log n *n 해서 n \log n
	- 평균적으로 봤을 때 n log n

	# Cost Analysis

	- worst case : $O(n^2) &lt;&lt; $merge, quick sort

	![16](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/16.png)

	- Cost
		- $T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1)$ if $n&gt;1$
	- Analysis
		- Divide : $O(n)$
		- Conquer : $T(m_1)+T(m_2)$
		- Combine : $O(1)$
	- Worst-case time complexity
		- 매 단계에서 선택한 pivot element가 가장 크거나 가장 작을 경우,
		- $T(n) = T(0) + T(n-1) + cn, T(1)=1$ then $T(n)=O(n^2)$
		- $T(1) = 1$
		- $T(n) = O(n^2)$
		- Skewed vs well-balanced trees
			- 

			![17](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/17.png)

	- Average-case time complexity
		- $T(n) = \sum_{p=1}^n {T(p-1) + T(n-p)} + cn$
		- $T(0) = 1 \rightarrow$
		- $\therefore T(n) = O(n log n)$
		- 

			![18](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/18.png)

	- mathematical induction

		![19](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/19.png)


		![20](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/20.png)


	# Average Case Time Complexity


	### 첫 번째 사실

	- $n \leq 0, \forall n \in \mathbb{Z}, T_{ave}(n)$ 을 n개의 원소를 가지는 배열을 퀵 정렬 방법을 사용하여 정렬하는데 걸리는 평균 수행시간이라고 하자. 그러먼 어떤 양의 정수 b와 c에 대해 다음과 같은 재귀 관계 존재
		- $T_{ave} (n) \geq cn + \frac {1}{n} \sum_{p=1}^{n} \{ T_{ave} (p-1) + T_{ave} (n-p) \}$
		- $\\= cn + \frac{2}{n} {\sum_{p=0}^{n-1} {T_{ave}(p)}}$
		- $\forall n \geq 2$
	- $T_{ave} (1) \leq b$
	- $T_{ave} (0) \leq b$
	- $Cost_{ave} = \sum_{p=1}^n {P_r (p) \cdot Cost(p)} = \frac {1}{n} \sum_{p=1}^n {... + ...}$

	### 두 번째 사실

	- $k=2(b+c)$ 라 할 때, 2보다 같거나 큰 모든 정수 n 에 대하여 $T_{ave} (n) \leq kn \log_e n$과 같은 관계 존재
	- 증명: 위의 부등식을 수학적 귀납법을 사용하여 증명하자.
		1. $n=2$
			- 첫 번째 사실로부터 다음과 같은 관계 성립
				- $T_{ave}(2) \leq 2c + T_{ave} (0) + T_{ave} (1) \leq 2(b+c) \leq k \cdot 2 \ log_e 2$
			- ∴ 따라서 두 번째 사실 성립
		2. 3보다 같거나 큰 임의의 n_n_ 이 given
			- Assume that : m&lt;n_m_&lt;_n_ 인 모든 m_m_ 에 대하여 두 번째 사실 성립한다고 가정하자.
			- 그러면 첫 번째 사실과 이 과정을 사용하여 다음과 같은 관계 유도 가능
			- $T_{ave} (n) \leq cn + \frac {2} {n} \sum_{m=0}^{n-1} {T_{ave} (m)}$
				- $\\ = cn + \frac 2 m \{ T_{ave} (0)+T_{ave} (1) \} + \frac {2} {n} \sum_{m=2}^{n-1} {T_{ave}(m)}$
				- $\\ \leq cn + \frac {4b} n + \frac {2k} n \sum_{m=2}^{n-1} {m log_e m}$
			- 그러므로 $T_{ave} (n) \leq cn + \frac {2} {n} \sum_{p=0}^{n-1} {T_{ve} (p)}∀n≥2$
			- $\frac 2 n \Sigma_{m=2}^{n-1} T_{ave} (m) : T_{ave}(m) \leq km \log _e m \leq \frac {2k}{n} \Sigma _{m=2}^{n-1} m \log_e n$
		- 함수 $x \log_e x$가 x_x_에 대하여 아래로 볼록한 함수이어서 $m log_e m \leq \int_m^{m+1} x \log_e x dx$라는 사실을 이용하면 다음과 같은 관계식을 얻는다.
			- $T_{ave} (n)= cn + \frac {4b}n + \frac {2k}n \int_2^n x log_e x dx$
			- $≤cn+n4b+n2k{2n2 \log_en−4n^2}=kn \log_e n+{cn+n^4b−2kn}$

				$\\ \leq cn + \frac {4b}{n} + \frac{2k}{n} \{ \frac{n^2 log_e n}{2} - \frac {n^2} 4 \}$


				$\\= knlog_e n + \{ cn + \frac{4b} n - \frac {kn} 2\}$


			&gt; $\int_2^n x log_e x dx =[\frac 1 2 x^2 log_e x - \frac {x^2} 4]_2^n$


				$= (\frac {n^2} 2) log_e n - \frac {n^2} 4 - (2log_e 2 - 1) \leq \frac {n^2} {2} {log_e n} - \frac {n^2} {4}$

		- 이 때, $cn + \frac{4b} n - \frac {kn} 2 = (c-\frac k 2 )n + \frac {4b} n = b(\frac 4 n -n)$ 과 같고 이 값은 2보다 같거나 큰 n에 대해 항상 0보다 같거나 작으므로 $ T_{ave} (n) \leq kn log_e n$이 되어 3보다 같거나 큰 임의의 n에 대해서도 두 번째 사실이 성립한다. 따라서 2보다 같거나 큰 모든 정수 n에 대해 다음과 같은 두 번째 사실이 성립한다.

		![21](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/21.png)


		![22](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/22.png)


		![23](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/23.png)


	## Another Implementation


	&gt; 🏝️ 중간고사 빈칸 .??? 코드가 편해질 때 까지!


	```c
	void quicksort(element list[], int left, int right)
	{
	    // list[left], …, list[right]까지 오름차순으로 정렬.
	    // list[left].key를 중추 키(pivot key)로 선정
	    // list[left].key ≤ list[right + 1].key 라고 가정
	    int pivot, i, j;
	    element temp;
	    if (left &lt; right)
	    {
	        i = left;
	        j = right + 1;
	        pivot = list[left].key;
	        do
	        {
	            // pivot을 중심으로 왼쪽과 오른쪽 리스트 생성
	            // 왼쪽 리스트: pivot보다 적은 키들을 저장, 오른쪽은 반대do
	            // 왼쪽부터 pivot보다 큰 키를 검색
	            i++;
	            while (list[i].key &lt; pivot);
	            do // 오른쪽부터 pivot보다 작은 키를 검색
	                j--;
	            while (list[j].key &gt; pivot);
	            if (i &lt; j)
	                // 각 리스트의 속성을 만족하도록 데이터 교환
	                SWAP(list[i], list[j], temp);
	        } while (i &lt; j);
	        SWAP(list[left], list[j], temp);
	        quicksort(list, left, j – 1);
	        // 왼쪽 리스트를 다시 정렬
	        quicksort(list, j + 1, right);
	        // 오른쪽 리스트를 다시 정렬
	    }
	}
	
	//code 약간 다르니 수정
	```


	## Comparison Sorts

	- source: WikiPedia

		![24](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/24.png)

	- 못난이 삼형제 sort : $O(n^2)$
		- insertion, select, bubble
		- n log n 방법들이 있음에도 n^2를 공부 : 장점은 구현하기 쉽다. 그리고 n log n, n^2늬 차이는 n이 커질 때 차이가 나는 것이지, 10개 즈음이면 복잡하게 function call하면서 쓸 필요가 없는 것이다. 너무 구현이 단순해서 오히려 더 빠를수도 있다.
		- insertion : 이를 이용하여 quick sort를 더 빠르게 할 수 있다.

	cost comparison


	![25](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/25.png)


	---


	## Improving the Performance of Quick Sort


	<첫 번째="" technique="">

	- How can you select a “good” pivot element? : pivot element를 잘 선택하는 것이 중요
		- Choose a <u>random</u> element in the list.
		- 가장 이상적인 케이스 : Choose **the** <u>**median**</u> **of the first, middle, and final** elements in the list.
			- 세 개만 보자, 다섯 개만 보자 : constant time
				- 데이터가 11개 있는데 그 중 크기 순으로부터 5번째 것을 찾아라 → linear time에 될까?
					- linear time에 당연히 된다.
					- median이 아니라 임의의 kth element를 찾는 문제도 나중에 divide and conquer에 나오고, 당연히 median 찾는 것도 가능
		- Choose **the** <u>**median**</u> **of the entire elements** in the list. (bad idea)
			- 다 보자 : 상수 시간에서 lienar time (to pick pivot element)
		- 이론적으로는 아무 문제 없음
			- 그러나 그만큼의 linear time 만큼이 추가되는 것이기 때문에 구현 측면에서 좋지 않음
		- Etc.

	![26](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/26.png)

	- Program 7.4. improved quicksort
		- Choosing the median of the first, middle, and final elements as the partitioning element and cutting off the recursion for small subfiles can significantly improve the performance of quicksort.
		- This implementation partitions on the median of the first, middle, and final elements in the array (otherwise leaving these elements out of the partitioning process).
		- Files of size 11 or smaller are ignored during partitioning; then, insertion from is used to finish the sort.

	<두 번째="" technique="">

	- if (r - l &lt;= M)  // r-l+1 &lt;= M + 1
		- compiler가 다 없애줌 : compiler의 최적화
	- merge sort:
		- 함수의 작동 기작 : 처음에 전체에 대해서 함수가 호출되고, recursively 1/2로 나누어지며 원소가 1개일 때 까지 split되며 control이 왔다갔다한다.
		- stack에 각 정보를 저장해 두고 내려간다.
		- quick sort → insertion
			- 이빨 빠지듯 중간에 quicksort가 이루어지지 않은 부분에 대해서

		```c
		#define M
		
		void quicksort(ITEM[] a, int l, int r)
		{
		//첫 벉재 technique : 어떻게 하면 pivot을 더 좋은 것을 뽑을가?
		//두 번째 technique : 
		// 정렬하려는 개수 r-l+1인데 이를 r-l+1 &lt;= M+1 
		// 해당 문장이 의미하는 바 : 정렬하고자 하는 원소의 개수가 주어진 상수값 m+1보다 작거나 같으면 정렬하지 말고 넘어가라. m=5, 7, 10, .. 사용하는 computing system에서 실험을 통해 얻어야 하는 값 (적당히 작은 값)
		// 원소으ㅐ 개수가 5-6개 정도 되면 그냥 빠져나와라 : 정렬이 안 된 경우 -&gt;건너뛴 부분 생김
		// insertion sort를 적용하면 이론적으로는 n^2이지만 정렬 안 하고 건너 뛴 부분들이 있을 때 전체적으로 sorting이 되어 있는데 부분 부분 정렬되지 않은 부분 -&gt; linear time에 돈 부분
		
		// 왜 빨라지는지 생각해 보고 올 것.
		    if (r - l &lt;= M)
		        return;
				// r-l+1 &lt;= M + 1
		
		    exch(a, (l + r) / 2, r - 1);
		    compExch(a, l, r - 1);
		    compExch(a, l, r);
		    compExch(a, r - 1, r);
		    int i = partition(a, l + 1, r - 1);
		//median을 찾아 divide하는 단계
		    quicksort(a, l, i - 1);
		    quicksort(a, i + 1, r);
		//양 쪽에 대하여 quick sort
		}
		
		void sort(ITEM a[], int l, int r)
		{
		    quicksort(a, l, r);
		    insertion(a, l, r);
		}
		```

	- How can you minimize the bookkeeping cost involved in the recursive calls?
		- Much of the pushing and popping of the frame stack is unnecessary.
		- Lists of size smaller than M are ignored during quick sort, then do a single sorting pass at the end.
		- depth만큼의 stack 필요함
		- 한없이 줄줄 내려가는 recursive function call : skewed되어서 줄줄이 내려가는 케이스의 경우 system에서 stack overflow

	![27](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/27.png)

	- How can you minimize the bookkeeping cost involved in the recursive calls?
		- pivot element: 제일 왼 쪽에 있는 것을 갖고 싶다
		- 작은 쪽에 대해서는 recursivesy
			- 큰 쪽 : 속도보다는 큰 데이터에 알맞게
		- Avoid making the recursive call on the larger subrange.
		- The depth of recursion $\leq O(\log n)$

	```c
	quicksortTRO(E, first, last)
	{
	  int first1, last1, first2, last2;
	  first2 = first;
	  last2 = last;
	  while (last2 - first2 &gt; 1)
	  {
	
	      pivotElement = E[first];
	      pivot = pivotElement.key;
	      int splitPoint = partition(E, pivot, first2, last2);
	      E[splitPoint] = pivotElement;
	      if (splitPoint &lt; (first2 + last2) / 2)
	      {
	          first1 = first2;
	          last1 = splitPoint - 1;
	          first2 = splitPoint + 1;
	          last2 = last2;
	      }
	      else
	      {
	          first1 = splitPoint + 1;
	          last1 = last2;
	          first2 = first2;
	          last2 = splitPoint - 1;
	      }
	      quicksortTro(E, first1, last1);
	// continue loop for fist2, last2.
	  }
	  return;
	}
	
	
	```


	![28](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/28.png)


	## Example: Quick Sort


	By courtesy of David R. Musser

	- Average-case: $O(n \log n)$
	- Worst-case: $O(n^2)$

		![29](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/29.png)

	- 코드 상에서는 별 차이 없지면 simulation에서는 에러가 날 수도 있다.
		- tech 1,2, 3

	## Performance Comparisons

	- 

	![30](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/30.png)


	## Quicksort: Implementation 2 [K. Loudon]


	```c
	#include <stdlib.h>
	#include <string.h>
	#include "sort.h"
	static int compare_int(const void *int1, const void *int2)
	{
	    // Compare two integers (used during median-of-// three partitioning
			if (*(const int *)int1 &gt; *(const int *)int2)
		    return 1;
	
	    else if (*(const int *)int1 &lt; *(const int *)int2) 
			return -1;
	
	    else return 0;
	}
	
	static int partition(void *data, int esize, int i, int k, int (*compare)(const void *key1, const void *key2))
	{
	    char *a = data;
	    void *pval, *temp;
	    int r[3];
	    /*  Allocate storage for the partition value and swapping. */
	    if ((pval = malloc(esize)) == NULL)
	        return -1;
	    if ((temp = malloc(esize)) == NULL)
	    {
	        free(pval);
	        return -1;
	    }
	    /* Use the median-of-three method to find the partition value.  */
	    r[0] = (rand() % (k - i + 1)) + i;
	    r[1] = (rand() % (k - i + 1)) + i;
	    r[2] = (rand() % (k - i + 1)) + i;
	    issort(r, 3, sizeof(int), compare_int);
	    memcpy(pval, &amp;a[r[1] * esize], esize);
	    /* Create two partitions around the partition   value.  */
	    i--;
	    k++;
	    while (1)
	    {
	        /* Move left until an element is found in the wrong partition. */
	        *do { k--; }
	        while (compare(&amp;a[k * esize], pval) &gt; 0)
	            ;
	        /* Move right until an element is found in the wrong partition. */ do
	        {
	            i++;
	        } while (compare(&amp;a[i * esize], pval) &lt; 0);
	
	        if (i &gt;= k)
	        {
	            break;
	        }
	        /* Stop partitioning when the left and right counters cross. */ else
	        {
	            /* Swap the elements now under the left and   right counters.  */ memcpy(temp, &amp;a[i * esize], esize);
	            memcpy(&amp;a[i * esize], &amp;a[k * esize], esize);
	            memcpy(&amp;a[k * esize], temp, esize);
	        }
	    }
	
	    /* Free the storage allocated for
	         partitioning. */
	    free(pval);
	    free(temp);
	    /* Return the position dividing the two partitions. */ return k;
	}
	
	int qksort(void *data, int size, int esize, int i, int k, int (*compare)(const void *key1, const void *key2))
	{
	    int j;
	    /* Stop the recursion when it is not possible
	         to partition further. */
	    if (i &lt; k)
	    {
	        // Determine where to partition the elements
	        if ((j = partition(data, esize, i, k, compare)) &lt; 0)
	            return -1;
	        // Recursively sort the left partition
	        if (qksort(data, size, esize, i, j, compare) &lt; 0)
	            return -1;
	
	        // Recursively sort the right partition
	        if (qksort(data, size, esize, j + 1, k, compare) &lt; 0)
	            return -1;
	    }
	
	    return 0;
	}
	```


# [ALG] 3.1.3. Insertion Sort (1)


	## Insertion Sort: Example 1


	매번 for loop이 돌 때마다 정렬된 stack이 다시 정렬됨


	![31](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/31.png)

	- 정렬된 배열이 끝에 가선 다 정리됨.
	- comparison sort : nlog n보다 더 빨리 할수 없다고 증명되어 있음.
	- $O(n^2)$ : worst case time complexity
		- $1+2+3+ ... + (n-1)$
		- 처음에 15 비교 → 10, 15 비교, …
		- 제일 오른쪽애랑비교하여 나보다 크면오른쪽으로 가라, 작으면 왼쪽으로 가라
	- best case time complexity
		- 1 + 1 + … + 1 = n-1 = O(n) - linear time
	- inp place algorithm

	## Insertion Sort: Example 2


	![32](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/32.png)

	- 전체적으로는 정렬 잘 된 것처럼 보이지만 중간에 잘 안된 케이스 존재
		- worst case는 o(n^2)이지만 linear처럼 돌아가게 됨.
			- n이 100만 일 때 엄청나게 큰 차이 존재
	- Insertion : $O(n+d)$ in the worst case over sequences that have d inversions
	- When does the insertion sort run fast?
	- 이러한 insertion sort의 성질을 quick sort의 성능 향상에 활용하자.
		- 이러한 insertion sort의 성질을 이용해서 quick sort를 더 빠르게 어떻게 할 것인가? (practical 구현 관점)
			- 

	## Implementation


	```c
	void insertion_sort(int *A, int n)
	{
	    int i, j, tmp;
	    for (i = 1; i &lt; n; i++)
	    {
	        tmp = A[i];
	        j = i;
	        while ((j &gt; 0) &amp;&amp; (tmp &lt; A[j - 1]))
	        {
	            A[j] = A[j - 1];
	            j--;
	        }
	        A[j] = tmp;
	    }
	}
	```

	- Sort a list of elements by iteratively inserting a next element in a progressively growing sorted array.

		```c
		#include <stdlib.h>
		#include <string.h>
		#include "sort.h"
		int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))
		{
		    char *a = data;
		    void *key;
		    int i, j; // Allocate storage for the key element.
		    if ((key = (char *)malloc(esize)) == NULL)
		        return -1;
		    // Repeatedly insert a key element among the sorted elements.
		    for (j = 1; j &lt; size; j++)
		    {
		        memcpy(key, &amp;a[j * esize], esize);
		        i = j - 1;
		        // Allocate storage for the key element.
		        if ((key = (char *)malloc(esize)) == NULL)
		            return -1;
		        // Repeatedly insert a key element among the sorted elements.
		        for (j = 1; j &lt; size; j++)
		        {
		            memcpy(key, &amp;a[j * esize], esize);
		            i = j - 1;
		            /* Determine the position at which to insert the key element. */ while (i &gt;= 0 &amp;&amp; compare(&amp;a[i * esize], key) &gt; 0)
		            {
		
		                memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
		                i--;
		            }
		            memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
		            i--;
		        }
		        memcpy(&amp;a[(i + 1) * esize], key, esize);
		    }
		    // Free the storage allocated for sorting.free(key);
		    return 0;
		}
		```


	## Run-Time Analysis

	- Worst case
		- No. of comparisons:
			- $1+2+ ...+n-1 = O(\frac {n^2}{2})$ : 완전히 뒤집혀진 경우 최악
		- No. of record assignments:
			- $1+2+ ...+n-1 = O(\frac {n^2}{2})+2(n-1)$
				- 왜 2가 붙는가 :

		![33](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/33.png)


		![34](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/34.png)

	- Average case
		- No. of comparisons

			$\sum_{i=1}^{n-1} {\frac{1+2+...+i+i}{i+1} } =\sum_{i=1}^{n-1} {(\frac{i}{2}+1-\frac{1}{i+1})}$


			$\approx \frac{(n-1)(n+4)}{4} - \ln n = O(\frac{n^2} 4)$

		- No. of record assignments

			$\sum_{i=1}^{n-1} {\frac{0+1+2+...+i}{i+1} +2} = \frac{n(n-1)}{4}+2(n-1) = O(\frac{n^2}4)$

			- 0번으로 시작해서 8번째에 insert : 확률적으로 위치는

			![35](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/35.png)


	## Example (skip)


	![36](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/36.png)


# [ALG] 3.1.4. Selection Sort (1)


	## Implementation

	- $T(n) = O(n^2)$

		```c
		#define SWAP(a, b) {
		    item_type tmp;
		    tmp = a;
		    a = b;
		    b = tmp;
		}
		
		void selection_sort(item_type *A, int n)
		{
		    int i, j, cur;
		
		    for (i = 0; i &lt; n - 1; i++)
		    {
		        cur = i;
		        for (j = i + 1; j &lt; n; j++)
		            if (A[j] &lt; A[cur])
		                cur = j;
		        SWAP(A[i], A[cur]); // what if i == cur? }
		    }
		}
		```


	## Example


	![37](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/37.png)


	## Run-Time Analysis

	- Worst case
		- No. of comparisons

			$\sum_{i=0}^{n-2} (n-i-1) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$3(n-1) = O(3n)$

	- Average case
		- No. of comparisons

			$\sum_{i=0}^{n-2} (n-i-1) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$3(n-1) = O(3n)$

	- [생각해보기] If we code like “if (i != cur) SWAP(A[i], A[cur]);”, what is the average cost?

# [ALG] 3.1.5. Bubble Sort (1)


	## Example


	![38](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/38.png)


	## Implementation


	```c
	#define SWAP(a, b) {
			item_type tmp;
			tmp = a;
			a = b;
			b = tmp;
	}
	
	void bubble_sort(item_type *A, int n)
	{
	    int i, j;
	
	    for (i = 0; i &lt; n - 1; i++)
	    {
	        for (j = n - 1; j &gt; i; j--)
	        {
	            if (A[j] &lt; A[j - 1])
	                SWAP(A[j], A[j - 1]);
	        }
	    }
	}
	```


	![39](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/39.png)


	## Run-Time Analysis

	- Refer to The Art of Computer Programming (Vol. 3)
	- Worst Case
		- No. of comparisons

			$\sum_{i=1}^{n-1} (n-1-i) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$\sum_{i=1}^{n-1} 3i = \frac 3 2 n(n-1)= O (\frac {3} {2} n^2)$

	- Average case
		- No. of comparisons

			$\sum_{i=1}^{n-1} (n-1-i) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$\frac 1 2 \sum_{i=1}^{n-1} 3i = \frac 3 2 n(n-1)= O (\frac {3} {4} n^2)$


# [ALG] 3.1.6. Cost Comparison (1)

	- 

	![40](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/40.png)

	- # of comparisons
		- Insertion
			- (average) $\frac {n^2} 4$
			- (worst) $\frac{n^2} 2$
		- Bubble
			- (average) $\frac{n^2}{2} $
			- (worst) $\frac{n^2}2$
		- selection : $\frac{n^2}2$
	- # of record assignments
		- Insertion
			- (average) $\frac{3n^2} 4$
			- (worst) $\frac{n^2}2$
		- Bubble
			- (average) $\frac 4 3n^2$
			- (worst) $\frac{3n^2}2$
		- selection : $3n$

	## Comparison Sorts


	[https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms)


	![41](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/41.png)


	## Performance Comparisons

	- By courtesy of David R. Musser
	- 

		![42](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/42.png)

</string.h></stdlib.h></string.h></stdlib.h></두></첫></iostream></details></details>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] 3.1.1. Merge Sort (1)]]></summary></entry><entry><title type="html">[ALG] 2. Heap-based PQ</title><link href="http://localhost:4000/ALG-2.-Heap-based-PQ" rel="alternate" type="text/html" title="[ALG] 2. Heap-based PQ" /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-2.-Heap-based-PQ</id><content type="html" xml:base="http://localhost:4000/ALG-2.-Heap-based-PQ"><![CDATA[<p>Heap-based Priority Queue, Heap Sort</p>

<h1 id="a-variety-of-priority-queue-implementations">A Variety of Priority Queue Implementations</h1>

<ul>
  <li>Heap이라는 개념 - 매우 전공에서 중요한 자료구조. 실제로 컴퓨터 system에서 메모리르 다루는 데 쓰이는 핵심적인 구조중 하나</li>
  <li>Insert, delete : 원소를 집어넣고 빼고 - queue</li>
  <li>Push, Pop : 데이터를 집어넣었다가 빼고 - stack</li>
  <li>data를 넣었다가 뺐다가 이런것을 반복하는 것들. 구현이 적합한 stack
    <ul>
      <li>→ queue, stack은 굉장히 특정 형태를 갖는 방식으로 데이터를 넣고 빼는 작업</li>
    </ul>
  </li>
  <li>[Priority Queue 1: Max(Min) Heap]</li>
  <li>[Priority Queue 2: Min-Max Heap]</li>
  <li>[Priority Queue 3: Heap and Hashing]</li>
  <li>[Priority Queue 4: Deap]</li>
  <li>[Priority Queue 5: Leftist Tree]</li>
  <li>[Priority Queue 6: Binomial Heap]</li>
  <li>[Priority Queue 7: Fibonacci Heap]</li>
  <li>

    <p><img src="/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/0.png" alt="0" /></p>
  </li>
</ul>

<h1 id="job-scheduling-example-priority-queue">[Job Scheduling Example: Priority Queue]</h1>

<ul>
  <li>Consider the following sequence of requests in an operating system:</li>
  <li>multiprocessing을 할 때 여러 process가 도는데,
    <ul>
      <li>예를 들어 바이러스가 침입했고 이를 막기 위한 process가 제일 먼저</li>
      <li>제한된 rsrc를 시간 쪼개가며 쓴다. cpu 입장에서는 다음에 시간을 나누어 process를 돌릴 놈을 나와라 하여 처리해 주고 그 다음 줄 서있는 놈들 중 process 번호, owner , priority일 때 여러 policy로 OS를 만들 수 있다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/1.png" alt="1" /></p>
  </li>
  <li>data 저장소에 처리해달라는 것이 들어가 있고, data 저장소에 들어갔다 나왔다가 계속반복되고 있다. 가장 먼저 들어온 애를 가장 먼저 처리해 주고, OS마다 인터넷에서 동영상 보는 process보다는 운영체제들이 바이러스 및 네트워크 처리 등 priority 높은 process들이 있다.</li>
  <li>data저장소에 element가 있는데 priorty를 가지고 우선순위가 높은 놈 나와, 하는 것이 priority-based
    <ul>
      <li>각각의 원소들이 들어갈 때 계속 들어가고 뺄 때는 priority에 따라 나오게 함.</li>
      <li>데이터 저장 :나올 때 우선순위 설정</li>
    </ul>
  </li>
</ul>

<h2 id="requirement-1">Requirement 1</h2>

<ul>
  <li>CPU executes the process with the highest priority first.</li>
  <li>Use a heap structure – a simple max heap :)</li>
  <li>

    <p><img src="/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/2.png" alt="2" /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_process</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">proc_id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Process</span><span class="p">;</span>
	
<span class="k">static</span> <span class="n">Process</span> <span class="o">*</span><span class="n">_proc_heap</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_proc_heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">_proc_heap_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
<span class="kt">int</span> <span class="nf">PH_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">PH_full</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">PH_empty</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">PH_insert</span><span class="p">(</span><span class="n">Process</span> <span class="n">item</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">PH_delete</span><span class="p">(</span><span class="n">Process</span> <span class="o">*</span><span class="n">item</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="requirement-2">Requirement 2</h2>

<ul>
  <li>
    <p>The priority of processes can be modified after they are placed in the priority queue.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">H_change_priority</span><span class="p">(</span><span class="kt">int</span> <span class="n">proc_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_priority</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>This function requires locating a particular process in the heap, but the basic heap operations provide no efficient way to do it.</li>
      <li>Employ an auxiliary data structure such as a hash table that keeps track of the location of each process in the heap structure.</li>
    </ul>
  </li>
  <li>
    <p>Once the two requirements are satisfied, the operating system can process the following basic commands efficiently</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  INSERT  &lt;proc_id&gt;  &lt;owner&gt;  &lt;priority&gt;
  DELETE
  CHANGEPR &lt;proc_id&gt; &lt;new_priority&gt; PRINTHEAP
  END
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-22-pq1-maxmin-heap-1">[ALG] 2.2. PQ1: Max(Min) Heap (1)</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_ref_. [Horowitz 5.6.2] [Neapolitan 7.6]


# PQ1: Max(Min) Heap

- Problem
	- The following operations must be performed as mixed in data processing:
		- Store a record with a key in an arbitrary order.
		- Fetch the record with the current largest key.
- A solution
	- &lt;u&gt;Design a&lt;/u&gt; &lt;u&gt;**data structure**&lt;/u&gt; that offers an efficient implementation of the following operations:
- &lt;u&gt;**Insert an element with an arbitrary key.**&lt;/u&gt;
- &lt;u&gt;**Delete an element with the largest key.**&lt;/u&gt;

	![3](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/3.png)

	- key = priority 의미
		- 두 가지 operation을 효율적으로 구현하는 자료구조를 설계하여 구현하라
		- insert, delete 등 용어는 알아서 생각하면 될 것.
- 배열 array 가지고 구혆할 수 있는 방법
	- 0, 1, 2, 3. .. 끝에다 계속 집어넣으면 됨
	- 제일 끝에 있는 애를 보내주면 끝이 된다.
	- insert하고 delete의 연산이 있는데, data가 현재 배열 data 저장소에 n개 원소가 있을 때 insert, delete의 비용은
		- insert $O(1)$
		- sequential search → delete $O(n)$
- system 들어가는 것은 느려도 상관 없는데 나올 때는 빨리 나와야 한다고 하면 array가 더 좋을수도 있음
	- 일반적으로 heap이 성능이 좋기는 함

	![4](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/4.png)


	|        | array | array | heap     |
	| ------ | ----- | ----- | -------- |
	| insert | O(1)  | O(n)  | o(log n) |
	| delete | O(n)  | O(1)  | O(log n) |
</code></pre></div></div>

<p>undefined
	# An Array Implementation</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Ref. [Sedgewick 9.2]

	```c
	void PQinit();
	int PQempty();
	void PQinsert(int);
	int PQdelmin();
	void PQdec(int);
	
	#include &lt;stdlib.h&gt;
	static int *pq;
	static int N;
	#define MAX_N 10000;
	
	void PQinit()
	{
	    pq = malloc(MAX_N * sizeof(int));
	    N = 0;
	}
	int PQempty()
	{
	    return N == 0;
	}
	void PQinsert(int v)
	{
	    pq[N++] = v;
	}
	
	int PQdelmin()
	{
	    int j, min = 0;
	    for (j = 1; j &lt; N; j++)
	        if (less(pq[min], pq[j]))
	            min = j;
	    exch(pq[min], pq[N - 1]);
	    return pq[--N];
	}
	
	int less(int i, int j)
	{
	    return **... * *;
	}
	
	void exch(int i, int j)
	{
	    ...
	}
	
	void PQdec(int k)
	{
	    ...
	}
	```

- What will be the worst-case time complexity of each operation?

# Max(Min) Heap: Definitions


![5](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/5.png)

- tree
	- rooted tree
		- 일반적인 tree에서 vertex를 하나 잡아 올려 root
		- binary - 최대 두 개 까지의 child를 가지는 tree
		- full binary tree : 모두 두개 child를 갖는 tree
		- complete binary tree : 제일 끝의 leaf 몇 개만 날아간 bt
			- pointerless representation
			- 왼쪽 child는 parent의 두 배, 오른쪽 child는 parent의 두 배 +1
	- a kind of graph
		- connected + acyclic
		- vertex, edge

## Definition 1

- [Horowitz 5.6.2] [Neapolitan 7.6]
- A max(min) heap is a complete binary tree where the key value in each internal node is no smaller(larger) than the key values in its children.

## Definition 2

- A binary tree has the max(min) heap property if and only if
	- The number of nodes of the tree is either 0 or 1, or
	node 0개거나 1개면 max heap
	- For the tree that has at least two nodes, the key in the root is no smaller(larger) than that in each child and the subtree rooted at the child has the max(min) heap property.
	
	root node는 자신의 child보다 같거나 작지 않다 (같거나 크다)
	그리고 각각의 child를 root으로 하는 subtree.
	- 나랑 같이 생겼는데 size만 작은 것의 성질 : recursion 성질을 잘 생각해보면 밑으로 내려가면 결국 어떤 node든 건에 parent는 child보다 크다.
- A &lt;u&gt;max(min) heap&lt;/u&gt; is a complete binary tree that has the &lt;u&gt;max(min) heap property.&lt;/u&gt;
	- max heap : complete BT - max heap property를 갖는

![6](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/6.png)


### Brainstorming on Max Heap Operations

- Max Heap Example
	- 성질을 잘 이해할 것 : 자기 자신보다 같거나 크니까 36이 아니라 101이어도괜찮음
- Deletion Example 1
	- data 저장된 것들 중 priority/key 제일 큰 것 나감. - 103
	- 계속해서 complete BT 유지하려고 하는데 대장 103이 나가버림.
	- 원래 있던 것보다 원소 개수가 하나 더 줄은, heap을 유지하는 방법은 어떻게 되는가?

		→ 자식보다 같거나 크다는 성질 : 101을, 99를 올리느냐 고민하며 101이 올라가며 빈 곳을 다른 node들이 채워 줌.


		max heap property가 깨지기 때문에 아님. 무조건 하나씩 위로 올리는 것은 아님을 확인할 수 있음. 9를 올리면 맨 끝 13은 해결할 수 없음


	![7](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/7.png)

- Deletion Example 2
	- 13을 왕 시키면 항상은 문제 생기지 않음
		- 우연히 밑의 원소가 13일 때는 문제가 안생기겠지만.
	- child에서 101, 99중에 이 동네 왕 한번 해 볼까 하고 살펴보는 그 상황ㅇ으로 바뀌게 됨. 13이 왕 해볼까 하는 상황에서 101을 올려보는 상황이고 왼쪽 아래로 내려감.
	- 많은 tree의 문제들이 recursion 자체를 서서 활용가능함
	- delete alg의 최대 비용, 시간 비용 - 최대 몇 칸까지 내려가는가 (3칸) - log적으로 보여얗 ㅏㅁ
	- complete bt는 됨.
	- 경로에 있는 애들은 ‘내가 내 child보다 크다’라는 heap 조건을 잘 지켰음
	- 두 child보다 큰 13 &gt; 9, 6의 형태 - 두 child보다 같거나 크다는 성질을 유지하며 내려옴./
- Insertion Example
	- 50을 집어넣어라. 그러면 complete bt 만들어야 하나ㅣ node를 하나 만들고 100을 집어넣는다.
	- root까지의 path 경로에 있는 관계만 따지면 됨 :
		- left family에서 100이 있건 없건 아무 상관없음 (heap의 정리에 의해서)
		- 형제 관계 중에서도 상관없고, 중요한 건 부모와 나의 관계일 뿐
		- 경로를 쫓아 올라가며 부모를 보고 부모보다 크면 자신잉 부모가 됨. (부모보다 작으면 그 시점에서 멈춤. 같은 논리로, 경로를 max heap 성질을 유지하면서 왔고 + 나머지는 유지가 되어 있고 → 알고리즘의 합리성 검증
		- 최악의 경우 log(n) time

	![8](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/8.png)

- $C = \log_2 n$
- Deletion from a Max Heap
- ref. [Horowitz 5.6.2]

	```c
	#define MAX_ELEMENTS 200
	#define HEAP_FULL(n) (n == MAX_ELEMENTS - 1) #define HEAP_EMPTY(n)(!n)
	typedef struct
	{
	    int key;
	    /* other fields */
	} element;
	element heap[MAX_ELEMENTS];
	int n = 0;
	```


	![9](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/9.png)


	$2^c \leq n &lt; 2^{c+1} \rightarrow c \leq log_2 n &lt;c+1$


	```c
	//최대 히프에 삽입
	void insert_max_heap(element item, int *n)
	{
	    int i;
	    if (HEAP_FULL(*n))
	    {
	        fprintf(stderr, "the heap is FULL\n");
	        exit(1);
	    }
	    i = ++(*n);
	    while ((i != 1) &amp;&amp; (item.key &gt; heap[i / 2].key))
	    {
	        heap[i] = heap[i / 2];
	        i /= 2;
	    }
	    heap[i] = item;
	}
	
	```


	![10](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/10.png)


	$C \sim log_2n $


	```c
	element delete_max_heap(int *n)
	{
	    int parent, child;
	    element item, temp;
	    if (HEAP_EMPTY(*n))
	    {
	        fprintf(stderr, "The heap is empty\n");
	        exit(EXIT_FAILURE);
	    }
	
	    item = heap[1];
	
	    temp = heap[(*n)--];
	    parent = 1;
	    child = 2;
	    while (child &lt;= *n)
	    {
	
	        if ((child &lt; *n) &amp;&amp; (heap[child].key &gt; heap[child + 1].key))
	            child++;
	        if (temp.key &lt;= heap[child].key)
	            break;
	
	        heap[parent] = heap[child];
	        parent = child;
	        child *= 2;
	    }
	    heap[parent] = temp;
	    return item;
	}
	```


	![11](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/11.png)


	![12](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/12.png)


	$O(\log n)$

- child가 있을 때까진 내려가야 한다.
	- child가 2개면 left , right 중 큰 거 선택해서 줄줄줄 while 문에서 돈다.
- 중간고사에서 빈칸 매꾸기 문제 가능

	child 2개 : 


# Another Heap Implementation (Min Heap)

- _ref_. [Sedgewick 9.3]

	```c
	void PQinit(int);
	int PQempty();
	void PQinsert(int);
	int PQdelmin();
	static int *pq;
	static int N;
	void PQinit(int maxN)
	{
	    pq = malloc(maxN * sizeof(int));
	    N = 0;
	}
	
	int PQempty()
	{
	    return N == 0;
	}
	
	void PQinsert(int v)
	{
	    pq[++N] = v;
	    fixUp(pq, N);
	}
	
	Item PQdelmin()
	{
	    exch(pq[1], pq[N]);
	    fixDown(pq, 1, N - 1);
	    return pq[N--];
	}
	
	fixUp(int a[], int k)
	{
	    while (k &gt; 1 &amp;&amp; a[k / 2] &gt; a[k])
	    {
	        exch(a[k], a[k / 2]);
	        k = k / 2;
	    }
	}
	
	fixDown(int a[], int k, int N)
	{
	    int j;
	    while (2 * k &lt;= N)
	    {
	        j = 2 * k;
	        if (j &lt; N &amp;&amp; a[j] &gt; a[j + 1])
	            j++;
	        if (a[k] &lt;= a[j])
	            break;
	        exch(a[k], a[j]);
	        k = j;
	    }
	}
	```

- What will be the worst-case time complexity of each operation?

&gt; 💡 sort by comparisoin algorithm. 원소 n개 있을 때 n log n 속도 보다 빠르게 불가능하다.


## Comparisons of Priority Queue Implementations


![13](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/13.png)


# Heap Sort


Horowitz 7.7., Neapolitan 7.6

- Method
	1. Convert an input array of n unordered items into a max heap.
	2. Extract the items from the heap one at a time to build an ordered array.
- Sort by comparison : comparison을 통해 정렬하는 방법은 input size n에 대해서 cost는 아무리 좋은 알고리즘을 만들더라도 $O(n \log n)$보다 더 빠르게 할 수는 없다 (optimal이다)
	- 불가능하다고 증명된 바 있음

	&gt; 💡 원소의 개수 n에 대해서 정렬이 안된 임의의 배열에 대해서 min, max heap은 ilnear time에 적용할 수 있다. 그리고 그 둘은 유용한 자료구조

- max heap : 크기가 같거나 큰 순서대로 데이터를 정렬하는 것이 목표인데, max heap 상태에서는 정렬은 정확하게는 안 되어있는 어정쩡한 상태. 대충 정렬은 된 듯한데 중간에 삐쭉한, 정확하게 맞지는 않은 상태.
- unordered data를 크기 순서대로 정리하려고 함. 한 단계 중간단계를 거쳐서 max heap 으로 변경한 다음 ordered 단계로 변환

![14](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/14.png)

- 1번 단계의 시간 복잡도 - n이 걸리고 2번에서 n이 걸려서 N log n 타임의 데이터를 정렬한다.
- 주어진 정수들을 비감소 순서(non-decreasing order)대로 정렬하라.
	- nondecreasing ≠ increasing (단조증가 등의 차이)

	```c
	typedef struct
	{
	    int key;
	    /* other fields */
	} element;
	Element list[MAX_SIZE];
	```


	```c
	void heapsort(element list[], int n)
	{
	    /*perform heapsort on the array*/ int i, j;
	    element temp;
	
	    // (1) Make a (max) heap
	    for (i = (n) / 2; i &gt; 0; i--)
	        adjust(list, i, n);
	
	    // (2) Extract items one by one
	    for (i = n - 1; i &gt; 0; i--)
	    {
	        SWAP(list[1], list[i + 1], temp);
	        adjust(list, 1, i);
	    }
	}
	```

	- (1) Make a (max) heap : $O(n)$
	- (2) Extract Items : $O(n \log n)$

→ n log n


upper bound eㅚ면서 operation들이 없어지고 다 하면 각각은 tight upper bound


제일 큰 거 나와 해서 집어넣어주고 n-2개 대해서 똑같은거 반복하니까 


log n-1


처음에 n개 있었는데 나머지 n-1개에 대해서 어떤 node가 leaf에 들어갈 수 있는지 없는지 확인


$2^c \leq n &lt; 2^{c+1} \rightarrow c \leq \log_2 n &lt;c+1$


## Make a Max Heap

1. $O(n\log n) \rightarrow O(n\log n)$
	- Make a (max) heap.

		![15](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/15.png)


		![16](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/16.png)


		![17](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/17.png)


		![18](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/18.png)


		![19](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/19.png)


## The `adjust()` function


&gt; 💡 과거 알고리즘 만든 사람의 논리를 분석해서 적용해보자. 그러면 computatinoal thinking 상황에서 자연스럽게 파악하며 성장할 수 있다!

- cost : 각각에 대해서 핵심이 되는 operation
	- root에서 시작해서 두 child중에 큰 것 (list[child].key &lt;
- 어떻게 생각했을까 추적해보면 : ‘혹시 정의에 의해서 :
	- 정의 : root node는 두 child보다 같거나 크고, 각각의 child를 root로 하는 subtree가 max heap이면 recursive한 max heap이 구성된다
	- 두 child를 root로 하는 tree
- code

	```c
	void adjust(element list[], int root, int n)
	{
	    int child, rootkey;
	    element temp;
	    temp = list[root];
	    rootkey = list[root].key;
	    child = 2 * root;
	    while (child &lt;= n)
	    {
	        if ((child &lt; n) &amp;&amp; (list[child].key &lt; list[child + 1].key))
	            child++;
	        if (rootkey &gt;= list[child].key)
	            break;
	        else
	        {
	            list[child / 2] = list[child];
	            child *= 2;
	        }
	    }
	    list[child / 2] = temp;
	}
	```


	![20](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/20.png)

	- Executed d times, where d is the depth of the tree with root i → $O(d)$

# Cost of Make-Heap


![21](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/21.png)

- Executed d_d_ times, where d_d_ is the depth of the tree with root i_i_
	- So $O(d)$ time
- `Output`: a binary tree T adjusted so that the entire binary tree satisfies the heap property
- `Input`: a binary tree T whose left and right subtrees satisfy the heap property but whose root may not

## Proof of correctness of Heap Construction Algorithm


```c
//make a max heap
for(i =n/2;i&gt;0;i--)
	adjust(list,i,n);
```

- $i = \frac n 2 , \frac n 2 -1, \frac n 2 -2, ... 2, 1$
- Loop Invariant
	- just before each iteration for the for-loop starts, each node numbered i+1, i+2, … n is the root of a max heap
- Proof of correctness by mathematical Induction
	- base step (base case, basis)
		- when $i = \frac n 2 $ (why?)
	- induction step (inductive step)
		- assume that the loop invariant holds for $i=k(k&lt;\frac n 2)$
		- then it also holds for $i = k-1$
			- $k+1, k+2, ... n \rightarrow k, k+1, k+2, ... n$
			- fact 1 : each child node of node k is a max-heap
			- fact 2 : the `adjust()` function makes the node k a root of max-heap
			- fact 3 : it also preserves the property that the nodes k+1, .. n are roots of max-heaps
- notes
	- when the for-loop terminates, the node 1 is the root of a max-heap

## Extract items one by one.

- 꼼꼼히 따져보면서 성적 및 시험에서 그동안 기출 문제를 올릴 예정인데, 이를 강조하는 이유가 나타날 듯
- 제일 큰 놈 나왈 해서 leaf에다 집어넣고,
	- 비용이 n log n : 매번 해 주는 비용을 생각해보면
	- 매번 제일 큰 것 나와 해서 줄줄줄 update를 반복하다보면 제일큰 것 순서대로 쌓이게 될 것.

![22](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/22.png)

- Time Complexity Analysis
	- $2^k \leq 2n2k≤2n, −k&lt;−\log2n$
		- $k &lt; -\log_2 n$
	- then $2k−k−1&lt;2n−\log2n−1$

		$2^k -k -1 &lt; 2n - log_2n -1$

	- so $C_{MH} = O(n)$
- $I = -k+ \frac {1 \cdot (2^k-1)}{2-1} = 2^k -k -1I=−k+2−11⋅(2k−1)=2k−k−1$

	$∴ C_{MH} \leq 2^k -k -1$

- $2I= (k-1)2^1 + (k-2)2^2 + (k-3)2^3 + ...+1 \cdot 2^{k-1}$
	- $\rightarrow 2I-1I= -(k-1) + 2^1+ 2^2 + ... + 2^{k-2}$
- $I= (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \cdot 2^{k-2}$
- $C_{MH} \leq (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \cdot 2^{k-2}$

![23](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/23.png)


$2^{k-1} \leq n &lt; 2^k$ → $k-1 \leq \log_2 n &lt; k$


## Complexity of Item Extractions


![24](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/24.png)


```c
for (int i = n / 2; i &gt; 0; i--)
    adjust(list, i, n);
for (int i = n - 1; i &gt; 0; i--)
{
    SWAP(list[1], list[i + 1], temp);
    adjust(list, 1, i);
}
```

- Heap Sort : $C_{MH} +C_{IE} = O(n)+ O(n \log n) = O(n \log n)$
- $C_{IE}
\\=⌊\log (n-1)⌋+⌊\log (n-2)⌋+⌊\log (n-3)⌋...+⌊\log2⌋+⌊\log 1⌋\\ \leq \log2 + \log3 + ...+\log {(n-1)} = \log (n-1)!\\=O((n-1)\log (n-1)) = O(n \log n)\\&lt; \sum_{i=2}^n \log_2 n
\\= O(n \log n)
\\≤log2+log3+...+log(n−1)\\&lt;∑i=2n \log 2n\\ =O(n \log n)$
- for a given $n$, the cost (depth) is $c = ⌊\log_2n⌋$
- $O(\log n!) = O(n \log n)$
	- proof

## Heap Sort in C Implementation

- 상황에 맞게 판단하여 적용
	- constant time , log n하고는 엄청난 차이가 존재하는 시간 복잡도
	- 2^20이 백만인데 그에 비례하는 시간,

# Priority Queue 2 : Min-Max Heap

- Problem
	- The following operations must be performed as mixed in data processing:
		- Store a record with a key in an arbitrary order.
		- Fetch the record with the current largest key.
		- Fetch the record with the current smallest key.
- A solution
	- Design a data structure that offers the efficient implementation of the following operations (Double-Ended Priority Queue):
		- Insert an element with an arbitrary key.
		- Delete an element with the largest key.
		- Delete an element with the smallest key.
		- → 어떻게 풀 것인지

O(log n) → 

- ref._ref_. [Horowitz 9.1]

---


{교육과정 외}


Priority Queue 3: Heap and Hashing


Priority Queue 4: Deap


Priority Queue 5: Leftist Tree


Priority Queue 6: Binomial Heap


Priority Queue 7: Fibonacci Heap
</code></pre></div></div>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[Heap-based Priority Queue, Heap Sort]]></summary></entry></feed>