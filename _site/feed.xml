<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-29T03:13:09+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Kyuhwan Shim</title><subtitle>Kyuhwan Shim is a senior undergraduate in CS at Sogang University.
</subtitle><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><entry><title type="html">회고와 대회</title><link href="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C" rel="alternate" type="text/html" title="회고와 대회" /><published>2023-11-16T00:00:00+09:00</published><updated>2023-11-16T00:00:00+09:00</updated><id>http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C</id><content type="html" xml:base="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C"><![CDATA[<h1 id="블로그">블로그</h1>

<ul>
  <li>리디자인</li>
</ul>

<h1 id="대회">대회</h1>

<ul>
  <li>2022
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2022 빅콘테스트</li>
    </ul>
  </li>
  <li>2023
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />강서구 데이터 공모전</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />LG Aimers</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Samsung AI Challenge</li>
    </ul>
  </li>
</ul>

<h1 id="일">일</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Nota ITS ML Engineer 인턴 후기
    <ul>
      <li>들어가야 하는 내용
        <ul>
          <li>지원 계기
            <ul>
              <li>타 기업에 대비하여 가질 수 있었던 이점</li>
            </ul>
          </li>
          <li>가서 주로 맡은 업무</li>
          <li>가서 배운 일</li>
          <li>앞으로의 할 일</li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />앞으로 할 일에 대한 정리
    <ul>
      <li>대학원과 취업 사이의 기로</li>
      <li>전공</li>
      <li>ML</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="경험" /><category term="일상기록" /><summary type="html"><![CDATA[블로그]]></summary></entry><entry><title type="html">Final Repackaging for ML (1)</title><link href="http://localhost:4000/Final-Repackaging-for-ML-(1)" rel="alternate" type="text/html" title="Final Repackaging for ML (1)" /><published>2023-06-14T00:00:00+09:00</published><updated>2023-06-14T00:00:00+09:00</updated><id>http://localhost:4000/Final-Repackaging-for-ML-(1)</id><content type="html" xml:base="http://localhost:4000/Final-Repackaging-for-ML-(1)"><![CDATA[<h1 id="7-knn">7. kNN</h1>

<details>
  <summary><u>**kNN = Instance based learning**</u></summary>


주어진 test sample X에 대하여, kNN samples (xn1, yn1) … (xnk, ynk)를 위치시켜 majority class label yn1, .. ynk를 xt에 assign한다.



  </details>
<details>
  <summary><u>**kNN pros and cons**</u></summary>

- pros :
	- training is very fast : feature extraction and save
	- learn complex target fn
	- doesn’t lose info
- cons :
	- slow at test  → not goot
	- requires large storage
	- not robust against irrevalent attributes, outliers


  </details>
<details>
  <summary><u>**Distance Metrics**</u></summary>

- kNN - test 시점 ) data와 Near한지 distance 계산
- distance : 모든 Classification , regression에서 중요
	- 단 Nominal data다루는 DT에서는 불필요
	- similiarity와 반비례
- Euclidean distance : $\sqrt{\Sigma_{d=1}^{D} |x_{td} - x_{nd}|^2}$
- Manhattan distance : ${\Sigma_{d=1}^{D} |x_{td} - x_{nd}|}$
- $L^n$-norm : $\sqrt{\Sigma_{d=1}^{D} |x_{td} - x_{nd}|^n}$


  </details>
<details>
  <summary>**VDM**</summary>


provide d measurements for nominal attributes



  </details>
<details>
  <summary><u>**Problem from Euclidean distance**</u></summary>

1. High dim data - curse of dimensionality
	- 너무 많이 feature, attrib 증가시킬 경우 dim이 너무 많이 증가해 차원의저주
	- sample로부터 available info 가 많고 정확하다면 dim 높아도 괜찮음
2. 보통 sparse하고 density를 shrink하여 적용한다.
3. 과연 d가 동일하다고 data feature를 잘 나타낼까?
	- MSB, LSB 등 bit 연산으로부터 잘 표현이 안될수도 있음
	- Hamming d.


  </details>
<details>
  <summary><u>**Behavior of limit**</u></summary>


$\lim _{n \rightarrow \infty} \leq 2 \epsilon ^*$


pf) goodnote 참고



  </details>
<details>
  <summary><u>**Standardization**</u></summary>


z = x - mu / sigma



  </details>
<details>
  <summary><u>**how to choose k**</u></summary>

- k is too small → sensitive to noise points
- k is too big → neighborhood may include pts from other classes
	- smoother when k get bigger
- 보통 $k = \sqrt N$
- $n \rightarrow \infty$, k gets larger → good performance as good as bayes classifier


  </details>
<details>
  <summary><u>**Cross Validation !!!**</u></summary>

- N fold cross validation → k to minimize cross valid error

overfitting에 의해 - train error를 줄이는 것이 무작정 좋지는 않다



  </details>
<details>
  <summary><u>**Condensing!!!**</u></summary>

- [Aim] reduce the number of training samples
- Decision boundary consistent : same with entire training set
	- min. consistent set : smallest subset of samples

1) init subset with single ex. 
→ 2) nearest neighbor 생성, epsilon나오는 incorrected samples 선택 
→ 3) 2)반복 Until no transfers or subset is full → result 구하기



  </details>
<details>
  <summary><u>**Voronoi Diagram**</u></summary>

- Voronoi Diagram : div space into such cells : 구획으로 나누고 boundary 영향없는 sample del
- Delaunary triagulation 생성 → circumcircle center pt 끼리 연결 : 
각 sample pt class에 따라 전체 영역 Class 결정
	- Delaunary triagulation : 삼각형의 세 점에 외접하는 삼각형, 각도 최대화
	- not unique
- 


  </details>
<h1 id="8-ann"><strong>8. ANN</strong></h1>

<details>
  <summary><u>**Differences with**</u> </summary>

- Similar : SVM처럼 high dimension mapping과 유사한 input layer to hidden layer
	- 원래 feature space에서는 not linearly separable → phi fn(high dim) 으로 sol


  </details>
<details>
  <summary><u>**Bitwise Calc.**</u></summary>


perceptron : AND, OR연산 가능하나 XOR 불가능 

- sol: XOR이 nonlinear해서 생긴 문제 : 2 Decision boundary


  </details>
<details>
  <summary><u>**ANN Training**</u></summary>

- input - hidden - output : hidden layer 수에 따라 네트워크 구조가 좌우되며 linearly nonsolvable 문제도 해결해낼 수 있다
- 1) decide input /output / hidden layer node number 
→ 2) find weight using training alg (backpropagation)
- #class = #node


  </details>
<details>
  <summary><u>**Backpropagation**</u></summary>

- (등장배경) NN-SVM-DNN에서 SVM이 많이 쓰이는 경우였음. NN에서 overfitting / XOR문제
- (Idea) Weight w를 Error 감소하는 방향으로 Update - between prediction vs ground truth val
- (prob. similar to perceptron) stuck in local minima, iteratively get w, many w to get y
- chain rule


  </details>
<details>
  <summary><u>**Vanishing Gradient Problem**</u></summary>


error들이 backpropagate하면 gradient가 vanish하는 현상 : layer에서 소수점이 곱해질수록 0으로 수렴하기 때문이다. w = w - eta dE/du

- sol : requires lots of data
- nonlinear ReLU
- Layerwise learning : 충분히 학습되면 넘어감


  </details>
<details>
  <summary><u>**Overfitting**</u></summary>

- Only get good result for train data only

get stuck in local minima 

- solution : randomly set initial val +many data + much computation power→ train many times → avg 추출

good model check

- solution : train data, test data 변화시키며 stable result를 보이는지 확인한다


  </details>
<h1 id="9-dnn">9. DNN</h1>

<details>
  <summary><u>**Why is better than traditional ML**</u></summary>

- SVM) Manual, Human supervised, div and conquer
	- 기존에 human이 feature extraction한 후 classification함.
	- SVM에서는 Hand-crafted phi fn을 활용해서 alg에서 Pattern이 더 잘 보이도록 수정했다
- DL) Automatical, end-to-end NN
	- end-to-end joint system : NN이라는 hierarchical structure로 feature extract + classification 과정 수행
		- → data를 지속적으로 분류 : 자체적으로 자동적으로 배우고 지능적인 결정 수행
	- modularization : automatically learned from data (each classes)


  </details>
<details>
  <summary><u>**DNN consist**</u></summary>

- input layer + multiple hidden l + output layer


  </details>
<details>
  <summary><u>**(CNN) Layers : FC Layer, Locally connected layer**</u></summary>


corelation 구하는 작업 → 조합을 다음 layer로 전달한다.

- FC : globally corelated - rsrc waste, too much calc., not enough data to train pm
- LC : 일정 convolution내 node (different locations-convolutions with learned kernel)
	- convolution : 특정 Window size filter


  </details>
<details>
  <summary><u>**(CNN) Conv. operations**</u></summary>

- Conv A * B = B * A
- cross-corelation : A . B ≠ B . A
- auto-correlation : 자기 자신과 동일


  </details>
<details>
  <summary><u>**(CNN) Pooling**</u></summary>


filter responses at different location → robustnest to spatial location of filters

- max, avg, l2 pooling


  </details>
<details>
  <summary><u>**(CNN) size of feature map 계산**</u></summary>



  </details>
<details>
  <summary><u>**tasks**</u></summary>

- Classification : exact class 분류
- Localization : obj 주변에 box를 두고 정답과 적어도 50%이상 겹쳐야 함
- Obj Detection : n개의 obj에 모두 boundary box 처리


  </details>
<details>
  <summary><u>**Alexnet**</u></summary>

- act. fn. : ReLU in Hidden layers → faster, expressive than sigmoid
- ten different 224*224 patches from from 256*256 img
- dropout to reg. weight in FC layers
- padding


  </details>
<details>
  <summary><u>**FC Layer**</u> </summary>


has no constrains the input img size (상관 없음)



  </details>
<details>
  <summary><u>**DNN Evolution**</u></summary>


NN - Perceptron - Backporpagatino ,RNN, RBM - CNN, MNIST, LSTM, BRNN - DBN - GAN - AlphaGo

- data labeled
- obj detection focused
- GPU
	- good for mat*mat multiplies + high bandwidth
- shallower


  </details>
<details>
  <summary><u>**Backgrounds**</u></summary>

- HW (GPU) + Data (Big data) + Alg (learning Alg)
- limit : cannot do commonsense reasoning - 상식, 윤리의 Lack


  </details>
<h1 id="10-dnn2">10. DNN2</h1>

<details>
  <summary><u>**Data Processing**</u></summary>



  </details>
<details>
  <summary><u>**Weight Init.**</u></summary>



  </details>
<details>
  <summary><u>**Batch Normalization**</u></summary>



  </details>
<details>
  <summary><u>**Regularization**</u></summary>



  </details>
<details>
  <summary><u>**Dropout**</u></summary>

- (배경) deep NN 일수록 특정 node가 학습 시 dropped case 발생
- (train) assume dropout rate p → (test) no dropout


  </details>
<details>
  <summary><u>**regularization common pattern**</u></summary>



  </details>
<h1 id="11-ensemble-learning">11. Ensemble learning</h1>

<details>
  <summary>Ensemble Learning</summary>

1. 


  </details>
<details>
  <summary>Generate Ensembles </summary>



  </details>
<details>
  <summary>**Ensemble learning via negative correlation learning:**</summary>

- Generating sequentially new predictors **negatively correlated** with the existing ones
	- 현재 classifier하고 negative corelation갖는 classifier를 학습하여 융합한다


  </details>
<details>
  <summary>Bagging</summary>

- Averaging the prediction over a collection of predictors generated from **bootstrap samples** (both classification and regression)

	bootstrap sample :trian data있으면 subset sampling

	- 각각 sampling으로부터 classifier 학습

		Random하게 sampling하며 다양한 model



  </details>
<details>
  <summary>Boosting</summary>

- Weighted vote with a collection of classifiers that were trained sequentially from training sets given priority to instances **wrongly classified**

	Boosting : 여러 단계를 거쳐 classifier 학습

	- 이전 단계의 classifier의 오답에 초점을 맞춘다.

	오류가 나오는 data들을 모아 다음 stage에서 초점을 맞추어 학습하여 융합한다



  </details>
<details>
  <summary>Boosting - Adaboost</summary>



  </details>
<details>
  <summary>Adaboost vs Boosting</summary>



  </details>
<details>
  <summary>Random Forest</summary>


RandomForest:

- Averaging the prediction over a collection of trees constructed using a **randomly selected subset of features**
	- tree를 randomly생성하여 randomly select해서 만든다.


  </details>
<details>
  <summary>Heterogeneous ensembles:</summary>

- Combining a set of **heterogeneous predictors**
	- NN + SVM + DT 등 융합


  </details>
<details>
  <summary>Model Selection</summary>



  </details>
<h1 id="12-clustering">12. Clustering</h1>

<details>
  <summary><u>**K-means clustering**</u></summary>



  </details>
<details>
  <summary><u>**K-means clustering properties**</u></summary>



  </details>
<details>
  <summary><u>**Agglomerative clustering**</u> </summary>



  </details>
<details>
  <summary><u>**Agglomerative clustering - hierarchical clustering : strength, complexity**</u></summary>



  </details>
<details>
  <summary><u>**Closest pair (single-link clustering)**</u></summary>



  </details>
<details>
  <summary><u>**Farthest pair (complete-link clustering)**</u></summary>



  </details>
<details>
  <summary><u>**Average of all pairs**</u></summary>



  </details>
<h1 id="13-dimensionality-reduction">13. Dimensionality Reduction</h1>

<details>
  <summary><u>**Goal of Dimensionality Reduction**</u> </summary>


Visualization 용이 : 3dim 이하로 Reduct → visualize easy


Performance 향상 : easy to handle data


Computation cost 감소 



  </details>
<details>
  <summary><u>**Data Compression**</u></summary>


(필요성) Too high dimension of detection windows : computationally intensive

- Cannot handle them : too high dimensionality → pixel diminish시켜 사용
- Curse of dimensionality : 너무 Data dimension이 높아지면 accuracy가 떨어지는 현상
	- boolean이 아닌 Observed value (measured) : boolean이 아니라 acc 떨어질 수 있음


  </details>
<details>
  <summary><u>**Feature Extraction**</u></summary>


(과정) very high-dim raw data → feature extraction dimension reduction → classifier



  </details>
<details>
  <summary><u>**dimension reduction**</u></summary>


axis에 projection한 형태로 reduct dimension



  </details>
<details>
  <summary><u>**왜 좌표축을 rotate한 것이라고 표현하는가? (multivariate dataset into new config)**</u></summary>

- simplify data
- easy to look at rel. between variable - patterns of units


  </details>
<details>
  <summary><u>**PCA process**</u></summary>

- [goal] find k-dim projection  which preserves best variance


  </details>
<details>
  <summary><u>**PCA  - Eigenvalue, vector의 의미?**</u></summary>

- <u>**eigenvector :PCA분석을 했을 때 data가 가장 크게 분산된 방향으로 표현하는 방향벡터이고 그 정도를 가리키는 것은 eigenvalue.**</u>
- smaller eigenvalue 순 - eigenvector 정렬 → 크게 var되는 방향으로 정렬
- 가장 큰 eigenvector로 하여 좌표축을 변환해도 data들이 잘 표현이 됨
	- data를 Eigenvector에 Projection : 새로운 좌표값으로 나오게 됨


  </details>
<details>
  <summary><u>**LDA**</u></summary>


LDA : labeled 


LDA의 필요성



  </details>
<details>
  <summary><u>**PCA vs. LDA**</u></summary>



  </details>
<details>
  <summary><u>**Eigenface**</u></summary>


x new = sigma wi xi

- data의 Weighted sum으로 나온다 : linear data
- whoe data to DNN → 더 효과적이더라


  </details>
<h1 id="14-rl">14. RL</h1>

<details>
  <summary><u>**Characteristics of Reinforcement Learning**</u> </summary>

- Feedback is delayed, not instantaneous
- Time really matters (sequential, non i.i.d. data)
	- 시간이 중요한 요소 중 하나
	- sequential : 전반의 선택이 후반의 선택에 영향
	iid = independent identically distributed - 상호 연관
- Agent’s actions affect the subsequent data it receives
	- agent action이 이후 data에 영향을 미친다.
- **Goal: select actions to maximize total future reward**
	- 일련의 행동에 따른 reward가 최대가 되도록 학습한다


  </details>
<details>
  <summary><u>**Diff. with supervised, unsupervised learning**</u></summary>

- What makes reinforcement learning different from other machine learning paradigms?
- supervised l. vs unsupervised l. vs. RL
	- supervised : label + data
	- Unsupervised : just use given data
	- RL : data + reward - Reward에 해당하는 추가적인 input이 존재함

→ There is no supervisor, only a reward signal



  </details>
<details>
  <summary><u>**Rewards**</u></summary>

- Indicate show well agent is doing at step t &amp; The agent’s job is to maximize cumulative reward
- 각각의 시간에 얼마나 잘 행동 했는지 보고 reward 최대화되는 방향으로 행동하도록 학습
- Reinforcementlearning is based on the reward hypothesis
	- reward = 사람이 만든 기준
	ex. Atari game : target 별 최대한의 점수를 학습할 수 있도록 학습이 되기도 함. 점수가 많은 쪽을 더 빨리 얻을 수 있도록 학습시키는 양상이 생길 수 있다,
	- Reward hypothesis: all goals can be described by the m**aximization of expected cumulative reward**
- Reward may be delayed reward는 delay를 수반하여 주어질 수 있다
- 현재 action으로 인한 reward에 더 중점을 둘 것인지, 미래의 reward에 중점을 더 둘 것인지 : user setting할 수도 있고 학습 단계에서 어떻게 parameter를 설정했는지에 따라 / 학습이 잘 효과적으로 이루어질수 있는지를 고려하여 모수 조정
	- (greedy) 현재 reward에 초점을 맞추는 경우 - current reward
	- (optimal) 전체 reward에 초점을 맞추는 경우 - total reward
		- Itmay be better to sacrifice immediate reward to gain more long-term reward (greedy optimal)


  </details>
<details>
  <summary><u>**구성 of RL**</u></summary>

- At each stept the agent: agent가 주변을 관찰하고, reward를 받아 action을 취함
	- Executes action At
	- Receives observation Ot
	- Receives scalar reward Rt
- An RL agent may include one or more of these components:
	- Policy: agent’s behavior function 행동 정의
	- Value function: how good is each state and/or action 얼마나 좋은가
	- Model: agent’s representation of the environment  학습 모델

&lt;agent, environment의 상호작용&gt;
agent는 action을 취하고 state에 따라 Reward를 받게 됨
env는 action을 받아들여서 agent에게 주고 변환된 statement를 agent에게 줌

- t타임으로 이루어지는 요소들


  </details>
<details>
  <summary><u>**Bellman Eq**</u></summary>


$$
V(s) = max_a(R(s,a) + \gamma V(s'))
$$

- $R(s,a) $: reward: state에서 취한 action에 따른 reward
- $V(s)$ : is the value function - value function:전체 reward 를 어떻게 표현할 것인가
- $\gamma$ : is the discounting factor
	- 현재-미래 reward중 어느 것에 초점을 맞출 것인지 중요도 맞추는 상수
- $s'$ : is the next state agent can go from
	- s : 현재 state, s’ : next state

$$
V(s) = max_a(R(s,a) + \gamma V(s'))
$$

- By calculating V(s) for all states
	- Agent can move to the state with larger state value
- 임의의 출발점에서 state function 커지는 쪽으로 action을 취하면 된다
→ equation을 이용해서 value funcition을 구한후 최적의 path를 구할 수 있다


  </details>
<details>
  <summary><u>**Sequential Decision Making**</u></summary>

- 현재의 action이 다음 턴 action에 영향을 미치는데, 오랜 turn에 대해 영향을 끼칠수도 있음.
- Actions may have long term consequences
	- state가 있고 action을 취해서 s1-(a1)-&gt;s2-(a2)-&gt;s3


  </details>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="ML" /><summary type="html"><![CDATA[7. kNN]]></summary></entry><entry><title type="html">9. DNN Deep Neural Network (1)</title><link href="http://localhost:4000/9.-DNN-Deep-Neural-Network-(1)" rel="alternate" type="text/html" title="9. DNN Deep Neural Network (1)" /><published>2023-05-24T00:00:00+09:00</published><updated>2023-05-24T00:00:00+09:00</updated><id>http://localhost:4000/9.-DNN-Deep-Neural-Network-(1)</id><content type="html" xml:base="http://localhost:4000/9.-DNN-Deep-Neural-Network-(1)"><![CDATA[<p>박운상 교수
Office: R-911
Tel: 705-8936
Email: <a href="mailto:unsangpark@sogang.ac.kr">unsangpark@sogang.ac.kr</a></p>

<h1 id="deep-learning">Deep Learning</h1>

<ul>
  <li>A machine learning subfield. Exceptional performance in learning patterns.</li>
  <li>Deep learning algorithms attempt to learn (multiple levels of) representation by using a hierarchy of multiple layers.</li>
  <li>If you provide the system tons of information, it begins to understand it and respond in useful ways.</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/0.png" alt="0" /></p>

<ul>
  <li>Manually designed features are often over-specified, incomplete and take a long time to design and validate</li>
  <li>Learned Features are easy to adapt, fast to learn</li>
  <li>Deep learning provides a very flexible, (almost?) universal, learnable
framework for representing world, visual and linguistic information.</li>
  <li>Can learn both unsupervised and supervised</li>
  <li>Effective end-to-end joint system learning</li>
  <li>Utilize large amounts of training data</li>
</ul>

<h2 id="history">History</h2>

<ul>
  <li>In ~2012, deep learning (DL) started outperforming other machine learning (ML) techniques, first in speech and vision, then NLP</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/1.png" alt="1" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/2.png" alt="2" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/3.png" alt="3" /></p>

<h2 id="structure">Structure</h2>

<p>어떻게 DL이 좋은 성능을 내는가?</p>

<ul>
  <li>Fat + Short vs. Thin + Tall Networks</li>
  <li>The same number of parameters</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/4.png" alt="4" /></p>

<ul>
  <li>Deep → Modularization</li>
  <li></li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/5.png" alt="5" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/6.png" alt="6" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/7.png" alt="7" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/8.png" alt="8" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/9.png" alt="9" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/10.png" alt="10" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/11.png" alt="11" /></p>

<ul>
  <li>Before 2006, deeper usually does not imply better performance.</li>
  <li><a href="/a8916a1612b345718745d8cf339ab58b">Geoffrey Hinton showed how to train deep network in 2006 [1]</a>
    <ul>
      <li>Learned layers one by one</li>
    </ul>
  </li>
  <li><a href="/a8916a1612b345718745d8cf339ab58b">Deep Neural Networks showed good classification performance with large image data set in 2012. [2] </a>
    <ul>
      <li>GPU</li>
      <li>Big data</li>
      <li>Better learning algorithms</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/12.png" alt="12" /></p>

<p><a href="http://www.gizmodo.com.au/2015/04/the-basic-recipe-for-machinelearning-explained-in-a-single-powerpoint-slide/">http://www.gizmodo.com.au/2015/04/the-basic-recipe-for-machinelearning-explained-in-a-single-powerpoint-slide/</a></p>

<ul>
  <li>Rectified Linear Unit (ReLU)
    <ul>
      <li>Fast to compute</li>
      <li>Vanishing gradient problem</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/13.png" alt="13" /></p>

<ul>
  <li><a href="/a8916a1612b345718745d8cf339ab58b">[Xavier Glorot, AISTATS’11] [3]</a></li>
  <li><a href="/a8916a1612b345718745d8cf339ab58b">[Andrew L. Maas, ICML’13] [4]</a></li>
  <li><a href="/a8916a1612b345718745d8cf339ab58b">[Kaiming He, arXiv’15] [5]</a></li>
</ul>

<h1 id="dropout">Dropout</h1>

<p><a href="/a8916a1612b345718745d8cf339ab58b">Dropout [6]</a></p>

<ul>
  <li>Each time before computing the gradients</li>
  <li>Each neuron has $p \times 100 \%$ chance to be dropped
    <ul>
      <li>The structure of the network is changed</li>
    </ul>
  </li>
  <li>Use the new network for training</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/14.png" alt="14" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/15.png" alt="15" /></p>

<ul>
  <li>Weights should be multiplied by (1-p) when testing</li>
</ul>

<h2 id="training-stage">Training stage</h2>

<p>Assume dropout rate is 50%</p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/16.png" alt="16" /></p>

<h3 id="testing-stage">Testing stage</h3>

<p>No dropout</p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/17.png" alt="17" /></p>

<h1 id="convolutional-neural-network">Convolutional Neural Network</h1>

<h2 id="fully-connected-layer">Fully connected layer</h2>

<ul>
  <li>Example: 200x200 image * 40K hidden units → ~2B parameters</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/18.png" alt="18" /><em>Slide Credit: Marc’Aurelio Ranzato</em></p>

<ul>
  <li>Waste of resources + we have not enough training samples</li>
  <li>Spatial correlation is local</li>
</ul>

<h2 id="locally-connected-layer">Locally Connected Layer</h2>

<ul>
  <li>Example: 200x200 image * 40K hidden units → ~4M parameters (Filter size: 10x10)
Page 20- Spatial correlation is local</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/19.png" alt="19" /></p>

<ul>
  <li>Waste of resources + we have not enough training samples</li>
  <li>Spatial correlation is local</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/20.png" alt="20" /></p>

<ul>
  <li>Statistics is similar at different locations
    <ul>
      <li>Share the same parameters across</li>
    </ul>
  </li>
  <li>different locations (weight sharing)
    <ul>
      <li>Convolutions with learned kernels</li>
    </ul>
  </li>
</ul>

<h2 id="convolution-operation">Convolution operation</h2>

<p>$F(m,n) = f * h = \Sigma_{l= -\frac w 2}^{\frac f 2}\Sigma_{k= -\frac w 2}^{\frac w 2} {f(m+k, n+l) *h(\frac w 2 -k, \frac w 2 -l)}$</p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/21.png" alt="21" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/22.png" alt="22" /></p>

<ul>
  <li>If a feature is useful in some locations during training, detectors for that feature will be useful in all locations during testing</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/23.png" alt="23" /></p>

<h2 id="pooling">Pooling</h2>

<ul>
  <li>By “pooling” (e.g., taking max) filter responses at different locations, we gain robustness to the exact spatial location of features.</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/24.png" alt="24" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/25.png" alt="25" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/26.png" alt="26" /></p>

<h3 id="max-pooling">Max-pooling</h3>

<p>$h_i^n(r,c) = max_{\bar r \in N(r), \bar c \in N(c), } h_i^{n-1} (\bar r, \bar c)$</p>

<h3 id="average-pooling">Average-pooling</h3>

<p>$h_i^n(r,c) = mean_{\bar r \in N(r), \bar c \in N(c), } h_i^{n-1} (\bar r, \bar c)$</p>

<h3 id="l2-pooling">L2-pooling</h3>

<p>$h_i^n(r,c) = \sqrt{\Sigma_{\bar r \in N(r), \bar c \in N(c), } h_i^{n-1} (\bar r, \bar c)}$</p>

<h2 id="convolution-kernel-filter-examples">Convolution kernel (filter) examples</h2>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/27.png" alt="27" /></p>

<ul>
  <li>
    <p>Examples of learned object parts from object categories</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/28.png" alt="28" /></p>
  </li>
</ul>

<h2 id="lenet-5-1998">LeNet-5 (1998)</h2>

<p><a href="/a8916a1612b345718745d8cf339ab58b">[7] Le-Net</a></p>

<ul>
  <li>Yann LeCun and his collaborators developed a really good recognizer for
handwritten digits by using backpropagation in a feedforward net with
    <ul>
      <li>Many hidden layers (at that time),</li>
      <li>3 convolution layer,</li>
      <li>2 subsampling (pooling) layer</li>
      <li>5*5 convolution kernels,</li>
      <li>~340,000 connections,</li>
      <li>~60,000 parameter</li>
    </ul>
  </li>
  <li>
    <p>Used for reading ~10% of the checks in North America</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/29.png" alt="29" /></p>
  </li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/30.png" alt="30" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/31.png" alt="31" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/32.png" alt="32" /></p>

<h2 id="backpropagation-in-cnn">Backpropagation in CNN</h2>

<ul>
  <li>Same color shares the same weight</li>
  <li>Compute the gradients as usual, and then modify the gradients so that they satisfy the constraints</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/33.png" alt="33" /></p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/34.png" alt="34" /></p>

<ul>
  <li>The 82 errors made by LeNet5</li>
  <li>Notice that most of the errors are cases that people find quite easy.</li>
  <li>The human error rate is probably 20 to 30 errors.</li>
  <li>LeNet uses knowledge about the invariances to design:
    <ul>
      <li>local connectivity</li>
      <li>weight-sharing</li>
      <li>Pooling</li>
      <li>~ 80 errors</li>
    </ul>
  </li>
  <li>Using many different transformations of the input and other tricks (Ranzato2008)
    <ul>
      <li>~ 40 errors</li>
    </ul>
  </li>
  <li>Using carefully designed extra training data (Ciresan 2010)
    <ul>
      <li>For each training image, they produced many new training examples by applying many different transformations</li>
      <li>~ 35 errors</li>
    </ul>
  </li>
</ul>

<p>[Ciresan 2010][8]</p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/35.png" alt="35" /><em>PyTorch implementation of LeNet-5 for MNIST, https://github.com/radsn/LeNet5</em></p>

<ul>
  <li>The top printed digit is the right answer.</li>
  <li>The bottom two printed digits are the network’s best two guesses.</li>
  <li>The right answer is almost always in the top 2 guesses.</li>
  <li>With model averaging they can now get about 25 errors.</li>
</ul>

<h1 id="from-handwritten-digits-to-3-d-objects">From Handwritten Digits to 3-D objects</h1>

<ul>
  <li>Recognizing real objects in color photographs downloaded from the web is much more complicated than recognizing hand-written digits:
    <ul>
      <li>Hundred times as many classes (1000 vs 10)</li>
      <li>Hundred times as many pixels (256* 256 color vs. 28* 28 gray)</li>
      <li>Two dimensional image of three-dimensional scene</li>
      <li>Multiple objects in each image</li>
      <li>Cluttered background</li>
    </ul>
  </li>
  <li>Will the same type of convolutional neural network work?</li>
</ul>

<h1 id="the-ilsvrc-2012-competition-on-imagenet">The ILSVRC-2012 Competition on ImageNet</h1>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/36.png" alt="36" /></p>

<ul>
  <li>[9] ImageNet
    <ul>
      <li>Over 15 million labeled high-resolution images</li>
      <li>Roughly 22,000 categories</li>
      <li>Collected from the web</li>
      <li>Labeled by human using Amazon’s Mechanical Turk crowd-sourcing tool</li>
    </ul>
  </li>
  <li>ImageNet Large-Scale Visual Recognition Challenge (ILSVRC)
    <ul>
      <li>Uses a subset of ImageNet</li>
      <li>1,000 categories</li>
      <li>1.2 million training images</li>
      <li>50,000 validation images</li>
      <li>150,000 test images</li>
    </ul>
  </li>
  <li>The classification task:
    <ul>
      <li>Get the “correct” class in your top 5 bets. There are 1000 classes.</li>
    </ul>
  </li>
  <li>The localization task:
    <ul>
      <li>For each bet, put a box around the object. Your box must have at least 50%
  overlap with the correct box.</li>
    </ul>
  </li>
  <li>Some of the best existing computer vision methods were tried on this dataset by leading computer vision groups from Oxford, INRIA, XRCE(XEROX), …
    <ul>
      <li>Computer vision systems use complicated multi-stage systems</li>
      <li>The early stages are typically hand-tuned by optimizing a few parameters</li>
    </ul>
  </li>
</ul>

<h2 id="examples-from-the-test-set-with-the-networks-guesses">Examples from the test set (with the network’s guesses)</h2>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/37.png" alt="37" /></p>

<p>Error rates on the ILSVRC-2012 competition</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>classification</th>
      <th>classification &amp; localization</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>UToronto</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>16.4%</td>
      <td>34.1%</td>
      <td> </td>
    </tr>
    <tr>
      <td>UTokyo</td>
      <td>26.1%</td>
      <td>53.6%</td>
    </tr>
    <tr>
      <td>Oxford University Computer Vision Group</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>26.9%</td>
      <td>50.0%</td>
      <td> </td>
    </tr>
    <tr>
      <td>INRIA + XRCE</td>
      <td>27.0%</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>undefined- UToronto (deep learning - Alex Krizhevsky, AlexNet)</p>
<ul>
  <li>INRIA (French national research institute in CS) + XRCE (Xerox Research Center Europe)</li>
</ul>

<h1 id="a-cnn-for-imagenet">A CNN for ImageNet</h1>

<p>AlexNet[10]</p>

<ul>
  <li>Alex Krizhevsky (NIPS 2012) developed a very deep convolutional neural net of the type pioneered by Yann LeCun.</li>
  <li>7 hidden layers not counting some max pooling layers</li>
  <li>The early layers are convolutional, the last two layers are fully connected</li>
  <li>The activation functions are
    <ul>
      <li>Rectified linear units in every hidden layer. These train much faster and are more expressive than sigmoid.</li>
      <li>Normalization for better activation</li>
    </ul>
  </li>
  <li>Use “dropout” to regularize the weights in the fully connected layers</li>
  <li>224<em>224 patches are taken from the 256</em>256 images (10 different versions) and leftright reflections are used to get more data</li>
  <li>Used all 10 different patches at test time</li>
</ul>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/38.png" alt="38" /></p>

<h2 id="more-examples-from-alexnet">More examples from AlexNet</h2>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/39.png" alt="39" /></p>

<h2 id="hardware-for-alexnet">Hardware for AlexNet</h2>

<ul>
  <li>He uses a very efficient implementation of convolutional nets on two NvidiaGTX 580 Graphics Processor Units (over 1000 fast little cores)
    <ul>
      <li>GPUs are very good for matrix-matrix multiplies.</li>
      <li>GPUs have very high bandwidth to memory.</li>
      <li>This allows him to train the network in a week.</li>
      <li>It also makes it quick to combine results from 10 patches at test time.</li>
    </ul>
  </li>
  <li>We can spread a network over many cores if we can communicate the states fast enough.</li>
  <li>As cores get cheaper and datasets get bigger, big neural nets will improve faster than old-fashioned computer vision systems.</li>
</ul>

<h1 id="evolution-of-the-dnn">Evolution of the DNN</h1>

<ul>
  <li>Network depths and the performance</li>
  <li>
    <p>ILSVRC classification error (top-5 error)</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/40.png" alt="40" /></p>
  </li>
</ul>

<h1 id="fully-convolutional-networks">Fully Convolutional Networks</h1>

<ul>
  <li>
    <p>Fully connected layer constrains the input image size</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/41.png" alt="41" /></p>
  </li>
  <li>
    <p>Fully convolutional network structure has no constrains on the input image size</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/42.png" alt="42" /></p>
  </li>
</ul>

<h1 id="machine-learning-deep-learning-data-mining-big-data">Machine Learning, Deep Learning, Data Mining, Big data</h1>

<h2 id="big-data">Big Data</h2>

<ul>
  <li>기존 데이터의 크기 범주를넘어서는 규모(2010~)</li>
  <li>기존 데이터 처리 이슈 공유</li>
  <li>대용량 데이터 분산저장/처리 방법 필요</li>
</ul>

<h2 id="machine-learning">Machine Learning</h2>

<ul>
  <li>데이터의 속성을 일반적으로 분석하는 방법, 주로 분류/회귀 작업에 사용됨(1950~)</li>
  <li>지도학습/비지도학습/군집화</li>
  <li>체스 게임으로부터 발전</li>
</ul>

<h2 id="deep-learning-1">Deep learning</h2>

<ul>
  <li>심층 인공신경망 기술을 사용하는 기계학습 방법(2010~)</li>
  <li>기존 기계학습 방법의 성능을 뛰어 넘음</li>
</ul>

<h2 id="data-mining">Data Mining</h2>

<ul>
  <li>데이터에 내재된 속성을 분석 (1930~)</li>
  <li>기계학습과 유사하나 데이터 간의 규칙을 분석하는 측면으로 차별화</li>
</ul>

<h2 id="some-history">Some history</h2>

<ul>
  <li>
    <p>Frank Rosenblatt, Perceptron (1957, 1962): Early description and engineering of single-layer and multilayer artificial neural networks.</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/43.png" alt="43" /></p>
  </li>
  <li>
    <p>Kasparov vs Deep Blue, 1997</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/44.png" alt="44" /></p>
  </li>
  <li>
    <p>Lee Sedol vs AlphaGo, 2016</p>

    <p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/45.png" alt="45" /></p>
  </li>
</ul>

<h3 id="timelines">timelines</h3>

<ul>
  <li>1943: Neural networks</li>
  <li>1957-62: Perceptron</li>
  <li>1970-86: Backpropagation, RBM, RNN</li>
  <li>1979-98: CNN, MNIST, LSTM, Bidirectional RNN</li>
  <li>2006: “Deep Learning”, DBN• 2009: ImageNet + AlexNet</li>
  <li>2014: GANs</li>
  <li>2016-17: AlphaGo, AlphaZero</li>
  <li>Turing Award given for:
    <ul>
      <li>“The conceptual and engineering breakthroughs that have made deep neural
  networks a critical component of computing.”
  • Yann LeCun
  • Geoffrey Hinton
  • Yoshua Bengio</li>
    </ul>
  </li>
</ul>

<h2 id="limitations-of-deep-learning">Limitations of Deep Learning</h2>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/46.png" alt="46" /></p>

<ul>
  <li>Prediction from Rodney Brooks:
“By 2020, the popular press starts having stories that the era of Deep Learning is over.”</li>
  <li>2019 is the year it became cool to say that “deep learning” has limitations.</li>
  <li>Books, articles, lectures, debates, videos were released that learning-based methods cannot do commonsense reasoning.</li>
</ul>

<h2 id="statics-of-acceptance-rate-neurips">Statics of acceptance rate NeurIPS</h2>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/47.png" alt="47" /></p>

<h2 id="deep-learning-frameworktoolkits">Deep Learning Framework/Toolkits</h2>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/48.png" alt="48" /></p>

<h2 id="alexnet">AlexNet</h2>

<p>https://sushscience.wordpress.com/2016/12/04/understanding-alexnet/</p>

<p><img src="/assets/img/2023-05-24-9.-DNN-Deep-Neural-Network-(1).md/49.png" alt="49" /></p>

<hr />

<p>[1] Geoffrey Hinton showed how to train deep network in 2006</p>

<p>[2] Deep Neural Networks showed good classification performance with large image data set in 2012.</p>

<p><a href="/a8916a1612b345718745d8cf339ab58b">[3] [Xavier Glorot, AISTATS’11]</a></p>

<p>Deep Sparse Rectifier Neural Networks. <em><strong>Xavier Glorot, Antoine Bordes, Yoshua Bengio</strong></em>
 <em>Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics.</em> PMLR 15:315-323, 2011.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- [https://proceedings.mlr.press/v15/glorot11a.html](https://proceedings.mlr.press/v15/glorot11a.html)
</code></pre></div></div>

<p><a href="/a8916a1612b345718745d8cf339ab58b">[4] [Andrew L. Maas, ICML’13] </a></p>

<p>Rectifier nonlinearities improve neural network acoustic models (2013) by Andrew L. Maas , Awni Y. Hannun , Andrew Y. Ng</p>

<p><a href="https://ai.stanford.edu/~amaas/papers/relu_hybrid_icml2013_final.pdf">https://ai.stanford.edu/~amaas/papers/relu_hybrid_icml2013_final.pdf</a></p>

<p><a href="/a8916a1612b345718745d8cf339ab58b">[5] [Kaiming He, arXiv’15] </a></p>

<p>Deep Residual Learning for Image Recognition📹
by Kaiming He, Xiangyu Zhang, Shaoqing Ren, Jian Sun</p>

<p><a href="https://arxiv.org/abs/1512.03385">https://arxiv.org/abs/1512.03385</a></p>

<p><a href="/a8916a1612b345718745d8cf339ab58b">[6] Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></p>

<p><em><strong>Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, Ruslan Salakhutdinov</strong></em>; 15(56):1929−1958, 2014.</p>

<p><a href="https://jmlr.org/papers/v15/srivastava14a.html">https://jmlr.org/papers/v15/srivastava14a.html</a></p>

<p><a href="/a8916a1612b345718745d8cf339ab58b">[7] Le-Net</a></p>

<p><a href="http://vision.stanford.edu/cs598_spring07/papers/Lecun98.pdf">http://vision.stanford.edu/cs598_spring07/papers/Lecun98.pdf</a></p>

<p>[8] [Ciresan 2010]</p>

<p>[9] ImageNet</p>

<p>ImageNet: A large-scale hierarchical image database</p>

<p>by Jia Deng; Wei Dong; Richard Socher; Li-Jia Li; Kai Li; Li Fei-Fei</p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="ML" /><summary type="html"><![CDATA[박운상 교수 Office: R-911 Tel: 705-8936 Email: unsangpark@sogang.ac.kr]]></summary></entry><entry><title type="html">8. ANN Artificial Neural Network (1)</title><link href="http://localhost:4000/8.-ANN-Artificial-Neural-Network-(1)" rel="alternate" type="text/html" title="8. ANN Artificial Neural Network (1)" /><published>2023-05-17T00:00:00+09:00</published><updated>2023-05-17T00:00:00+09:00</updated><id>http://localhost:4000/8.-ANN-Artificial-Neural-Network-(1)</id><content type="html" xml:base="http://localhost:4000/8.-ANN-Artificial-Neural-Network-(1)"><![CDATA[<h1 id="ann-introduction">ANN Introduction</h1>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/0.png" alt="0" /><em>h+ p ://cs231n.stanford.edu/slides/winter1516_lecture4.pdf</em></p>

<ul>
  <li></li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/1.png" alt="1" /><em>© 2017, SNU BioIntelligence Lab, h+ p ://bi.snu.ac.kr/</em></p>

<ul>
  <li></li>
  <li>Classification with a line, $y = ax + b$
    <ul>
      <li>single, multi layer perceptron with NN</li>
    </ul>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/2.png" alt="2" /></p>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/3.png" alt="3" /></p>
  </li>
  <li>
    <p>Generalization</p>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/4.png" alt="4" /></p>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/5.png" alt="5" /></p>

<h2 id="artificial-neural-networks-2-layers">Artificial Neural Networks (2 layers)</h2>

<ul>
  <li>NN 기본 구조 perceptron → hidden layer 쌓아 DNN</li>
  <li>Two-layer network
    <ul>
      <li>input layer + output layer (2)</li>
    </ul>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/6.png" alt="6" /></p>

    <ul>
      <li>sigmoid 형태</li>
      <li>no hidden layer → linearly separable prob only</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/7.png" alt="7" /></p>

<h2 id="and">AND</h2>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/8.png" alt="8" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/9.png" alt="9" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/10.png" alt="10" /></p>

<h2 id="or">OR</h2>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/11.png" alt="11" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/12.png" alt="12" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/13.png" alt="13" /></p>

<h2 id="xor">XOR</h2>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/14.png" alt="14" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/15.png" alt="15" /></p>

<ul>
  <li>Two layer network cannot implement XOR.
    <ul>
      <li>perceptron 으로 분류 시 error가 크게 나타남</li>
    </ul>
  </li>
  <li>Non-linear
    <ul>
      <li>two decision boundary (nonlinear)</li>
    </ul>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/16.png" alt="16" /></p>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/17.png" alt="17" /></p>
  </li>
</ul>

<h1 id="multi-layer-networks">Multi-layer Networks</h1>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/18.png" alt="18" /></p>

<ul>
  <li>input - hidden - output</li>
  <li>hidden layer 개수 → 몇 개인지에 따라 network 구조가 좌우됨
    <ul>
      <li>linearly nonsolvable 문제들도 풀 수 있게 된다</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/19.png" alt="19" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/20.png" alt="20" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/21.png" alt="21" /></p>

<ul>
  <li>hidden layer 1개 추가 → 많은 가중치 w들을 학습한다</li>
  <li>수백개 hidden layer →  수천, 수만 w 학습</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/22.png" alt="22" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/23.png" alt="23" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/24.png" alt="24" /></p>

<ul>
  <li>$wx = \Sigma_i w_i x_i$</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/25.png" alt="25" /></p>

<ul>
  <li>feature space : input layer → hidden layer</li>
  <li>SVM과 유사한 효과 : high dimension
    <ul>
      <li>원래 feature space: 원래는 not linearly separable하지만 high dimension phi fn을 활용</li>
      <li></li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/26.png" alt="26" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/27.png" alt="27" /></p>

<ul>
  <li>hidden layer를 추가하면 → 복잡한 boundary를 구할 수 있다</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/28.png" alt="28" /></p>

<h1 id="ann-training">ANN Training</h1>

<ul>
  <li>ANN training?
    <ul>
      <li>Estimate w by using training data</li>
    </ul>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/29.png" alt="29" /></p>

    <p>|               | training                                                                            |
  | ————- | ———————————————————————————– |
  | perceptron    | w                                                                                   |
  | SVM           | w :</p>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>margin, slack var, Phi fn</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Bayesian</td>
              <td>G(mu, sigma^2) : prior</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <p>density modeling → likelihood</p>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>prior P → post P</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Decision Tree</td>
              <td>Tree 구조</td>
            </tr>
            <tr>
              <td> </td>
              <td>kNN</td>
              <td>save train data</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>k value : train통해 결정</li>
      <li>dinstance metric  : 
  L1 vs L2 vs Euclidean |
  | ANN           | w
  NN Structure</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>I/H/O Layer개수</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>DNN</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<p>undefined	- test data 분류 작업
	- regularizer
	- hyperparameter normalize</p>
<ul>
  <li>By experiment ← train 중 parameter 결정</li>
  <li>data  : multimedia</li>
</ul>

<h2 id="1-decide-input-layers-node-number">1. Decide input layer’s node number</h2>

<ul>
  <li>By experiments, use domain knowledge</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/30.png" alt="30" /></p>

<h2 id="2-decide-output-layers-node-number">2. Decide output layer’s node number</h2>

<ul>
  <li>By experiments, use domain knowledge</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/31.png" alt="31" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/32.png" alt="32" /></p>

<ul>
  <li>구조만 보면 class가 몇 개인지 모른다</li>
  <li>class 수 = node 수
    <ul>
      <li>classification : output layer node의 activation 여부 확인</li>
    </ul>
  </li>
</ul>

<h2 id="3-decide-hidden-layers-node-number">3. Decide hidden layer’s node number</h2>

<ul>
  <li>By experiments, use domain knowledge</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/33.png" alt="33" /></p>

<h2 id="4-find-weight-using-training-algorithm">4. Find weight using training algorithm</h2>

<ul>
  <li>Use back-propagation algorithm. Supervised learning.</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/34.png" alt="34" /></p>

<h1 id="back-propagation-algorithm">Back-propagation Algorithm</h1>

<ul>
  <li>등장 배경 : NN → SVM →DNN
    <ul>
      <li>image가 낮인지 밤인지 예견하는 문제</li>
      <li>data를 잘 준비했어야 하는데 overfitting을 해결하지 못하여 SVM이 1990-2010년도 성행</li>
    </ul>
  </li>
  <li>train with back propagation algorithm
    <ul>
      <li>w값 arbitraily initialize → feed forward :
        <ul>
          <li><u>**w :**</u> $\epsilon \downarrow$<u>**방향으로 update**</u></li>
          <li>between prediction , ground truth value</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$y = f (\Sigma_i x_i w_{ij} + b)$
    <ul>
      <li>network의 구조가 결정되면 다음 layer의 node값에 bias를 더하는 함수</li>
      <li>perceptron 문제와 유사하게 발생 :
        <ul>
          <li>local minima</li>
          <li>many w → T 증가</li>
          <li>iterative하게 w 구하는 과정</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/35.png" alt="35" /></p>

    <p>모든 edge에 할당된 w에 대하여 backpropagation</p>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/36.png" alt="36" /></p>

<ul>
  <li>w update하면 iteration 반복 많아짐</li>
  <li>hidden 많아지면 update bigger</li>
  <li>
    <p>$E = \Sigma_k \frac 1 2 (z_k - t_k)^2$</p>

    <p>tk : ground truth</p>

    <ul>
      <li>제곱을 하고 2로 나누어준 이유 : perceptron처럼, 미분을 위해 제곱하고 1/2 *2하면 표현식이 간단해진다</li>
      <li>error 미분 : wij, wji 미분하여 update</li>
    </ul>
  </li>
</ul>

<p>chain rule</p>

<ul>
  <li>$\frac{\partial E}{\partial w_{kj}} = \frac{\partial E}{\partial z_{k}} \frac{\partial z_k}{\partial w_{kj}}  $</li>
  <li>$\frac{\partial E}{\partial w_{ji}} = \frac{\partial E}{\partial z_{k}} \frac{\partial z_k}{\partial w_{ji}}  = \frac{\partial E}{\partial z_{k}} \frac{\partial z_k}{\partial y_j}\frac{\partial y_j}{\partial w_{ji}}  $</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/37.png" alt="37" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/38.png" alt="38" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/39.png" alt="39" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/40.png" alt="40" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/41.png" alt="41" /></p>

<ul>
  <li>big NN의 한계 : hidden layer 제한 → 다양한 성능 제한</li>
  <li><strong>hidden layer수 증가 감소 이유 :???</strong>
    <ul>
      <li>output에서 input으로 backpropagate할 수록 더 많은 chain rule (Differentiation) 수행 → update양 감소</li>
    </ul>
  </li>
  <li>To update weights far from the output layer, more nodes and their derivatives are involved. Due to the chain rule, the amount of update becomes smaller.</li>
</ul>

<h2 id="activation-function-sigmoid">Activation function: sigmoid</h2>

<p>perceptron, SVM</p>

<ul>
  <li>input data (weight) - f(x) update
    <ul>
      <li>동일한 input에 대해 error 계산</li>
      <li>error가 각 iteration별로 작아짐</li>
    </ul>
  </li>
  <li>input data 바꾸면 - updated w도 new input data에 부적절할수도 있으니 fix해야 한다</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/42.png" alt="42" /></p>

<ul>
  <li>부적합</li>
  <li>SVM에서, nondifferentiable fn : hinge loss → 구간 나누어 미분 → 복잡해지는 미분 계산 과정 itreation
    <ul>
      <li>수학적으로 옳지는 않다??</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/43.png" alt="43" /></p>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/44.png" alt="44" /></p>

<ul>
  <li>back propagation example
    <ul>
      <li>Ex) 1st error = 0.298371109 
  2nd error = 0.291027924
  …
  …
  10000th error = 0.000035085</li>
      <li>output neurons after 10000th iteration : 
  0.015912196 (vs 0.01 target) 
  0.984065734 (vs 0.99 target)</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/45.png" alt="45" /></p>

<ul>
  <li>error : 역전파하면서 error 감소
    <ul>
      <li>10000th로 갈수록 0으로 error 수렴</li>
    </ul>
  </li>
  <li>output neuron : target에 근사</li>
</ul>

<h1 id="deep-neural-network">Deep Neural Network</h1>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/46.png" alt="46" /></p>

<ul>
  <li>raw data in real world : 영상 획득, microphone 녹음 등 ..</li>
</ul>

<p>DNN : Number of hidden layers</p>

<ul>
  <li>
    <h1 id="of-hidden-layers-leq-1--shallow-neural-network">of hidden layers $\leq 1$ → Shallow Neural Network</h1>
  </li>
  <li>
    <h1 id="of-hidden-layers-geq-2--deep-neural-network">of hidden layers $\geq 2$ → Deep Neural Network</h1>
  </li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/47.png" alt="47" /></p>

<h2 id="dnn-training">DNN Training</h2>

<h3 id="vanishing-gradient-problem">Vanishing gradient problem</h3>

<p>Problem with non-linear activation</p>

<ul>
  <li>As errors are back propagated, the gradient vanishes</li>
  <li>Derivatives of sigmoid are 0~0.25. As these are multiplied at multiple layers, they become smaller and smaller</li>
  <li>$w_{ji} = w_{ij} -\eta \frac {\partial E}{\partial w_{ji}}$: as $\frac {\partial E}{\partial w_{ji}}$becomes smaller, $w$ is not well updated, especially for the layers far from the output layer</li>
</ul>

<p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/48.png" alt="48" /></p>

<ul>
  <li>Typically requires lots of labeled data
    <ul>
      <li>Collecting data is time consuming and expensive (time, price)</li>
      <li>but time 소모 증가, 비용 증가
        <ul>
          <li>data collection, tagging, labeling</li>
        </ul>
      </li>
      <li>2010년도 DNN의 발전배경  :
        <ul>
          <li>Big data → 수집 용이</li>
          <li>GPU (HW Support)</li>
          <li>Algorithm적 발달</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><u>_**Overfitting problem**_</u>
    <ul>
      <li>When training data is not sufficient, model only can handle the training data well (poor performance at test time)</li>
      <li>data 변화 요인에 w 학습하고 , 다양한 test에 대해서도 적용</li>
    </ul>

    <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/49.png" alt="49" /></p>
  </li>
  <li>ground truth sampling → data에 fit하여 정답과 일치하도록</li>
  <li>overfitting : regression, classification 시 정답을 보지 않아도 train well됨을 확인함</li>
  <li>Get stuck in <strong>local minima : iteration시 유의</strong>
    <ul>
      <li>Problem even with enough training data</li>
      <li>solution : 초기값을 randomly setting하고 train을 많이 하여 그 avearge를 추출한다
        <ul>
          <li>test set에 대해 일반적으로 성능 좋아짐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Train Set 에서의 문
    <ul>
      <li>input data : raw data→ input layer : x1, x2</li>
      <li>state of the nature $\in$ real world</li>
      <li>학습 data로 model을 만들지만 prediction-ground truth가 0이라고 하여도 좋은 model인지 아닌지 확신할 수 없다.
        <ul>
          <li>사실 정답을 알 리가 없다 : 그 정답으로 추출된 제한된 관찰에 의해 얻어진 학습 data로 model을 구한 것이기에</li>
        </ul>
      </li>
      <li>sol <strong>→ train data를 변화시키며 model이 얼마나 안정된 결과를 보이는지 (test data를 변화시키기도 해보자)</strong></li>
    </ul>
  </li>
  <li>Vanishing gradient problem
    <ul>
      <li>ReLU(Rectified Linear Unit)
        <ul>
          <li>$\max(0,x)$ gradient update</li>
        </ul>
      </li>
      <li>Layer-wise training
        <ul>
          <li>
            <p>충분히 학습되었다면 건너뜀</p>

            <p><img src="/assets/img/2023-05-17-8.-ANN-Artificial-Neural-Network-(1).md/50.png" alt="50" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Requires <strong>lots</strong> of labeled data</li>
  <li><strong>Overfitting</strong> problem</li>
  <li>Get stuck in <strong>local minima</strong>
    <ul>
      <li>Mitigated by increasing data and computation power</li>
    </ul>
  </li>
  <li>시간 소모 :
    <ul>
      <li>depend on performance of HW</li>
      <li>w update : vanishing gradient → activation fn 변화</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="ML" /><summary type="html"><![CDATA[ANN Introduction]]></summary></entry><entry><title type="html">7. k-Nearest Neighbor</title><link href="http://localhost:4000/7.-k-Nearest-Neighbor" rel="alternate" type="text/html" title="7. k-Nearest Neighbor" /><published>2023-05-10T00:00:00+09:00</published><updated>2023-05-10T00:00:00+09:00</updated><id>http://localhost:4000/7.-k-Nearest-Neighbor</id><content type="html" xml:base="http://localhost:4000/7.-k-Nearest-Neighbor"><![CDATA[<h1 id="k-nearest-neighbor-classifier">k-Nearest Neighbor Classifier</h1>

<ul>
  <li>perceptron : linear classifier</li>
  <li>SVM : linear, nonlinear classifier
    <ul>
      <li>given data → 분류하는 hyperplane를 구한다.</li>
      <li>GD로 계산한다 : iteration 수천~수백 epoch 연산을 수행한다</li>
      <li>(1) phi fn으로 고차원 mapping data 처리 가능
        <ul>
          <li>kernel trick ($\epsilon$→0)</li>
        </ul>
      </li>
      <li>(2) soft margin</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/0.png" alt="0" /></p>

<ul>
  <li>Store all training samples $(x_i, y_i)$ - 모든 데이터 저장
    <ul>
      <li>학습 data 저장하면 끝이다 (extra data task 불필요)</li>
    </ul>
  </li>
  <li>Nearest Neighbor classifier
    <ul>
      <li>Given a test sample $x_t$, locate the nearest training sample $(x_{n1}, y_{n1})$,</li>
      <li>then assign $y_{n1}$as the class label of $x_t$</li>
      <li></li>
    </ul>
  </li>
  <li>k-Nearest Neighbor classifier
    <ul>
      <li>Given a test sample $x_t$, locate the k-nearest training samples $(x_{n1}, y_{n1}), …,(x_{nk}, y_{nk}) $ then assign <strong>majority class label</strong> of $y_{n1}, … y_{nk}$ to $x_t$
        <ul>
          <li><strong>majority class label</strong>  : majority voting, nearst sample labeling algorithm</li>
        </ul>
      </li>
      <li>Take mean of , if they are real valued $\hat{f} = \frac 1 k \Sigma_{i=1}^{k} f(x_{ni})$</li>
      <li>Also called as <strong>Instance</strong> based learning</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/1.png" alt="1" /></p>

<ul>
  <li>test 시점에서 data 들어오면 해당 data와 near sample 판단 : <strong>sample간 거리 계산</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$L^2$-norm : $\sqrt{\Sigma_{d=1}^{D}</td>
              <td>x_{td} - x_{nd}</td>
              <td>^2}$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>test data에 대해 거리를 계산할 때 test sample과 near한지 distance 계산한다.</li>
    </ul>
  </li>
  <li>sample dimension이 증가하면 → calculation cost 증가
    <ul>
      <li>모든 sample들끼리 거리를 계산하면 - dimension 증가되면</li>
    </ul>

    <p>(해결) kNN Optimization</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 학습 시 계산 적게 storage 크게 : 어떻게 save하는가?
  - test 시 계산 많이 :  어떻게 줄이는가?
</code></pre></div>    </div>
  </li>
  <li>When to consider
    <ul>
      <li>Vector features</li>
      <li>~Less than 20 attributes (=20 dim)</li>
      <li>Sufficient amount of training data</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/2.png" alt="2" /></p>

<ul>
  <li><strong>Advantages</strong>
    <ul>
      <li><u>**Training is very fast :**</u> feature extraction &amp; save</li>
      <li>Learn complex target functions</li>
      <li>Don’t lose information</li>
    </ul>
  </li>
  <li><strong>Disadvantages</strong>
    <ul>
      <li>Slow at query time ( ⇒ test time)
        <ul>
          <li><strong>train 에서의 연산이 많은 것이 좋을까?</strong> 아니면 test 에서의 연산이 많은 것이 좋을까?
            <ul>
              <li>test하기 전 enough time으로 저장 (sample 그대로 저장)</li>
              <li>train offline / test online,offline</li>
              <li><strong>so→ test 시점 연산이 적은 것이 유리함</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Requires large storage</li>
      <li>Not robust against irrelevant <strong>attributes or outliers</strong>
        <ul>
          <li>SVM, Perceptron : boundary에 크게 영향이 없음</li>
          <li>kNN : test sampel decision에 변화 가능함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="distance-metric">Distance Metric</h1>

<ul>
  <li>Search operation is expensive with high dimensions</li>
</ul>

<h2 id="distance">Distance</h2>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/3.png" alt="3" /></p>

<ul>
  <li>모든 classify / regress에서 중요함
    <ul>
      <li>decision tree : nominal data → distance 불필요</li>
      <li>각 feature 값들이 서로 다른 w를 가질 수 있음
        <ul>
          <li>ex. age, height</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>distance = 1/similarity</li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/4.png" alt="4" /></p>

<p>feature vector하나 dimension은 의미가 없으며, 전체가 모여 압축된 형태로 표현된다.</p>

<h2 id="equations-of-selected-distance-functions">equations of selected distance functions</h2>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/5.png" alt="5" /></p>

<ul>
  <li></li>
</ul>

<h2 id="value-difference-metric-vdm">Value difference metric (VDM)</h2>

<ul>
  <li>attribute class 통해 판단 → 동일 class 속하는 것이 관찰되면 attribute가 더 가깝다고 본다.
    <ul>
      <li>ex. R-B가 더 많이 같은 class를 가지고 있으면 → R-B &gt; R-G</li>
    </ul>
  </li>
  <li>Providing distance measurements for nominal attributes
    <ul>
      <li>$vdm_a(x,y) = \Sigma_{c=1}^C (\frac{N_{a,x,c}}{N_{a,x}}-\frac{N_{a,y,c}}{N_{a,y}})^2$</li>
      <li>𝑵𝒂,𝒙 : # times attribute a had value x
  𝑵𝒂,𝒙,𝒄: # times attribute a had value x and class was c
  𝑪 : # output classes</li>
      <li>a : color / x : big / y : medium, small ??</li>
    </ul>
  </li>
  <li>Two values are considered closer if they have more similar classifications, i.e., if they have more similar correlations with the output classes</li>
</ul>

<h1 id="problem-with-euclidean-distance">Problem with Euclidean distance</h1>

<ul>
  <li>High dimensional data
    <ul>
      <li>dimension : color, length, weight…등의 data attribute</li>
      <li>더 많은 attribute를 추가할수록 performance 상승</li>
      <li>그러나 너무 많이 feature/ attribute 증가시키면 dim이 너무 많이 증가하여 curse of dimensionality에 빠질 수 있다
        <ul>
          <li>data가 고차원일수록 취급이 어려움
  data에 관련하여 알아야 할 정보가 많은데 잘 활용치 못하면 classifier 성능 저하됨</li>
        </ul>
      </li>
      <li>(Number of samples - available info) 양이 많고 + 정확한 정보라면 dimension이 높아도 괜찮다.</li>
    </ul>
  </li>
  <li>Can produce counter-intuitive results</li>
  <li>Shrinking density – sparsification effect
    <ul>
      <li>data dimension을 낮추어 처리하면 data가 sparse한 형태</li>
    </ul>
  </li>
  <li>d가 같다고 data feature를 잘 반영하는지에 대해서는 잘 고려해봐야 함
    <ul>
      <li>각 feature dimesion이 data significance를 나타냄 → feature거리를 측정하는 것이 유사성과 차이점을 덜 반영할 수도 있음</li>
      <li>binary feature : 과연 d가 동일한 값이라고 data feature를 잘 나타내는 것일까?</li>
      <li>1 1 1 1 1 1 1 1 1 1 1 0
  0 1 1 1 1 1 1 1 1 1 1 1
  d = 1.4142</li>
      <li>1 0 0 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0 0 0 1
  d = 1.4142</li>
    </ul>
  </li>
  <li>hamming distance
    <ul>
      <li>각 bit 사이 같은/다른 bit 나타나는지 판단</li>
    </ul>
  </li>
  <li>histogram intersection
    <ul>
      <li>
        <p>$\Sigma_i \min(h_{1i}, h_{2i})$</p>

        <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/6.png" alt="6" /></p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="behavior-in-the-limit">Behavior in the limit</h1>

<ul>
  <li>성능
    <ul>
      <li>kNN ($\epsilon$ up) &lt; optimal classifier ($\epsilon$ down)</li>
    </ul>
  </li>
  <li>$\epsilon^*(x) $ <strong>:</strong> Error of optimal prediction</li>
  <li>$\epsilon_{NN}(x) $ : Error of nearaest neighbor</li>
</ul>

<p>Theorem :</p>

\[\lim_{n\rightarrow \inf} \leq 2\epsilon^*\]

<ul>
  <li>proof:
    <ul>
      <li>$p_+$ : data가 (+)일 확률, $p_{NN\in(-)}$ : nearest neighbor이 (-)일 확률</li>
      <li>$\epsilon_{NN} = p_+p_{NN\in(-)}+p_-p_{NN\in(+)} = p_+(1-p_{NN\in(+) })+(1-p_+)p_{NN\in(+)} $
        <ul>
          <li>$\epsilon_{NN} \sim\epsilon_{+} $ : Nearest Neighbor과 optimal한 sample의 결과가 동일하다</li>
        </ul>
      </li>
      <li>$\lim_{n \rightarrow \infty} p_{NN\in (+)} = p_+$$lim_{n \rightarrow \inf} p_{NN\in (+)} = p_+$</li>
      <li>$\lim_{n \rightarrow \inf} p_{NN\in (-)} = p_-$</li>
      <li>$\lim_{n \rightarrow \inf} \epsilon_{NN} = p_+(1-p_+) + (1-p_+)p_+ = 2p_+(1-p_+) = 2\epsilon^<em>(1-\epsilon^</em>)\leq2 \epsilon^*$
        <ul>
          <li>$2p_+(1-p_+)$
            <ul>
              <li>prediction : (+) or (-)</li>
              <li>$p_+$가 맞으면 $(1-\epsilon^<em>)$ 맞고 $\epsilon^</em>$ 틀림</li>
              <li>$p_+$가 맞으면 $(1-\epsilon^<em>)$ 틀리고 $\epsilon^</em>$ 맞음</li>
            </ul>
          </li>
          <li>$\epsilon^* \in [0,1]$</li>
        </ul>
      </li>
      <li>NN Classifier can have up to twice as much error of <strong>optical error</strong>
        <ul>
          <li>= Bayesian Classifier</li>
          <li>Sampling할 때 특정 d보고 sample → 전체 population know</li>
          <li>→ 전체 population 정보가지고 classifier를 생성하면 classifier error : optimal classification error이고</li>
          <li>우리가 얻을 최소의 error → optimal classifier</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Theorem :</p>

\[\lim_{n\rightarrow \infty, k \rightarrow \infty, \frac k n \rightarrow 0 } \leq \epsilon^*\]
  </li>
</ul>

<h1 id="standardization">Standardization</h1>

<ul>
  <li>Transform raw feature values into z-scores $z_{ij} = \frac{x_{ij} - \mu_j}{\sigma_j}$
    <ul>
      <li>$x_{ij}$ is the ith sample and jth feature (dimension)</li>
      <li>$\mu_j$ is the average of all for feature</li>
      <li>$\sigma_j$ is the standard deviation of all for feature</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/7.png" alt="7" /></p>

<h1 id="efficient-searching">Efficient searching</h1>

<ul>
  <li>sample 주변을 확인해야 함 : 어떠한 data 주변에 존재할지</li>
  <li>KD trees
    <ul>
      <li>
        <p>n개 KD Tree 구성하면 - $\epsilon \downarrow$ : 각 class score, $w_{sum}$계산</p>

        <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/8.png" alt="8" /></p>
      </li>
    </ul>
  </li>
  <li>Choose dimension</li>
  <li>Choose pivot (median)</li>
  <li>Split data, repeat</li>
  <li></li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/9.png" alt="9" /></p>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/10.png" alt="10" /></p>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/11.png" alt="11" /></p>

<h1 id="choosing-k">Choosing k</h1>

<ul>
  <li>Choosing the value of k:
    <ul>
      <li>If k is too small, sensitive to noise points</li>
      <li>If k is too large, neighborhood may include points from other classes</li>
    </ul>
  </li>
  <li>Rule of thumb:
k = sqrt(N)
N: number of training samples</li>
  <li>Use N fold cross validation – Pick k to minimize the cross validation error</li>
  <li>For each of N test example
    <ul>
      <li>Find its k nearest neighbors</li>
      <li>Make a classification based on these k neighbors</li>
      <li>Calculate classification error</li>
      <li>Output average error over all examples</li>
    </ul>
  </li>
  <li>Use the k that gives lowest average error on the training data
    <ul>
      <li>이론적으로 $k \uparrow$이면 smoother해짐</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/12.png" alt="12" /></p>

<ul>
  <li>Bayes-optimal boundary given true generating model
    <ul>
      <li>ideal case : $k, n \rightarrow \infty$, $\frac k n \rightarrow 0$, $\epsilon^* \leq \epsilon_{kNN}\leq2\epsilon^*$</li>
    </ul>

\[\lim_{n\rightarrow \infty, k \rightarrow \infty, \frac k n \rightarrow 0 } \leq \epsilon^*\]

    <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/13.png" alt="13" /></p>
  </li>
  <li>As number of training <u>samples</u> $\rightarrow \infty$, and k becomes large, k-Nearest Neighbor classifier shows performance as good as that of Bayes classifier</li>
</ul>

<h1 id="cross-validation">Cross-validation</h1>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/14.png" alt="14" /></p>

<ul>
  <li>train error가 낮아지는게 무작정 좋지는 않을 수 있다 (overfitting)</li>
</ul>

<h1 id="condensing">Condensing</h1>

<ul>
  <li>
    <p>Aim is to reduce the number of training samples</p>

    <p>더 작은 dataset으로의 압축</p>
  </li>
  <li>Retain only the samples that are needed to define the decision boundary</li>
  <li>Decision Boundary Consistent – a <strong>subset</strong> whose nearest neighbor decision boundary is identical to the boundary of the entire training set
    <ul>
      <li>전체 original data와 동일한 boundary 구해짐</li>
    </ul>
  </li>
  <li>Minimum Consistent Set – the <strong>smallest subset</strong> of the training data that correctly classifies all of the original training data
    <ul>
      <li>가장 작은 Sample sel</li>
    </ul>
  </li>
  <li>
    <p>Original data</p>

    <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/15.png" alt="15" /></p>

    <ul>
      <li>decision boundary 구성 Sample만을 남겨 이 data만을 남긴다.</li>
      <li>2,3개 씩 저장해도 boundary가 유지된다.</li>
      <li>전체 Dataset을 활용해도 decision boundary는 동일하게 구해진다.</li>
    </ul>
  </li>
  <li>
    <p>Condensed data</p>

    <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/16.png" alt="16" /></p>
  </li>
  <li>
    <p>Minimum Consistent Set</p>

    <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/17.png" alt="17" /></p>
  </li>
</ul>

<h2 id="condensed-nearest-neighbor-cnn">Condensed Nearest Neighbor (CNN)</h2>

<ul>
  <li>iteration 최소 data로 errorless 구하기??
    <ol>
      <li>Initialize subset with a single (or k) training example</li>
    </ol>
    <ol>
      <li>하나의 Data를 임의로 추출
        <ol>
          <li>Classify all remaining samples using the subset, and transfer any incorrectly classified samples to the other subset</li>
        </ol>
      </li>
      <li>그 Data를 이용하여 NN → $\epsilon$이 나오는 임의의 Data 선택
        <ol>
          <li>Return to 2 until no transfers occurred or the subset is full</li>
        </ol>
      </li>
      <li>data, error 구하기</li>
    </ol>
  </li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/18.png" alt="18" /></p>

<p>→ 초기 Data 선택에 따라 decision boundary 변화</p>

<ul>
  <li>kNN → decision boundary
    <ul>
      <li>어떤 group에 test data 속하는지 확인</li>
    </ul>
  </li>
</ul>

<h1 id="condensation">Condensation</h1>

<ul>
  <li>Each cell contains one sample, and every location within the cell is closer to that sample than to any other sample.</li>
  <li>A <strong>Voronoi diagram</strong> divides the space into such cells.
    <ul>
      <li>구획으로 나누고 boundary에 영향 없는 Sample을 제거하는 방향</li>
    </ul>
  </li>
  <li>Every query point will be assigned the classification of the sample within that cell. The decision boundary separates the class regions based on the 1-NN decision rule.</li>
  <li>Knowledge of this boundary is sufficient to classify new points.</li>
  <li>The boundary itself is rarely computed; many algorithms seek to retain only those points necessary to generate an identical boundary.</li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/19.png" alt="19" /></p>

<ul>
  <li>data 주어지면 그로부터 얻는 1NN boundary가 유일하게 결정됨
    <ul>
      <li>→ train data 전부 저장하지 않아도 boundary만 저장하면 됨</li>
    </ul>
  </li>
</ul>

<h2 id="voronoi-diagram-구성하는-방법">Voronoi Diagram 구성하는 방법</h2>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/20.png" alt="20" /></p>

<ul>
  <li><strong>Delaunay triangulation (Delone triangulation)</strong> for a given set P of discrete points is a triangulation DT(P) such that no point in P is inside the <strong>circumcircle</strong> of any triangle in DT(P)</li>
  <li>Circumcircle (circumscribed circle) of a polygon is a circle that passes through all the vertices of the polygon</li>
  <li>어떠한 점도 해당 Circle 내 들어가지 않도록, 다각형을 둘러싼 원 형성
    <ul>
      <li>→세 점을 둘러싼 원, 원 내부에 주어진 점을 포함하면 안 되는 형태로</li>
    </ul>
  </li>
  <li>Avoid sliver triangles. (maximize angles of triangles) 
예각삼각형을 피하고, 각도 최대화
    <ul>
      <li>
        <p>Delaunay triangulation is not unique</p>

        <p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/21.png" alt="21" /></p>
      </li>
    </ul>
  </li>
  <li>Circumcenters of Delaunay triangles are the vertices of the Voronoi diagram</li>
  <li>If two triangles share an edge in the Delaunay triangulation, their circumcenters are to be connected with an edge in the Voronoi tesselation</li>
  <li>방법 : delaunary triangle 만들고 → circumcircle의 가운뎃점 pt → centered point 연결</li>
  <li>Voronoi Diagram의 최종 목표 : 모든 영역 안에 임의의 지점은 그 안의 Sample point와 최단 거리를 갖는 영역으로 정의함</li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/22.png" alt="22" /></p>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/23.png" alt="23" /></p>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/24.png" alt="24" /></p>

<ul>
  <li>각 sample point의 class에 따라, 전체 영역의 class 결정</li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/25.png" alt="25" /></p>

<ul>
  <li>test Data 들어오면, 이를 포함한 voronoi diagram이면 class 결정</li>
</ul>

<p><img src="/assets/img/2023-05-10-7.-k-Nearest-Neighbor.md/26.png" alt="26" /></p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="ML" /><summary type="html"><![CDATA[k-Nearest Neighbor Classifier]]></summary></entry><entry><title type="html">빅콘테스트 후기 (2022년 이노베이션 분야)</title><link href="http://localhost:4000/%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0-(2022%EB%85%84-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B6%84%EC%95%BC)" rel="alternate" type="text/html" title="빅콘테스트 후기 (2022년 이노베이션 분야)" /><published>2022-12-30T00:00:00+09:00</published><updated>2022-12-30T00:00:00+09:00</updated><id>http://localhost:4000/%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0-(2022%EB%85%84-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B6%84%EC%95%BC)</id><content type="html" xml:base="http://localhost:4000/%EB%B9%85%EC%BD%98%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0-(2022%EB%85%84-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EB%B6%84%EC%95%BC)"><![CDATA[<h1 id="의미없는-경험은-없다">의미없는 경험은 없다!</h1>

<ul>
  <li><strong>빅콘테스트란?</strong> 국내 최대 규모의 데이터 사이언스 경연 대회이다. 신한카드, LG U Plus, Finda 등 20여개에 이르는 다양한 참여사들이 주관하며, 그에 따라 참가자의 수준 또한 상당히 높은 편이다</li>
  <li>빅콘테스트에는 <strong>데벤져스 DAVANGERS 의 이름으로 팀을 이루어 참여했다</strong>.
    <ul>
      <li>팀원들 모두가 각기 다양한 배경과 경험을 토대로 지금까지 공부해 왔으며 모인 모습이 마치 어벤져스같다는 의미에서 데이터 + 어벤져스를 합해 DAVENGERS라는 이름을 짓게 되었다.</li>
      <li>
        <p>팀원들은 경영&amp;빅데이터 2명 (정현, 경주), 수학&amp;빅데이터 1명 (경훈), 경영&amp;컴퓨터공학 1명(혜나), 그리고 컴퓨터공학 1명(규환) 총 다섯명으로 구성되어 있다. 지금 봐도 화려한 라인업이다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/0.png" alt="0" /><em>우리들의 포토이즘</em></p>
      </li>
    </ul>
  </li>
  <li>
    <p>이름이 정해지는 순간</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/1.png" alt="1" /><em>데이터분석 + 어벤져스 = 데벤져스!</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/2.png" alt="2" /><em>우리의 핵심 모토</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/3.png" alt="3" /></p>
  </li>
</ul>

<h2 id="빅콘테스트-팀-합류">빅콘테스트 팀 합류</h2>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/4.png" alt="4" /><em>팀장 하정현씨의 모집글</em></p>

<ul>
  <li>팀원들은 서강대학교 데이터사이언스학회인 INSIGHT에서 조직했다. 나는 당시 신입기수였던 8기였고, 다른 팀원분들은 7기 선배 기수로서 이미 한 텀동안 데이터 분석 경험이 있는 분들이었다. 데이터 분석 특성상 데이터를 분석하고 이를 바탕으로 인사이트를 도출한 이후, 커뮤니케이션 전략까지 설계해야 한다. 비단 회사에서도 마찬가지로, 팀의 목표에 따라 데이터를 철저히 분석하고 이후 경영팀과 상의해야 한다. 팀플레이에도 익숙한 친구들이라고 생각했고, 학회에 들어가고 나서도 적극적으로 참여하던 친구들이었기에 주저 없이 합류했다. 사실 주제 자체도 재밌어보이는 것이 컸다.</li>
</ul>

<h2 id="주제설명">주제설명</h2>

<ul>
  <li>빅콘테스트에는 이노베이션 분야(신한카드) / 퓨처스 부문(핀다) / 챔피언 부문(엘지 유플러스) 3가지의 분야가 존재한다.
    <ul>
      <li>분야마다 참여사가 다르고, 그에 따라 시상금도 다르고, 주제도 다르고, 원하는것도 달랐기에 주제를 정하는 것이 제일 중요했다. 빅콘테스트 공식 사이트에 내용이 엄청 자세해서 사이트 꼼꼼히 보고 토론했다. 경쟁률도 중요하지만 주제 별 도메인이 너무나도 달랐기에 신중해야하는 순간이었다. 챔피언 부문의 경우에는 비슷한 프로젝트로 수상한 선배들도 있고, 이노베이션에도 비슷한 프로젝트로 수상한 선배들이 있었기에 무엇을 선택해도 0에서 시작하는 환경은 아니었다.</li>
    </ul>
  </li>
  <li>긴 토론 후, <u>**신한카드**</u>에서 주관하는 ‘<u>**MZ세대가 떠나는 친환경 ESG 제주여행 루트짜기’**</u>의 주제에 참여했다. 아이디어와 인사이트를 활용한, 데이터 기반의 전략 도출이 중요한 분야였고 데벤져스 팀의 강점이 드러날 수 있으리라 생각하여 결정하게 되었다.
    <ul>
      <li><strong>(선정 이유) 여행 관련 데이터라 재밌게 할 수 있을 것 같았고, 모델링과 더불어 스토리라인이 잘 드러나는 분야였기에 흥미로웠다.</strong></li>
      <li><strong>(다른 분야와의 비교)</strong> 제주도 여행뿐만 아니라 ESG를 기반한 인덱스를 만드는 느낌이라 재미가 있어 보였다. 이에 반해, 퓨처스 챔피언분야는 방법이 이미 정해져 있고 모범답안이 존재하는 느낌으로 느껴졌다. 치별화된 결과를 만들만했던 건 이노베이션 분야였다.</li>
      <li>신한카드가 데이터 및 IT에 큰 흥미를 가지고 사업을 확장하는 모습도 결정의 주안점에 있었다.</li>
      <li>주최사는 제주관광공사/신한카드이며, 데이터 제공사 : 신한카드/제주관광공사/산림빅데이터/ Leeds University이다.</li>
    </ul>
  </li>
</ul>

<h1 id="진행">진행</h1>

<h2 id="0-매일매일-가을을-갈아넣은-빅콘">0. 매일매일 가을을 갈아넣은 빅콘</h2>

<ul>
  <li>경훈이형은 회사를 다니고 정현/경주/혜나/규환은 학교에 다니면서 학회를 하는 스케줄이었다. 주말을 모두 고정 회의시간으로 정했고 일반 주중에도 남는 시간에 만나서 진행하기로 결정했다. 처음 조직된 상황으로부터 3주밖에 시간이 남지 않아서 데이터 ~ 모델링 ~ 경영 전략에 이르기까지 빡센 일정이었다.</li>
  <li>
    <p>주로 만남은 (1) 바오로관 라운지, (2) 스타벅스-신촌 / 서강대학교정문, (3) 인사이트 세션 교실에서 이루어졌다. 당시 평범한 공대생이었던 나는 바오로관 라운지가 어딘지 몰랐는데, 앞으로의 대학생활에 있어 영혼의 안식처가 될 줄은 몰랐다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/5.png" alt="5" /><em>파라가 어딘지 몰랐던 시절</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/6.png" alt="6" /><em>인사이트 세션 다음날 파라에서 시켜먹은 엽떡!</em></p>
  </li>
</ul>

<h2 id="1-데이터-정제-및-수집">1. 데이터 정제 및 수집</h2>

<ul>
  <li>사실 데이터가 너무 많아서 이노베이션 분야로의 참여를 주저했었다. 지역별 탄소를 어떻게 계산할지부터 위도 경도가 담긴 데이터까지, 처음에 어떻게 시작해야할지에 대하여도 감이 잘 잡히지 않았다.
    <ol>
      <li>데이터 수정 및 정제
        <ul>
          <li>신한카드에서 직접적으로 제공해 준 데이터들은 물론 엑셀에 잘 설명되어 있었지만, 우리가 팀플레이하기에는 이들을 다 암기하기는 어렵겠다 생각했다. 그래서 기존의 이름으로부터, T4, C5 이런식으로 데이터를 간략화하여 명명하도록 정해두었다. 예를 들어, <code class="language-plaintext highlighter-rouge">t6 → t6_jeju_sns_keyword.csv</code>, <code class="language-plaintext highlighter-rouge">t7_jeju_sns_emotion_keyword.csv</code> 등으로 이해하기 쉽게 제목을 변경했다.</li>
          <li>데이터의 row는 실제 현업의 데이터였다보니 그 양이 상당히 많았다. <code class="language-plaintext highlighter-rouge">t1</code>의 경우 <code class="language-plaintext highlighter-rouge">316174개,</code> <code class="language-plaintext highlighter-rouge">t4</code>의 경우 <code class="language-plaintext highlighter-rouge">103만개</code> 등 각각에 대하여 address들을 mapping해야만 했다. 법정동 정의서 기반으로 진행했다.</li>
        </ul>
      </li>
      <li>주소매칭 후 데이터 통합
        <ul>
          <li>처음에 카카오 혹은 네이버지도에서 제공하는 도로명주소 변환API를 활용하면 DataFrame끼리 잘 merge되리라고 생각했다. 그러나 주소가 안 채워진 것들을 삭제하고 나니 컬럼 수가 반이 된 거 같아 무언가 이상하다 생각했다. API를 돌리니 주소가 똑같이 나와 다시 몇번씩 해봤는데도 같은 결과가 나왔다.</li>
          <li><code class="language-plaintext highlighter-rouge">t5</code> 파일의 경우 ‘기존의 도로명 주소’를 다시 카카오맵 API를 통해 ‘정제된 도로명 주소’로 변환하는 것이 목표였는데, 몇몇 컬럼은 도로명 주소가 검색이 안 되어서 변환되지 않았다.</li>
          <li>API Request 사용량이 매일 정해져 있어 일일 제한수만큼만 가능했다. <a href="https://haries.tistory.com/9">카카오맵 API 사용 블로그</a>를 참조하여 예외처리를 통해서 걸렀었는데 다시 해보려하니까 keyError 잘 안되어서 찾아보니 몇개 안 변환했는데도 불구하고 리밋에 도달한 상태였다.</li>
          <li>→ 카카오 API하는 작업도 생각보다 오래 걸리고, 에러들을 일일히 확인하기도 어려웠고, 애초에 몇만개의 컬럼을 프로세싱하기는 어려웠다. 그러나 주소가 변환되어야 각각에 일치하는 것끼리 데이터 row별로 일치시켜 통일해 진행할 수 있었기에 진행했다.</li>
        </ul>
      </li>
      <li>데이터 크롤링
        <ul>
          <li>데이터 크롤링으로부터 탄소 발자국 알고리즘의 설계까지 10월 3일 월요일날 하기로 결정했다.</li>
          <li>비짓제주, 제주관광공사, 네이버플레이스 등으로부터, 여행지 목록 데이터, 여행지 이동 데이터를 산출하는 것이 목표이다.</li>
          <li>주변관광지/음식점/숙소까지 크롤링해서 합친 비짓제주관광지데이터를 하나로 통합했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="2-여행관련-탄소발자국-계산기-구축">2. 여행관련 탄소발자국 계산기 구축</h2>

<ul>
  <li>**<기존 탄소="" 발자국="" 계산기의="" 한계="">**
</기존>    <ul>
      <li>기존에 탄소발자국 계산기들이 있지만, 이용한 전기 사용량 등 일반인들이 구체적으로 기억하고 있기 어려운 값들을 정확하게 입력 값에 넣어야 탄소배출량이 계산되는 형태였다. 따라서 우리가 구축하고자 하는 탄소발자국 계산기는, 정확한 수치를 알고 있지 않은 일반인들도 자신이 이용한 숙소 형태나 음식점 정도만 선택한다면 대략적인 탄소 배출량을 알 수 있게 해주는 계산기이다. 또한, 여행이라는 특정 상황에서의 탄소발자국을 계산한다는 점에서 의미가 있다.</li>
      <li>우리는 실제 사용성을 고려하여 엑셀이 아닌, <strong>배포/관리/시각화가 용이한</strong> <strong>파이썬 기반의 웹 어플리케이션 Streamlit</strong>을 이용하여 계산기를 구현했다. <strong>계산기 중간중간에 탄소배출량을 절감하는 팁</strong>을 추가해 친환경 여행을 유도하였다. 예를 들어, <strong>렌터카 차종을 선택</strong>할 때는 탄소배출량이 적은 연료타입을 알려주고, <strong>숙소를 선택</strong>할 때는 호텔의 탄소배출량이 높다는 사실을 강조하는 식이다.</li>
    </ul>
  </li>
  <li>참조한 링크
    <ul>
      <li>다양한 블로그 등에 사전에 구현된 <a href="https://hwgrn.github.io/howgreenfoodprintcalculator/">음식 탄소발자국 계산기</a>, <a href="https://www.ibm.com/docs/ko/tririga/10.5.2?topic=calculations-carbon-footprint-calculation-formulas">IBM 탄소발자국 계산공식</a>, <a href="http://116.67.44.68/fcr_web/resources/carbon_calc/html/main/CTC_03_01.html">탄소나무계산기</a> 등과 같은 웹 공개 자료와, London 영국 의회에서 발행한 <a href="https://www.londoncouncils.gov.uk/node/38613">보고서</a>나 논문들을 추가적으로 또한 리서치하여 반영하고자 했다. 세번째의 산림청, 국립산림과학원 탄소나무 계산기 참조를 참조하여 웹으로 어느정도 비슷하게 구현하리라는 목표를 세우고 진행했다.</li>
    </ul>
  </li>
  <li>주요 역할 분담은 다음과 같다.
    <ul>
      <li>정현 - 데이터 전처리 (주소 기반), 탄소계산기/관광업 : 데이터 수집, 로직 설계</li>
      <li>경훈 - 데이터 전처리 (주소 기반), 탄소계산기/요식업 : 로직 검증, 탄소계산기/관광업 : 데이터 수집, 로직 설계, 여행 알고리즘 설계</li>
      <li>경주 - 탄소계산기/교통업 : 데이터 수집, 로직 설계, 추가 비짓제주 및 네이버 지도 데이터 크롤링</li>
      <li>혜나 - 탄소계산기/요식업 : 데이터 수집, 로직 설계, 탄소계산기/교통업 : 로직 검증, 기타 로직 검증</li>
      <li>규환 - 프로젝트 웹 페이지 구현, Streamlit을 활용한 탄소 발자국 계산기 구현, 로직 검증, 여행객 페르소나 헥사곤 구현
        <ul>
          <li>탄소 발자국 계산기의 경우 음식, 관광 등 각자 분야별 나누어서 데이터분석 후 로직구현을 하도록 정리했다. 배출 계산 단계가 복잡하였기 때문에, 각각에 대해서 person처럼 정리하거나, 사칙연산으로 Streamlit 상에서 구현할 수 있도록 했다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="여행-카테고리별-구현">여행 카테고리별 구현</h3>

<ul>
  <li><strong>(1) 음식 분야</strong>
    <ul>
      <li>혜나가 음식 분야를 먼저 완성하여 streamlit으로 초안을 만드는 데에 들어갔다.</li>
      <li>한국일보에서 개발해 둔 [<한끼밥상 탄소계산기="">](https://interactive.hankookilbo.com/v/co2e/), [다른 탄소발자국 계산기](https://foodfootprint.nl/en/foodprint-finder/)를 바탕으로 교차검증하여 없는 식품에 대하여 리서치하거나 산출된 배출량에 대하여 확인 후 값을 나오도록 설계했다.</한끼밥상></li>
      <li>기존의 탄소배출량 계산기와 달리, 사용자가 정확한 음식 재료를 몰라도 쉽게 계산할 수 있는 계산기를 개발할 수 있었다.</li>
      <li>데이터의 경우 <strong>제주 가맹점 데이터에 있는 음식점 목록</strong>과 <strong>식품별 탄소배출량 데이터</strong>를 이용했다. <strong>추가적으로,</strong> 음식점별 메뉴 정보를 얻기 위해 <strong>네이버 지도를 크롤링</strong>했다.</li>
      <li><strong>이용한 음식점이 주어진 데이터에 있는 경우</strong>,  <strong>음식점 대표메뉴들의 탄소배출량 평균</strong>을 해당 <strong>음식점의 탄소배출량</strong>으로 산정했다. <strong>이용한 음식점이 주어진 데이터에 없는 경우에는</strong>, <strong>음식점 유형별 탄소배출량</strong>을 일반화해 사용했다. 네이버지도의 태그를 활용해 제주도 음식점을 고기국수집, 횟집 등의 <strong>15개의 유형으로 분류</strong>한 후, <strong>유형에 속하는 메뉴들의 탄소배출량 평균</strong>을 <strong>해당 유형의 탄소배출량</strong>으로 산정했다.</li>
      <li>
        <p>음식의 카테고리를 정하는 데에 사실 재료부터 탄소 발자국을 계산하는 데에 들어가기 때문에, 전문가인 경훈이형에게 많이 물어봤던 기억이 난다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/7.png" alt="7" /></p>
      </li>
    </ul>
  </li>
  <li><strong>(2) 숙박 분야</strong>
    <ul>
      <li>숙박 카테고리의 경우 정현이누나가 맡아서 진행했다.</li>
      <li>데이터의 경우 제공된 <strong>비짓제주 데이터</strong>와 <strong>주소별 온실가스 배출량 데이터</strong>를 이용했습니다. t5 숙소 c3 랑 매칭시켜서 등급별 탄소배출량 평균을 낸 후, 비짓제주 숙박 크롤링이랑 c3 매칭시켜서 호텔 등급별 탄소배출량 평균을 냈다.</li>
      <li>추가적으로 <a href="https://www.data.go.kr/data/15041985/fileData.do">숙박 공공데이터</a>를 리서치해 반영하였다. <a href="https://www.mcst.go.kr/kor/s_policy/dept/deptView.jsp?pCurrentPage=1&amp;pType=05&amp;pTab=01&amp;pSeq=1550&amp;pDataCD=0417000000&amp;pSearchType=01&amp;pSearchWord=%EA%B4%80%EA%B4%91%EC%88%99%EB%B0%95%EC%97%85">문화체육관광부 관광숙박업 등록 현황</a> 또한 참조했다.</li>
      <li><strong>이용한 숙소가 주어진 데이터에 있어서, 주소 매칭을 통해 실제 탄소배출량을 알 수 있는 경우</strong>, 해당 숙소의 탄소배출량을 이용했다. <strong>이용한 숙소가 주어진 데이터에 없는 경우</strong>, <strong>숙소유형별 탄소배출량</strong>을 일반화해 사용했다. 앞서 구한 숙소별 실제 탄소배출량을 이용해 호텔, 리조트 등의 숙소유형별로 평균값을 계산했다.</li>
      <li><strong>사용자가 계산기를 이용할 때</strong>도 위의 로직처럼 이용 숙소가 데이터에 있는 경우와 없는 경우로 분리된다. 이를 통해, 사용자는 정확한 전기사용량 등을 몰라도 탄소배출량을 쉽게 계산할 수 있습니다.</li>
    </ul>
  </li>
  <li><strong>(3) 관광 분야</strong>
    <ul>
      <li>관광 분야의 경우 정현, 경주가 맡아서 진행했다.</li>
      <li>선정 데이터 : 주어진 데이터는 t4_nature, t4_tour, t1_culture 를 주소 매칭하여 활용하기로 했다. t4_nature는 자연 경관 관광데이터로서, ‘성산일출봉’, ‘천지연폭포’, ‘천제연폭포’, ‘주상절리대’, 등의 경관이 포함된다. 추가적으로 <a href="https://www.data.go.kr/data/15041982/fileData.do">관광 공공데이터</a>를 리서치해 반영하였다. 관광의 경우, 관광지 목록 데이터와 주소별 온실가스 배출량 데이터를 이용했다. 또한, <strong>비짓제주 사이트의 관광지 정보를 크롤링한 데이터</strong>를 추가로 이용했다.</li>
      <li>아이디에이션 을 통해, → 입장객 수, 카테고리별 탄소배출량, 관광시간을 산출하기로 결정했다.
        <ol>
          <li>관광지카테고리별 (t4) 입장객 수 비율 : 논문 참고 + 추가 자료조사 필요</li>
          <li>관광지 카테고리별 평균 탄소 배출량 : (1인당 계산)</li>
          <li>관광지 카테고리별 평균 관광시간
            <ul>
              <li>아이패드 메모장</li>
            </ul>

            <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/8.png" alt="8" /></p>
          </li>
        </ol>

        <ul>
          <li>c3랑 매칭된 거+c3 매칭 실패들 등 데이터를 일원화함 약간의 충돌도 있었지만, 일반화한 모든 관광지의 탄소배출량 모음을 구현하도록 노력했다. 관광지별 대분류랑 중분류까지 나와있는 csv 등 을 활용해 관광지 루트 추천에도 반영했다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>(4) 교통 분야
    <ul>
      <li><strong>교통은</strong> 주어진 <strong>세개의 내부 데이터</strong>를 이용해 탄소배출량을 구했다. <strong>추가적으로, 비행기</strong>는 탄소배출량이 굉장히 큰 교통편인데, 내부데이터에 자세하게 나오지 않아, <strong>출발공항</strong>과 <strong>이용좌석</strong>에 따른 탄소배출량을 알 수 있는 <strong>구글플라이트 외부데이터</strong>를 이용했다.</li>
      <li><strong>탑승 인원수, 이동거리, 차종</strong> 등을 질문에 담아 탄소 배출량을 최대한 정확히 산출하고자 했습니다.</li>
    </ul>
  </li>
  <li><strong>이상치 처리</strong>
    <ul>
      <li>아무래도 위치정보를 이용한 탄소배출량은 100% 정확할 수 없기에 <strong>탄소배출량에 대한 이상치를 처리</strong>했다.
        <ul>
          <li>예를 들어, ‘<strong>섭지코지</strong>’의 경우 탄소배출량이 매우 높은데, 그 이유는 <strong>주소 권역이 너무 넓게 설정</strong>되어 있어 <strong>여러 건물들이 함께 존재</strong>하기 때문임을 확인했다.</li>
          <li>→ 따라서 <strong>사분위수를 이용해 발견된 이상치들</strong>은 모두 <strong>카테고리별 평균값</strong>으로 대체했다.</li>
        </ul>
      </li>
      <li>우리 프로젝트의 친환경 여행이었기에, 육각형 중 카테고리 부분 점수 선택할때 자연은 5이상으로만 선택할수있게 하는 등의 조치가 필요하리라 생각했다. 자연이 은근 탄소 배출이 안 높게 나오기도 했고 후처리로도 생각보다 잘 걸러지지 않았기 때문이다. 관광지 탄소 배출량은 다 건물로 매칭한 거라 은근 높게 나온다는 것이 문제였다.
        <ul>
          <li>→ 논문 등에 나와있는 유형별 탄소배출량이랑 비교해보고 타당한지 파악하고, 너무 수치 높게나오는 것은 건물 추정 입장객수를 활용해 수치를 정확하게 수정했다.
            <ul>
              <li>교통 / 비행기 $224 kgCO_2$(왕복)</li>
              <li>숙소 / 그랜드호텔 1박에 $28kgCO_2$ → 3박이면 $84kgCO_2$</li>
              <li>음식 / 이탈리안레스토랑 $3.2kgCO_2$ → 12끼면 $2-30kgCO_2$</li>
              <li>관광 / 아직은 천차마별이지만 $0 -3kgCO_2$느낌 -&gt; 12개 한다하면 $1 -30kgCO_2$정도?</li>
            </ul>
          </li>
          <li>사람들이 상식적으로 생각하기에 자연관광지면 탄소배출이 적게나온다는 생각이 드는게 일반적이기에, 우리도 그거에 맞게 탄소배출량 줄이구 그래서 관광지 선택될때도 자연꺼 많이 포함되게 나오도록 조정했다.</li>
        </ul>
      </li>
      <li>단순 해수욕장 등의 자연인데 높은경우는 이상치들 제외한 <code class="language-plaintext highlighter-rouge">md_cat</code> 별 평균으로 대체했다. 상세분류 <code class="language-plaintext highlighter-rouge">md_cat</code>들에 대해서 각각을 boxplot을 그려보고, 이상치를 어떻게 정의할 것인가에 대해 토론 후 이상치를 제외한 평균으로 각 이상치를 대체해야했다. 우리가 원하는 것은 자연 관광지들에 대하여 탄소 배출을 적게 정의하는거니까 평균 밑으로 어느정도 기준점을 잡아서 진행했다.</li>
      <li>대분류&amp;중분류 있는 관광지 이상치: 중분류 내 이상치 제외한 중분류 평균으로 대체</li>
      <li>중분류 없는 관광지 이상치: 중분류 내에서 이상치 처리 완료한 상태에서 대분류 평균으로 대체</li>
    </ul>
  </li>
  <li><strong>번외</strong>
    <ul>
      <li>대상 차량 선별기준 :
  일반 승용차 / 연비 최상 (-탄소배출과 반비례요소) / 탄소배출 최소
  -&gt; 선정 : 현대자동차 아이오닉 N (2019년형)</li>
      <li>
        <p>중간에 너무 엄밀하게 하다 보니 상세한 분류를 어떻게 해야하는지에 따라서 많은 이야기 후 결정하였다. 그 중 기억이 남았던 부분은 말고기가 반추동물이 아니기 때문에 탄소 배출량이 다르다는 말이었다… 구글링 해도 자료가 나오지 않아 돼지고기와 비슷하다 판단하여 적용했다. (사실 말고기를 안 먹기도 하고)</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/9.png" alt="9" /></p>
      </li>
      <li>
        <p>정현이누나가 잘못 보낸 링크에 리액션해주는 모습이다.. 언제였는지 이제는 기억도 안 난다</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/10.png" alt="10" /></p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-친환경-제주-여행-루트와-팁-제안">3. 친환경 제주 여행 루트와 팁 제안</h2>

<ul>
  <li><strong>친환경</strong> 뿐만 아니라, 자유여행을 선호하는 MZ세대에게 매력적인 여행 루트를 제공하기 위해 <strong>개인화 추천</strong>을 중요하게 고려했다. 따라서 단순히 탄소배출량을 최소화하는 것이 아닌, <strong>사용자의 여행취향도 고려하여</strong> <strong>최적의 탄소배출량을 도출</strong>하는, <strong>여행루트 추천시스템</strong>을 설계하였다. 이를 위해서는 <strong>사용자 데이터셋과 여행지 데이터셋이</strong> 필요하다</li>
  <li>
    <p>이때부터는 수업 끝나면 계속 만나서 빅콘만 계속했던 것 같다. 그 때를 생각해봐도, 갤러리를 보아도 그 때의 순간들이 가득하다. 사실 9월 내내동안 데이터만 만질 때도 매일 만나긴했지만..ㅎㅎ 다음 phase로 넘어간 느낌</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/11.png" alt="11" /><em>예쁜 에어비앤비 방에서 빅콘하는 낭만</em></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/12.png" alt="12" /></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/13.png" alt="13" /></p>
  </li>
</ul>

<h3 id="데이터셋-구축">데이터셋 구축</h3>

<ul>
  <li><strong>3.1. 사용자 데이터셋 생성</strong>
    <ul>
      <li>저희는 <strong>취향저격 Hexagon</strong>이라는 지표를 개발했다. <strong>개인화된 여행루트를 추천하기 위한, 사용자의 취향이 반영된</strong> 6개 요소의 그래프이다. 각 요소에 대해 사용자는 1점부터 10점까지 부여할수 있다. 이 중 <strong>액티비티 선호, 자연 선호, 문화유적 선호</strong> <strong>지표</strong>는 <strong>방문할 관광지를 선정</strong>하기 위한 지표로써, 해당 카테고리의 점수가 높을수록 그 카테고리의 관광지가 루트에 많이 포함된다.</li>
      <li><strong>핫플 선호, 맛집 추구</strong> <strong>지표</strong>는 사용자가 <strong>잘 알려진 곳과 숨겨진 곳 중 어떤 것을 선호하는지</strong>를 반영하기 위한 지표로써, 점수가 높을수록 보다 유명한 곳이 추천된다. <strong>여행 밀도</strong> <strong>지표</strong>는 <strong>방문할 관광지의 총 개수</strong>를 선정하기 위한 것으로, 점수가 높을수록 많은 관광지에 방문한다.</li>
      <li>육각형 지표를 구축했으니 이제 <strong>사용자에게 INPUT을 입력</strong>받는다.
        <ul>
          <li>우선, <strong>제주도의</strong> <strong>어떤 지역</strong><strong>을 여행할 것인지</strong> 선택한다. 동부,서부 같은 큰 단위로도, 구좌읍 같은 작은 단위로도 모두 선택 가능하다. 그리고 <strong>이용할</strong> <strong>교통수단</strong><strong>을 선택한</strong>다. 이 때 친환경 여행을 위한 렌터카 선택 팁도 함께 제공해 친환경 여행을 유도했다.</li>
          <li>그 다음, <strong>취향저격 HEXAGON</strong>을 입력받는다. 이 모든 과정은 <strong>스트림릿</strong>을 활용해 구현했으며, 오른쪽 링크를 통해 확인하실 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3.2. 여행지 데이터셋 생성</strong>
    <ul>
      <li><strong>음식점, 숙박, 관광지</strong> 데이터가 필요했는데, <strong>내부데이터 정보가 부족</strong>하다고 판단해, <strong>여행지 상세 정보</strong>를 제공하는 비짓제주 사이트를 크롤링해 보완했다.</li>
      <li>첫번째로 <strong>음식점 데이터</strong>이다. 비짓제주 사이트에 있는 1646개의 음식점을 크롤링했다. 탄소발자국 계산을 위해 음식점별 해시태그를 바탕으로 음식점을 유형별로 분류한 후, 앞서 구축한 탄소발자국 계산기를 이용해 탄소배출량을 계산했다.</li>
      <li>두번째로 <strong>숙소데이터</strong><strong>는</strong> 총 939개로, 음식점 데이터와 마찬가지로 <strong>숙소를 숙박업종별로</strong> 분류한 후, 탄소발자국 계산기를 이용해 탄소배출량을 계산했다. 마지막으로 <strong>관광지 데이터</strong><strong>는</strong> 총 1101개이며, 여행루트 추천의 메인이 되는 데이터라고 볼 수 있다. 탄소배출량 계산을 위해 제공된 데이터인 ‘<strong>주소별 온실가스배출량 데이터</strong>’를 이용했다.</li>
      <li>이렇게 모인 데이터에 대해 <strong>관광지별 지표 점수</strong>를 계산했다. 앞서 설명드린 것처럼 사용자가 자연선호도를 높게 입력하면, 자연성이 높은 관광지가 추천된다. 이를 위해서 저희는 <strong>한 관광지를 한 카테고리로 분류하는 것이 아니라</strong>, 그 관광지의 상대적인 자연성, 액티비티성, 문화유적성 비율을 산정했다. <strong>예를 들면, ‘성산일출봉’</strong>을 ‘자연’ 카테고리로 분류하는 것이 아닌, 자연성 0.77, 액티비티성 0.68 과 같이 점수를 산정했다.</li>
    </ul>
  </li>
  <li><strong>3.3. 여행지 클러스터링</strong>
    <ol>
      <li>
        <p>우선 <strong>텍스트 전처리</strong>를 하고, <strong>토큰화</strong>를 진행했다. 그다음 Word2Vec를 이용해 관광지를 벡터로 변환하여 수치화하는 <strong>워드 임베딩</strong> 과정을 거쳤다.</p>

        <p><a href="https://colab.research.google.com/drive/1pxjyT3NLVnsUXfO96dD1cuPvazrvXlEe?usp=sharing">bookmark</a></p>
      </li>
      <li>그다음 거리 기반의 군집화 방법인 <strong>k means 클러스터링</strong>을 진행하였고, <strong>고차원의 데이터 셋</strong>을 <strong>차원 축소</strong>하는데 효과적인 <strong>t-SNE</strong>를 이용해, <strong>150차원의 문장벡터를 2차원으로 축소</strong>한 후 결과를 시각화했다.</li>
      <li>생성된 6개의 클러스터 중 <strong>클러스터1</strong>은 해당되는 관광지수가 적으면서, <strong>국내 여행의 목적과 맞지 않는</strong> <strong>의료관광</strong>과 관련된 클러스터라고 판단해 제거했다.</li>
      <li>이후 <strong>클러스터별 상위 10개 명사</strong>를 바탕으로, <strong>유사하다고 판단되는 클러스터를 병합</strong>했고, 최종적으로 <strong>자연, 액티비티, 문화유적 세 개의 클러스터</strong>가 형성되었습니다.</li>
      <li>그 다음 클러스터링 결과를 이용해 <strong>자연성, 액티비티성, 문화유적성 점수를 산정</strong>하는 작업을 진행했다.
        <ul>
          <li>K-means 알고리즘 특성 상 <strong>클러스터의 중심에 위치한 관광지가 해당 클러스터를 가장 잘 대표하므로</strong>, 중심점과의 거리가 가까울수록, 해당 클러스터의 속성이 많이 포함된다고 판단했다.</li>
          <li>따라서  <strong>점수를 (1-거리)의 제곱</strong>으로 설정해, 클러스터 중심점과의 거리가 가까울수록 1, 멀수록 0에 가까운 지표를 산정했다.</li>
          <li>kmeans 클러스터링 개수 일단 6개로 지정하여 (빨주노초파귤) 개수 조정하면서 괜찮은 클러스터를 찾도록 했다.</li>
          <li>
            <p>클러스터 결과 : 최종 크롤링 데이터+명사만 포함+kmeans 8개</p>

            <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">0</span> <span class="p">[</span><span class="s">'카멜리아힐'</span> <span class="s">'휴애리 자연생활공원'</span> <span class="s">'아침미소목장'</span> <span class="s">'김경숙해바라기농장'</span> <span class="s">'아날로그감귤밭'</span> <span class="s">'제주허브동산'</span> <span class="s">'이니스프리제주하우스’..]
  - cluster 1 ['</span><span class="n">성산일출봉</span><span class="p">(</span><span class="n">UNESCO</span> <span class="n">세계자연유산</span><span class="p">)</span><span class="s">' '</span><span class="n">사려니숲길</span><span class="s">' '</span><span class="n">산굼부리</span><span class="s">' '</span><span class="n">섭지코지</span><span class="s">' '</span><span class="n">한라산국립공원</span><span class="s">' '</span><span class="n">에코랜드</span> <span class="n">테마파크</span><span class="s">' '</span><span class="n">비자림</span><span class="err">’</span><span class="p">..]</span>
  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">2</span> <span class="p">[</span><span class="s">'제주국제공항'</span> <span class="s">'하도해변'</span> <span class="s">'제주레일바이크'</span> <span class="s">'서귀포잠수함(대국해저관광)’…]
  - cluster 3 ['</span><span class="n">새별오름</span><span class="s">' '</span><span class="n">용눈이오름</span><span class="s">' '</span><span class="n">다랑쉬오름</span><span class="p">(</span><span class="n">월랑봉</span><span class="p">)</span><span class="s">' '</span><span class="n">백약이오름</span><span class="s">' '</span><span class="n">따라비오름</span><span class="err">’…</span><span class="p">]</span>
  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">4</span> <span class="p">[</span><span class="s">'오설록티뮤지엄'</span> <span class="s">'아쿠아플라넷 제주'</span> <span class="s">'방주교회'</span> <span class="s">'성이시돌목장’…]
  - cluster 5 ['</span><span class="n">우도</span><span class="p">(</span><span class="n">해양도립공원</span><span class="p">)</span><span class="s">' '</span><span class="n">협재해수욕장</span><span class="s">' '</span><span class="n">월정리해변</span><span class="s">' '</span><span class="n">제주올레</span> <span class="mi">12</span><span class="n">코스</span><span class="s">'…]
  - cluster 6 ['</span><span class="n">제주4</span><span class="p">.</span><span class="mi">3</span><span class="n">평화공원</span><span class="s">' '</span><span class="n">마라도</span><span class="p">(</span><span class="n">마라해양도립공원</span><span class="p">)</span><span class="s">' '</span><span class="n">용머리해안</span><span class="s">' '</span><span class="n">정방폭포</span><span class="err">’</span><span class="p">..]</span>
  <span class="o">-</span> <span class="n">cluster</span> <span class="mi">7</span> <span class="p">[</span><span class="s">'썬플라워의원'</span> <span class="s">'THE WE'</span> <span class="s">'서귀포의료원'</span> <span class="s">'솔담한방병원'</span> <span class="s">'제주대학교병원'</span> <span class="s">'제주우리병원'</span> <span class="s">'제주한라병원'</span> <span class="s">'제주카약'</span> <span class="s">'중앙병원'</span> <span class="s">'한국건강관리협회제주특별자치도부'</span><span class="p">]</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="추천시스템-구현">추천시스템 구현</h3>

<ul>
  <li>탄소 배출량만을 최소화하는 친환경 여행 루트를 설계하는 것은 쉽지만, 그러한 여행 루트는 사람들에게 매력적으로 다가오지 못할 것이다. 따라서, 탄소 배출량을 줄이는 친환경 여행 루트를 짜되, 충분히 흥미롭게 느껴지는 루트를 설계하는 게 목적이다.
    <ul>
      <li>저탄소 생태관광 시나리오를 참고하여 이에 주안점을 두고 루트를 설계하는 데에 고려했다. 이를 요약하면 아래와 같다. 그래도 생태관광이기에 자연 경관을 관광지로 선택하였다.
        <ul>
          <li>(최대 배출) 택시 + 호텔, 콘도리조트</li>
          <li>(보편 배출) LPG 렌터카 + 펜션</li>
          <li>(최소 배출) 휘발유 렌터카 + 친구집</li>
        </ul>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/14.png" alt="14" /></p>
      </li>
      <li>저비용으로 설계하는 것 또한 대회에서의 주안사항이었기에 약 70만원 - 100만원으로 그 range를 두고 항공비/식비/숙박비를 지출할 수 있도록 설계했다.</li>
    </ul>
  </li>
  <li>최단경로 알고리즘 이용해서 탄소배출계산기 바탕으로 MZ 세대에 적합한 여행루트 설계
    <ul>
      <li>숙소와 관광명소 크롤링
        <ul>
          <li>숙소/관광명소를 키워드로 네이버 블로그나 인스타그램을 크롤링해서 얻은 데이터를 자연어처리 후 감성분석과 클러스터링한 후, 이를 바탕으로 개인에게 맞는 관광지 추천할 예정이다.</li>
          <li>관광지 근처의 음식점 5개중에서는 네이버 지도 기반 더 유명한 것을 추천하도록 했다.</li>
        </ul>
      </li>
      <li>
        <p>저탄소 배출 관광지</p>

        <p>$input<em>탄소 + (1-input)</em>다른지표$</p>

        <ul>
          <li>다른 지표로는 인기있거나 맛집을 넣었다. 관광지 인기도 지표를 만든 것처럼 음식점도 지표를 만들어 넣었다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>참조하여 구현
    <ul>
      <li>참고한 링크 <a href="https://triple.guide/regions/759174cc-0814-4400-a420-5668a0517edd/articles/841db340-ffb6-4774-8265-45f559f37e2b">트리플에서 제공한 제주 여행 코스 설계방법</a>, <a href="https://www.visitjeju.net/kr/recommendTour/recommendScheduleList?menuId=DOM_000002000000000241&amp;cate1cd=cate0000001350#">비짓제주 여행 일정 페이지</a> 등을 참조하여 구현하도록 했다.
        <ul>
          <li>제주관광공사 - 추천한 곳 → 탄소발자국 매치 : 과연 데이터가 안에 존재하는가?</li>
        </ul>
      </li>
      <li>네이버에서 <a href="https://campaign.naver.com/gabojagojeju/?pcode=naver_brandsearch_myplacesearch_PC">&lt;제주 가보자고, 맛집여지도&gt;</a> 로 해둔 것과 많이 제주도를 가본 경주의 머릿속 네이버지도속 데이터를 활용할수 있도록 했다.</li>
    </ul>
  </li>
  <li>기본 로직
    <ul>
      <li>기본적으로는 ‘관광-밥-관광-밥’, ‘관광-밥-관광-밥-관광’, ‘관광-밥-관광-관광-밥-관광’으로 관광지들을 주요 노드에 두고 밥을 그 사이 끼어넣었다. 방문 관광지 개수는 6개에서 16개 사이로 나왔다.</li>
      <li>여행 첫 날의 경우 비행기 시간에 따라 첫 관광, 혹은 첫 관광밥 생략가능하도록 조정했다. 비행기로 제주도 가는 사람이 많으니 첫 시작지점은 제주공항이고 계산기는 교통에서 선택하도록 했으며, 마지막날은 비행기 시간에 따라 [:-2] 요소 생략가능하도록 설계했다.</li>
      <li>제주도를 크게 동서남북의 네 가지 권역으로 나누었다.
        <ul>
          <li>관광지 주변 숙박이 없는 경우가 많아서, 각 지역별로 가장 유명한 펜션/민박을 하나씩 뽑았다. 꼭 조회수 기반이 아니더라도 인기있는 곳을 추천할수있도록 정의했다.</li>
        </ul>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/15.png" alt="15" /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="제주-어셈블-코드">제주 어셈블 코드</h3>

<p>코드는 이러한 과정들을 구체적으로 구현하는데, 주로 데이터 처리, 필터링, 최적화 알고리즘 등을 포함한다. 예를 들어, <code class="language-plaintext highlighter-rouge">pandas</code> 라이브러리를 사용하여 데이터를 처리하고, <code class="language-plaintext highlighter-rouge">numpy</code>나 <code class="language-plaintext highlighter-rouge">scipy</code>를 사용하여 수학적 계산을 수행하며, 다양한 알고리즘 라이브러리를 통해 최적화 문제를 해결한다. 또한, 사용자의 입력을 받고 결과를 출력하는 사용자 인터페이스 부분도 중요한 역할을 한다. 전체적으로 이러한 코드의 구성은 사용자에게 맞춤형 여행을 제공하는데 필수적인 요소다.</p>

<p>제주_어셈블 코드의 개괄은 다음과 같다. 이 알고리즘은 사용자의 위치, 선호도, 그리고 각 관광지의 특성을 고려하여 개인화된 여행 경로와 식사, 숙박 장소를 제공한다. 전체 과정은 데이터 처리, 최적화 계산, 사용자 입력 처리 등을 포함하여 사용자에게 만족스러운 여행 경험을 제공하는 것을 목표로 한다.</p>

<ol>
  <li>Assemble 함수:
    <ul>
      <li><strong>Filtering</strong>: 사용자의 현재 위치와 관광지 인기도를 바탕으로 관광지를 필터링한다. 적절한 후보군(22개에서 최대 103개)을 선정한 후, 이를 더 관리하기 쉽게 일정 수(예: 22개)로 랜덤 샘플링한다.</li>
      <li><strong>지역 분류</strong>: 관광지를 소분류(loc1, 예: 애월)와 대분류(loc2)로 나누어 관리한다. 유명하지 않은 숨겨진 장소도 포함하여 다양성을 확보한다.</li>
      <li><strong>Combination</strong>: 필터링된 관광지들 중에서 사용자가 하루에 방문할 관광지 수(num tour weighted)에 따라 가능한 모든 조합을 생성한다. 각 조합에 대해 관광 목적, 인기도, CO2 배출량을 합산하여 최적의 조합을 선정한다.</li>
    </ul>
  </li>
  <li>CO2 최소화 및 최적 경로:
    <ul>
      <li><strong>CO2 최소화</strong>: CO2 배출량이 일정 비율 이하인 조합들 중에서, 사용자의 선호도와 가장 유사한 경로를 선택한다.</li>
      <li><strong>최단거리 경로(Recommended tour)</strong>: 선택된 관광지들 중에서 이동 거리를 최소화하는 순서로 방문 경로를 결정한다. 가능한 모든 순서의 조합(permutation)을 고려하여 계산한다.</li>
      <li><strong>Min route</strong>: 전체 경로 중 이동 거리가 가장 짧은 경로를 최종적으로 선택한다.</li>
    </ul>
  </li>
  <li>식사 및 숙박 장소 추천:
    <ul>
      <li><strong>식사 장소 결정</strong>: 사용자가 식사 시간에 맞춰 방문할 수 있는 식당을 daily route에 포함시킨다. 이때 주변 음식점의 정보, 식사 가능 시간, CO2 배출량 및 인기도를 고려한다.</li>
      <li><strong>숙박 장소 결정</strong>: 일정의 마지막 관광지 근처에서 숙박할 수 있는 장소를 추천한다. 사용자의 선호도에 따라 호텔, 펜션, 게스트하우스 등 다양한 유형의 숙소를 고려한다.</li>
    </ul>
  </li>
  <li>유저 적합성 고려:
    <ul>
      <li><strong>User fit 식당 선정</strong>: 사용자의 선호도(bad value)에 따라 식당을 선정하고, 점심과 저녁을 교차하여 배열한다. 만약 적당한 식당이 없으면 지역별 대표 식당(good food)을 제공한다.</li>
    </ul>
  </li>
  <li>숙소 고려
    <ol>
      <li>숙소 추천 시스템:
        <ul>
          <li><strong>일정의 마지막 관광지</strong>: 하루 일정의 마지막 관광지를 기준(min route[-1])으로 주변 숙박 시설을 찾는다.</li>
          <li><strong>주변 숙박 시설 탐색</strong>: 마지막 관광지 이름을 기준으로 주변 숙박 시설을 검색한다. 만약 검색된 숙박 시설이 없거나 분류되지 않은 경우, 추가적인 처리 과정을 통해 적합한 숙박 시설을 찾는다.</li>
        </ul>
      </li>
      <li>사용자 선호도에 따른 숙소 유형 분류:
        <ul>
          <li><strong>여유로운 사용자(beak value &lt; 0.2)</strong>: 사용자가 여유로운 여행을 선호한다고 판단되면, 호텔, 리조트, 콘도와 같은 고급 숙소를 추천한다.</li>
          <li><strong>보통의 여행자(0.2 ≤ beak value &lt; 0.8)</strong>: 평균적인 여행 선호도를 가진 사용자에게는 펜션, 민박, 모텔, 여관 등을 추천한다.</li>
          <li><strong>활동적인 여행자(beak value ≥ 0.8)</strong>: 활동적이고 경제적인 여행을 선호하는 사용자에게는 게스트하우스, 캠핑, 글램핑 등을 추천한다.</li>
        </ul>
      </li>
      <li>예외 처리:
        <ul>
          <li><strong>숙소 미발견 시 대응</strong>: 적합한 숙소를 찾지 못하는 경우, 사전에 정의된 ‘good accom’ 목록에서 대체 숙소를 추천한다. 이 목록에는 각 지역별로 대표되는 숙소가 포함되어 있어, 사용자에게 일정한 품질의 숙박 시설을 제공할 수 있다.
            <ul>
              <li><code class="language-plaintext highlighter-rouge">assemble(df, user)</code> 로 함수를 불러서 쓸 수 있다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/16.png" alt="16" /></p>
  </li>
</ol>

<ul>
  <li>
    <p>새벽에 경훈이 형 코드가 잘 돌아가지 않아서,, 혜나랑 열심히 삽질하다, 첫 번째 페르소나가 나왔던 감격스런 순간이다. 깨 있던 혜나와 나는 정말 이 때 기뻤다. 당일 오전 여섯시에 경주는 지쳐 자고 있었고 정현이누나는 집을 갔다가 방으로 다시 오는 길이었던걸로 기억한다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/17.png" alt="17" /><em>드디어 나온 페르소나</em></p>
  </li>
  <li>
    <p><strong>대고객 커뮤니케이션 방안</strong></p>
    <ol>
      <li><strong>인스타그램 활용 방안이다.</strong>
        <ul>
          <li><strong>취향저격 Hexagon에 따라 추천된 여행루트</strong>를 <strong>밤하늘 별자리</strong>로 표현해, 인스타그램에 공유하는 <strong>이벤트</strong>를 제안했다. 이는 탄소배출량을 줄이면, 공기가 맑아지고 밤하늘의 별이 더 밝게 빛나게 된다는 점에서 착안하였다.</li>
          <li><strong>MZ 세대는 인스타그램</strong>을 활발히 이용하기 때문에, MZ 세대 이용자를 확보할 수 있을 것으로 기대했다.</li>
        </ul>
      </li>
      <li><strong>제주도 북두칠성 버스킹 라이브</strong>
        <ul>
          <li><strong>현대카드</strong>는 매년 슈퍼콘서트를 개최해 큰 홍보 효과를 누렸지만, 콘서트는 개최 과정에서 많은 탄소가 배출된다는 문제가 있다. 현대카드가 고객의 문화생활을 타게팅하기 위해서 현대카드 슈퍼콘서트같은거나 현대카드 뮤직라이브러리를 운영하는데 제주도에서도 저녁부터 시작해서 조명없는 어쿠스틱 콘서트 하면 좋을 것 같다고 생각했다.</li>
          <li>별도의 조명이 필요없는 <strong>칠성대 분수 공원</strong>에서 진행하는 <strong>친환경적인 버스킹 콘서트를 신한카드 측에 제안하는 것으로 마무리했다.</strong></li>
        </ul>
      </li>
      <li><strong>신한카드 ESG 제주 여행 콘테스트</strong>
        <ul>
          <li>기존에 존재하는 <strong>신한 그린 인덱스 지수</strong>를 활용하여 여행 시 탄소 절감을 잘 실천한 고객을 선정하거나, <strong>친환경 여행 브이로그 영상 우수작</strong>을 선정하는 콘테스트이다.</li>
          <li><strong>위 3가지의 방법</strong>을 통해 <strong>신한카드의 친환경 경영 이미지를 구축</strong>할 수 있으며,  ‘친환경 여행’이라는 MZ세대의 새로운 트렌드를 만들어나갈 수 있을 것이라 기대한다.</li>
          <li>제주관광공사 측면에서랑 신한카드 가 데이터를 제공했다는 것에 착안하여, 제주 관광객과 신한카드 이용고객에 대한 커뮤니케이션 방안을 제안했다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="제출-당일">제출 당일</h2>

<ul>
  <li>분석 주제, 사용한 데이터, 전처리, 모델링, 결과, 활용 방안 등 모두가 쉽게 이해할 수 있을만큼 탄탄한 스토리를 구성했다. 나랑 경주가 같이 작업에 들어갔다. 창업팀 등 다양한 활동으로 나는 프레젠테이션 자료를 빨리 잘 만든다는 장점을 가지고 있고, 경주는 디자인적으로나 경영적으로 어떠한 장표가 어울리는지 잘 알고 있어서 끊임없이 파일을 주고받으며 완성을 시켜나갔던 것 같다.</li>
  <li>
    <p>제출당일, 밤을 새고 긴박하게 제출했던 우리들의 모습이다. 고등학교 때도 대학교 때도 밤을 샌 적 없었는데 에어비앤비로 방을 대여해 열심히 달렸던 기억이 난다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/18.png" alt="18" /></p>
  </li>
  <li>
    <p>경훈 취뽀 이후 현직자 데이까지 예측한 혜나 정현의 모습이다</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/19.png" alt="19" /></p>
  </li>
  <li><strong>수업도 째고.. 마감 5분전 벼락치기 제출 완료</strong>⚡</li>
  <li><u>**1차 서류평가 기준**</u>
    <ul>
      <li>탄소 계산기(40%) + 여행루트(50%) + 고객 커뮤니케이션 방안(10%)</li>
      <li>단순 탄소 배출량 최소화보다, 탄소배출량 절감 TIP등을 활용한 탄소 중립을 실천하는 여행 루트 개발하기</li>
    </ul>
  </li>
  <li>
    <p>제출완료 “귀하의 건승을 기원합니다”</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/20.png" alt="20" /></p>
  </li>
</ul>

<h1 id="발표심사1128">발표심사(11.28)</h1>

<ul>
  <li>2차 PT 발표심사는 현장 발표로 진행되며, 발표순서는 2022 빅콘테스트 서포터즈에서 추첨방식으로 선정 예정이었다. 이노베이션분야의 경우 11. 28(월)이고, 12팀 중에 2번째로 선정되어 열시 쯤 발표가 진행될 예정이었고, 청계천 주변 한국지능정보사회진흥원 서울사무소에서 발표를 진행했다.</li>
  <li><u>**2차 발표평가 기준은 다음과 같았다.**</u>
    <ul>
      <li>1차 서류심사 내용 구체화 및 발표능력</li>
      <li>심사위원 질의에 대한 논리적 대응 및 설명력</li>
    </ul>
  </li>
  <li>
    <p>아침 일찍 만나서 사진 왕창 찍었다.</p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/21.png" alt="21" /></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/22.png" alt="22" /></p>
  </li>
  <li><strong>빅콘테스트 이노베이션분야 2차 PT발표 질의응답</strong>
    <ul>
      <li><strong>1-1 질문과 답변:</strong> 숙소에서의 탄소 배출량 계산에 수용 인원을 고려했는지 여부.
        <ul>
          <li>→ <strong>답변</strong>: 숙소의 성격과 수용 인원이 다양하여 정확한 인원 수와 객실별 탄소 배출량을 알기 어렵다. 따라서 건물에서 나오는 총 탄소 배출량을 기준으로 하며, 특정 건물에 대한 정보가 없을 경우 유형별 평균값을 사용하여 계산한다.</li>
        </ul>
      </li>
      <li><strong>2번째 질문과 답변:</strong> MZ 세대의 특성을 반영한 탄소 저감 여행과 여러 명이 여행할 경우의 여행 루트 설계에 대한 고려 사항.
        <ul>
          <li>→ <strong>답변</strong>: MZ 세대의 특성을 반영하여 인기도, 유행, 독특한 장소 선호 등을 고려하여 알고리즘을 설계했다. 여러 명이 여행할 경우 각자 선호도를 조정하여 그룹에 최적화된 경로를 찾는데, 이는 알고리즘의 인풋 값을 조정하여 다양화된 추천을 받는 방식으로 해결할 수 있다.</li>
        </ul>
      </li>
      <li><strong>3번째 질문과 답변:</strong> GeoPy 라이브러리를 사용한 직선 거리 계산의 정확성.
        <ul>
          <li>→ <strong>답변</strong>: 실제 주행 거리와 직선 거리가 다를 수 있으나, 네이버 API 사용의 비용과 속도 문제로 GeoPy 라이브러리를 사용하여 직선 거리(유클리디언 거리)를 계산했다.</li>
        </ul>
      </li>
      <li><strong>4번째 질문과 답변:</strong> 숙박 시설의 속성별 선택과 탄소 배출량 계산에 대한 고민.
        <ul>
          <li>→ <strong>답변</strong>: 여행 밀도와 선호도에 따라 숙박 시설을 선택하며, 데이터베이스에 있는 호텔의 탄소 배출량 정보를 활용하여 저탄소 숙소를 추천한다.</li>
        </ul>
      </li>
      <li><strong>5번째 질문과 답변:</strong> 개인의 선호도에 고착되지 않고 다양한 관광지를 추천하는 대응책.
        <ul>
          <li>→ <strong>답변</strong>: 알고리즘에 랜덤성을 도입하고, 리커트 척도를 10점으로 설정하여 사용자가 다양한 선호도를 입력할 수 있게 함으로써, 똑같은 입력에도 다른 결과가 나오도록 설계하여 다양화된 추천을 제공한다.</li>
        </ul>
      </li>
      <li>
        <p>이후 메일이 오고 나서 시상식때 최종 결과가 나옴을 전달받았다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/23.png" alt="23" /><em>2022년 2학기의 결실!</em></p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="시상식1221">시상식(12.21)</h2>

<ul>
  <li>
    <p><strong>최우수상을 받을 수 있었다.</strong></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/24.png" alt="24" /></p>

    <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/25.png" alt="25" /></p>
  </li>
  <li><strong>의미 없는 경험은 없다!</strong>
    <ul>
      <li>2학기 거의 전체, 3개월에 달하는 기간동안 여념 없이 대회에 참여함과 동시에, 공대생 3학년의 신분으로 학교를 다니면서도, 나의 경우엔 창업팀에서의 성과가 나와서 빅콘 대회 당일에도 다이슨 어워드 시상식을 갔다오는 등 빡빡했던 스케줄이었다.</li>
      <li>
        <p>그러한 긴 기간동안, 적지 않은 명수의, 아주 다각화된 배경을 가지고 있는 다섯명의 구성원들과 함께했던 시간들을 떠올려 보면 정말 후회없다. 의견 충돌이 있을 때에도 서로 충분히 근거에 빗대어 설명했고 그 합치된 의견에 대해서는 함께 나아갔다. 피땀흘려 함께했던 시간들이 대학생활 중 따스했던 추억으로 남아있다. 상을 수상할 수 있어 좋았지만, 좋은 친구들과 열심히 협업했던 스물셋의 소중한 기억으로도 충분했다.</p>

        <p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/26.png" alt="26" /><em>동아리 자기소개 페이지에서도 이루어진 빅콘자랑 ~</em></p>
      </li>
    </ul>
  </li>
  <li><strong>진로로서의 고민 해결</strong>
    <ul>
      <li>소프트웨어 엔지니어로서의 꿈은 초등학생 때부터 <strong>스티브 잡스</strong>를 동경하며 지속적으로 바라 온 목표였고, 고등학생 때 부터는 <strong>딥러닝 엔지니어</strong>의 꿈을 위해 노력하고 있습니다. 대학에서도 데이터를 다루는 역량과 더불어 이로부터 인사이트를 창출하는 작업으로부터 다양한 방법론을 효율적으로 적용할 수 있으리라 느껴 INSIGHT 동아리에 합류했다.</li>
      <li>INSIGHT, 특히 데벤져스에서 빅콘을 준비하며 정말 다양한 배경과 도메인을 가지고, 각자의 목표를 향해 나아가는 열정적인 학회원들과 교류하며 깊은 리스펙은 물론 서로로부터 좋은 에너지와 시너지를 낼 수 있었다. 데이터 분석 뿐만 아니라 개발, 딥 러닝에 이르기까지 많은 분야로부터 열정적으로 참여할 기회 그 자체였다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/27.png" alt="27" /></p>

<h2 id="신한카드월드뱅크-그린인덱스-워크샵">신한카드&amp;월드뱅크 그린인덱스 워크샵</h2>

<ul>
  <li>빅콘테스트 사무국에서 오랜만에 정현이누나를 통해서 연락이 왔다. 탄소 데이터 관련하여 대학생 대회 프로젝트를 발표하는 자리였다. 이전 피피티로부터 부족한 부분을 채운 이후, 어색할 수 있는 부분들을 영어로 모두 수정했다. 큰 자리에서 발표하는 기회가 많이 있을 것 같지는 않으리라 생각했기에 내가 발표를 진행했다.</li>
</ul>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/28.png" alt="28" /><em>또다시 울린 정현이누나의 버스터콜</em></p>

<p><img src="/assets/img/2022-12-30-빅콘테스트-후기-(2022년-이노베이션-분야).md/29.png" alt="29" /></p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="경험" /><category term="Reminiscent" /><category term="대회" /><summary type="html"><![CDATA[의미없는 경험은 없다!]]></summary></entry><entry><title type="html">[ALG] 4.3. Misc.</title><link href="http://localhost:4000/ALG-4.3.-Misc" rel="alternate" type="text/html" title="[ALG] 4.3. Misc." /><published>2022-09-30T00:00:00+09:00</published><updated>2022-09-30T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.3.-Misc</id><content type="html" xml:base="http://localhost:4000/ALG-4.3.-Misc"><![CDATA[<h1 id="alg-huffman-1">[ALG] Huffman (1)</h1>

<p>Huffman Correctness Proof</p>

<p>Proof by Induction</p>

<p>if the set of trees obtained in the ith step are branches in a binary tree corresponding to an optimal code, then the set of trees obtained i+1 th step</p>

<h1 id="alg-intractable-problem-and-approximation-alg-1">[ALG] Intractable Problem and Approximation Alg (1)</h1>

<p>Millenium problems</p>

<p>NP Hard</p>

<ul>
  <li>0-1 knapsack
    <ul>
      <li>문제 size n에 대해서 솔루션 찾지도, 증명도 못하였지만 상수시간에 못 푸리라 생각한 NP</li>
      <li>1,2, …, n번 물건 중 몇 개만 훔칠건데, 훔친 것들 무게의 합이 가방 용량보다는 같거나 작으면서 내가 훔쳤을 때 얻을 수 있는 이득의 총합</li>
    </ul>
  </li>
  <li>subset sum
    <ul>
      <li>양의 정수 n개가 있는데, n개 중 몇 개를 뽑을 건데 해당 조건을 만족하면서 뽑은 것들의 총 합이 주어진 조건보다 작거나 같으면서 뽑은 것들의 무게를 최대화하는것</li>
      <li>뽑은 것들의 무게의 합을 최대화 : $\Sigma_{i \in A} w_i$</li>
    </ul>
  </li>
  <li>뭐가 더 어려울까?
    <ul>
      <li>둘 다 아무도 n에 대해서 효율적인 알고리즘 (polynomial time)을 찾지 못했고 없다고 증명도 못했고 단지 없을 것이라고 생각함.</li>
    </ul>
  </li>
</ul>

<h1 id="polynomial-and-exponential-time-function">Polynomial and Exponential Time Function</h1>

<ul>
  <li>$n^k$까지가 Polynomial time - $2^n$ 은 exponential time</li>
  <li>polynomial solution이 존재하면 효율적인 알고리즘이 존재한다.</li>
</ul>

<p>intractable problem = hard problem</p>

<ul>
  <li>무궁무진하게 많으나 아무런 솔루션을 찾지 못했음</li>
</ul>

<p>polynomial</p>

<p>없다고 증명할 수 있으면 해라</p>

<p>효율적인 알고리즘을 못 찾았는데 - 내가 못해서 그런가보다</p>

<p>효율적인 알고리즘을 못 찾았는데 - 실제로 가능하지도 않다</p>

<p>효율적인 알고리즘을 못 찾았는데 - 그런데 알고 봤더니 이것이 np complete이다.</p>

<ul>
  <li>→ 그 많은 알고리즘 하는 사람이 못 찾았고 나도 못 찾았다.</li>
</ul>

<p>np complete, hard일 가능성이 큼</p>

<ul>
  <li>→ Approximation alg, Heuristic alg를 통해
    <ul>
      <li>최대화, 극대화해주지는 못하지만 그에 대한 근사치를 찾아주는, 그렇지만 효율적으로 polynomial time 안에 돌아가는 solution을 찾아주는 알고리즘</li>
    </ul>
  </li>
</ul>

<h1 id="다양한-문제들">다양한 문제들</h1>

<h2 id="hamiltonian-path">Hamiltonian Path</h2>

<ul>
  <li>가급적 지나간 곳은 지나가지 않는다.</li>
</ul>

<h2 id="longest-path">Longest path</h2>

<h1 id="how-do-you-bp">How do you BP~~</h1>

<p>&lt; 시험 무조건 나옴&gt;</p>

<h1 id="0-1-knapsack-problem">0-1 Knapsack Problem</h1>

<ul>
  <li>optimization 문제 : 0-1 knapsack, subset sum
    <ul>
      <li>무언가를 최대로 최적화하는 문제</li>
      <li>Ex. 훔친 물건의 무게, 가격, 가방의 용량 → 내 가방에 담을 수 있는 선에서 해당 profit을 maximize해주는 selection을 찾아라.</li>
    </ul>
  </li>
  <li>이에 대응되는 ‘Decision problem’
    <ul>
      <li>Ex. 훔친 물건의 무게, 가격, 가방의 용량, ‘T’</li>
      <li>T : decision problem이니까 답이 Yes or No로 나뉘어 나옴 : 이런 무게와 profit, W가 주어졌을 때 허용된 용량 안에서 물건을 훔치며 관련 주어진 T보다 큰 것이 가능한가가 문제
        <ul>
          <li>가방에 담으려하는데, 담은 가격의 합이 주어진 값 T보다 많을 수 있느냐 (Ex. 5000원보다 더 훔쳐올 수 있느냐)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>→ optimization이 어려움</li>
</ul>

<h1 id="subset-sum-problem">Subset Sum Problem</h1>

<ul>
  <li>Decision Problem
    <ul>
      <li>Given a set of positive integers ${s_1, s_2, … s_n}$ of size n and a positive integer T, does there exist a suset A of {1,2,…,n} such that $S_i = \Sigma_{i \in A} s_i$?</li>
      <li>훔칠 것들의 무게 s,</li>
      <li>이중에 몇 개를 뽑는다. 뽑은 것들의 합이 주어진 s와 같게 해줄 수 있느냐?
        <ul>
          <li>S라는 집합이 있고 T가 주어졌을 때, 몇 개를 뽑아 T값이 나오도록 하는 선택이 가능하냐 (T보다 더 많이 훔쳐낼 수 있냐</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>knapsack이 조금 더 어렵다
    <ul>
      <li>$subset sum \leq_p 0-1 knapsack$ (polynomial time에 transform이 가능하다)</li>
      <li>Polynomial Reduction: from suset sum to 0-1 knapsack
        <ul>
          <li>0-1 knapsack만  polynomial time에 풀 수 있으면 subset sum도 풀 수 있다.</li>
        </ul>
      </li>
      <li>둘 다 정답 Yes or No</li>
    </ul>
  </li>
</ul>

<p>언제 n, s_1, s_2, ..n에서 합이 정답이 S가 나올까? 넘으면 Yes, 아니면 No</p>

<p>문제의 답이 No면 정답도 No를 출력해 줌.</p>

<p>해당 답을 가지고 transform을 통해 parameter를 만들어 냄 : n은 그대로 n으로 가고, w1..wn과 p1,,, pn을 만들어냄. 어떻게 하면 될까? →</p>

<p>n은 그대로 집어넣고,  s1_… sn은 w1…wn에 그대로 넣고 T값을 W, T에도 넣어줌</p>

<ul>
  <li>0-1 knapsack에서 w1, w2, .. wn - p1, p2, … pn → 뽑은 것들의 $\Sigma s_i \geq T, \Sigma s_i \leq T \rightarrow \Sigma s_i = T$</li>
  <li>이 중에 몇개를 뽑아서 합이 T가 되도록 하는 것이 가능하냐
    <ul>
      <li>문제를 transform : 언제 Yes를 출력할까? 우리가 이 문제에서 (가방 용량 허용하는 선에서 물건을 훔치는데 훔친 가격의 합이 T보다 크면 Yes.) (profit, 무게를 subset sum에서의 값으로 바꾸었으니까 $\Sigma s_i \geq T, \Sigma s_i \leq T \rightarrow \Sigma s_i = T$가 가능한가.</li>
    </ul>
  </li>
  <li>Transform
    <ul>
      <li>집어넣는 과정 : linear time에 가능</li>
    </ul>
  </li>
  <li>0-1 knapsack
    <ul>
      <li>Polynomial time</li>
    </ul>
  </li>
  <li>subset sum
    <ul>
      <li>0-1 knapsack으로 polynomial reduction으로 전환</li>
      <li>np hard라고 증명 = polynomial에 찾는 게 사실 말이 안됨
        <ul>
          <li>찾지도 못했고 없다고 증명도 못했고</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Fact 2읽어보기</p>

<ul>
  <li>knapsack을 polynomial에 대해 풀수 있으면 subset problem도 polynomial 시간안에
    <ul>
      <li>np complete : very hard</li>
      <li>polynomial solution을 찾아오던지, 없다고 증명하던지</li>
    </ul>
  </li>
</ul>

<p>$B,C  \in NP-Comlete$ 이면 $C \leq_p B \leq_p A$</p>

<p>Polynomial reduction을 해서 C도 NP Complete임을 증명 … 줄줄이 증명</p>

<ul>
  <li>→ 원조 문제 $X \leq_p … \leq_p B \leq_p A$
    <ul>
      <li>이미 알고 있던 np complete문제를 가지고 reduction : 태초에 문제가 하나 있어야 Polynomial reduction하여 np-complete</li>
      <li>Subset sum가지고 0-1 knapsack, …</li>
      <li>원조 문제는 무엇일까:
        <ul>
          <li>Proof by Cook</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CNF Conjunctive normal form
    <ul>
      <li>formula
        <ul>
          <li>$(p \lor q \lor s) \land (\bar q \lor r ) \land () \land () \land (\bar p \lor \bar s \lor \bar q)$</li>
          <li>or들의 and로 되어 있음</li>
          <li>신호니까 0 or 1이 input으로 들어감</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>SAT Satisfiability Problem
    <ul>
      <li>각각의 input에다가 0 or 1을 assign해서 CNF formula 결과가 true가 나오는 truth assignment가 존재하는가?</li>
      <li>실제 회로를 설계햇을 때 True로</li>
    </ul>
  </li>
  <li>3- SAT
    <ul>
      <li>CNF Formula에서 식을 3개로 제한하여 놓음 → polynomial 시간에 불가능</li>
      <li>모든 경우를 따져보면 $2^n, n!$ solution은 쉽게 나온다.</li>
    </ul>
  </li>
  <li>Cook’s Theorem
    <ul>
      <li>SAT 문제를 가지고 Clique \leq_p vertex cover \leq_p …  → NP Complete</li>
      <li>어려운 정도가 동등함 (증명되어 있음)</li>
      <li></li>
    </ul>
  </li>
  <li>NP Complete
    <ul>
      <li>이들을 모아둔 것이 ‘NP Complete’</li>
      <li>P : polynomial time algorithm 문제를 모두 모아둔 것</li>
      <li>NP Complete = $NP \cap NP Hard$
        <ul>
          <li>polynomial solution을 찾아오던지 or 없다고 증명하던지</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>BP</p>

<ul>
  <li>동영상에 넣어 출력하자</li>
</ul>

<p>Independent Set</p>

<ul>
  <li>알고 봤더니 1,2번이 싸웠더라 - 3,6,7은 3각관계라서 서로 마주치면 안된다 - 내일 파티를 하는데 싸운 애들은 나타나지 않게 한다. 모든 구성원과 서로의 관계를 줄 때, 최대로 인원을 뽑은 경우</li>
  <li>Ex.
    <ul>
      <li>1,4,5,6 → 싸우지 않은 괜찮은 사람들의 조합</li>
    </ul>
  </li>
  <li>sol : Exponential time algorithm</li>
</ul>

<p>→ 이런 문제들에 대해서 어덯게 대처할 것인가</p>

<ul>
  <li>Approximation Algorithm for BP : FFD Approach</li>
  <li>최대 solution은 못 찾지만 어느정도의 범위는 보장되는 알고리즘
    <ul>
      <li>애매한 89% 정도까지는 최적의 솔루션이 보장되는 polynomial time solution</li>
      <li>heuristic algorithm은 페이던스?케이던스라는 미국 회사에서 제공해주는 알고리즘 사용 (실제 반도체 회로에서의 유효성을 검증하기 위한 heuristic)</li>
    </ul>
  </li>
</ul>

<h1 id="bin-packing">Bin Packing</h1>

<p>Examples</p>

<ul>
  <li>제한된 용량의 CD에다 파일을 저장하는데, CD에다 굽고싶은 경우.</li>
  <li>2^n 알고리즘으로 쉽게 생각할 수 있음 → 그러나 np-hard로서 없을 것이라고 추정만 하는 상태</li>
</ul>

<h2 id="why-bp-is-a-hard-problem">why bp is a hard problem?</h2>

<ul>
  <li>
    <partition prob="">
</partition>
    <ul>
      <li>A의 부분집합인 A’과 A에서 A’ 뺀 차집합이 가능하냐 가능하지 않느냐.</li>
    </ul>
  </li>
  <li>if we have a polynomial time algorithm for the bin packing problem,
    <ul>
      <li>집합이 있을 때 이를 두 부분으로 나누어 각자 맞</li>
    </ul>
  </li>
  <li>$PARTITION \leq_p BP$
    <ul>
      <li>문제들 간 어떻게 연결이 되어있느냐 이해하기</li>
    </ul>
  </li>
</ul>

<h2 id="3-sat">3 SAT</h2>

<h2 id="vertex-cover-vc">Vertex Cover (VC)</h2>

<ul>
  <li>Vertex 와 Edge로 구성된 graph가 있을 때, 꼭짓점 중 몇 개를 뽑을 것인가 : 해당 graph의 어떤 edge를 가지고 와도 빨간 애가 항상 연결되어 있는 - 어떤 애를 가져와도 최소한 빨간 애가 항상 연결되어 있는 경우</li>
  <li>간단해 보이나 쉽지 않다 :
    <ul>
      <li>exponential alg르 푸는건 쉽지 않을 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="set-cover">Set Cover</h2>

<p>S라는 집합이 있는데, 그들의 부분집합이 존재한다. 그 m개의 부분집합에서 많아야 k개를 뽑아서 그들의 합집합이 S가 되게 함이 가능한가? → Yes or No</p>

<p>많아야 최대 k개까지 뽑아서 그들의 합집합이 S가 되게 하는 것이 가능한가?</p>

<ul>
  <li>Example</li>
  <li>$VC \leq_p SC$
undefined
$S = {S_1, S_2, … S_n}$</li>
</ul>

<p>NP, NP Complete</p>

<h1 id="alg-lps-1">[ALG] LPS (1)</h1>

<details>
  <summary>17</summary>


![0](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/0.png)



  </details>
<details>
  <summary>21</summary>


![1](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/1.png)


![2](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/2.png)


![3](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/3.png)


![4](/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/4.png)



  </details>
<ol>
  <li>다음과 같은 문제를 고려하자.</li>
</ol>

<h1 id="17">17</h1>

<p>“NURSESRUN” 처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열을 회문 (palindrome)이라고 한다. 어떤 문자열의 부분 문자열은 원래의 문자열에서 일부 문자만 뽑아 순서를 유지하면서 나열한 문자열으로서, “ABDGI”는 “ABCDEFGHIJ”의 부분 문자열이다. 한 문자열의 부분 문자열 중 회문이면서 길이가 가장 긴 것을 Longest Palindromic Subsequence (LPS)라 한다 (예를 들어, “BBABCBCAB”의 LPS는 “BABCBAB” 임). 이제 주어진 문자열의 LPS를 찾는 문제를 생각하자.</p>

<p>입력 문자열 X[1],X[2], XOX1X2…X-1의 각 문자들이 배열 X[0], x[n-1] 에 저장되어 있다고 하자.조건0 ≤i≤j≤n-1을 만족하는 모든 i, j에 대해 L[i][j]를 X[i]에서 X[j]까지의 연속한 문자열, 즉 XiXi1Xi-2…Xj의 부분 문자열 중 가장 길이가 긴 회문의 길이를 나타낸다고 하자.</p>

<p>가. L[i][i] 값은 무엇인가?</p>

<p>→ L[i][i] = 1</p>

<p>나, i&lt;j인 모든 i, j에 대해 L[i][j] 값은 dynamicprogramming 기법의 원리를 고려하여 다음과 같이 구할 수 있다. 이때 빈칸에 들어갈 내용을 정확히 기술하라. (힌트: 주어진 문자열에 대해 가급적 앞에서나 뒤에서 문자를 한 개씩 제거하여 문제의 크기를 줄일 것)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
<span class="c1">//      L[i][j] = max(L[i+1][j], L[i][j-1]);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span> <span class="c1">// X[i] == X[j]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">//          L[i][j] = L[i+1][j-1] + 2;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h1 id="21">21</h1>

<p>다음과 같은 Longest Palindromic Subsequence 문제를 고려하자.</p>

<p>“NURSESRUN” 처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열을 회문 (palindrome)이라고 한다. 어’떤 문자열의 부분 문자열은 원래의 문자열에서 일부 문자만 뽑아 순서를 유지하면서 나열한 문자열으로서, “ABDGI”는 “ABCDEFGHIJ”의 부분 문자열이다. 한 문자열의 부분 문자열 중 회문이면서 길이가 가장 긴 것을 Longest Palindromic Subsequence (LPS)라 한다(예를 들어, “BBABCBCAB” 의 LPS는 “BABCBAB” 임). 이제 주어진 문자열의 LPS를 찾는 문제를 생각하자.</p>

<p>입력 문자열 X0X1X2…X-1의 각 문자들이 배열 X[0], X[1], X[2], …, x[n-1] 에 저장되어 있다고 하자. 조건 0≤i≤j≤n-1 을 만족하는 모든 i, j에 대해 L[i][j]를X[i]에서 X[j]까지의 연속한 문자열, 즉 XiXi+1Xi+2…X의 부분 문자열 중 가장 길이가 긴 회문의 길이를 나타낸다고 하자. 이제 다음과 같은 코드에 대하여 dynamic programming 기법에 기반을 두어 위 문제를 해결해주는 두 함수 Fillup_L_M_Tables()와 Print_LPS()를 구현하려고 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="cp">#define L(i, j) *(T_L+ (j)-(i))*n - ((j)-(i)-1)*((j)-(i))/2+i)
#define M(i, j) *(T_M+ (j)-(i))*n - ((j)-(i)-1)*((j)-(i))/2+i)
</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">T_L</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">lps</span><span class="p">,</span> <span class="o">*</span><span class="n">T_M</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Find_LPS</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T_L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">T_M</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">lps</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

    <span class="n">Fillup_L_M_Tables</span><span class="p">();</span>
    <span class="n">Print_LPS</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"input_O.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)))</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error in reading the file %s. Wn"</span><span class="p">,</span> <span class="s">"input_0.txt"</span><span class="p">);</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="err">'</span><span class="n">WO</span><span class="err">'</span><span class="p">;</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"^^^Input size is %d.Wn"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"^^^Input sequence is %s. WnWn"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">Find_LPS</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>먼저 함수 Fillup_L_M_Tables()의 구현을 보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'L': remove left end, 'R': remove right</span>
<span class="c1">// 'B': remove both ends, 'U': use it</span>
<span class="kt">void</span> <span class="nf">Fillup_L_M_Tables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">가</span><span class="p">);</span>
        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'U'</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">{</span>

                <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">나</span><span class="p">);</span>
                <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'B'</span><span class="p">;</span>

                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'R'</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">dist</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="n">dist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dist</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">다</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="p">{</span>
                        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">라</span><span class="p">);</span>
                        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'R'</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="err">마</span><span class="p">);</span>
                        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'L'</span><span class="o">:</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>가. (6점)이 코드의 Li,i)는 L[i][i]를 나타내는데, (가)에 부분에 들어갈 값은 무엇인지 그 이유는 무엇인지 설명하라.</p>

<p>나. (6점)다음 (나)에 부분에 들어갈 값을 기술하라.</p>

<p>다. (8점)이 코드의 문맥을 볼 때 (다)에 부분에 들어갈 문자는 무엇인지 기술하라.</p>

<p>라. (12점)이 코드의 문맥을 볼 때 (라)와 (마)에 부분에 들어갈 내용을 C/C++ 문법에 맞게 정확히 기술하라.</p>

<p>다음 함수 Print_LPS()의 구현을 보자.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Print_LPS</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"The length of a LCS is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'B'</span><span class="p">:</span>
            <span class="p">(</span><span class="err">바</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="sc">'R'</span><span class="p">:</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'L'</span><span class="p">:</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'U'</span><span class="p">:</span>
            <span class="n">lps</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="err">사</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">kk</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">kk</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kk</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">kk</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">lps</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">lps</span><span class="p">[</span><span class="n">kk</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">lps</span><span class="p">[</span><span class="mi">2</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"***The found LPS is %s.WnWn"</span><span class="p">,</span> <span class="n">lps</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>마. (8점)이 코드의 문맥상 (바)에 부분에 들어갈 내용을 C/C++ 언어 문법에 맞게 정확히 기술하라.</p>

<p>바. (8점)이 코드의 문맥상 (사)에 부분에 들어갈 내용을 C/C++ 언어 문법에 맞게 정확히 기술하라.</p>

<p>사. (8점) 다음과 같은 내용의 입력 파일에 대하여.</p>

<p>9</p>

<p>BBABCBCAB</p>

<p>이 프로그램 수행 결과 구한 L 테이블의 내용은 다음과 같다.</p>

<p><img src="/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/5.png" alt="5" /></p>

<p>이때 L[1][8] 값을 구하는데 필요했던 L 테이블의 원소 L[x][y]의 인덱스를 기술하라.</p>

<p>(주의: 답은 (1, 8)-&gt; (2, 4)와 같이 기술하며, 두 개 이상의 원소가 필요하였다면 각 원소의 인덱스를 기술할 것)</p>

<p>아. (8점) (위 문제에 이어서) 이때 L[1][7] 값을 구하는데 필요했던 L 테이블의 원소 L[x][y]의 인덱스를 기술하라. (주의: 답은 (1, 7) -&gt; (2, 4)와 같이 기술하며, 두 개 이상의 원소가 필요하였다면 각 원소의 인덱스를 기술할 것)</p>

<p>자. (15점) 동일한 내용의 입력 파일에 대하여, 이 프로그램 수행 결과 구한 M 테이블의 내용은 아래와 같다.</p>

<p><img src="/assets/img/2022-09-30-[ALG]-4.3.-Misc..md/6.png" alt="6" /></p>

<p>이때 Print_LPS() 함수의 while 문장에서 Ips[] 배열을 구축하는 과정에서 방문한 이 테이블의 인덱스는 다음과 같은데 아래의 빈칸을 메꾸어라.</p>

<p>(0, 8)-&gt; (?, ?) -&gt; (?, ?)-&gt; (?, ?)-&gt; (?, ?) -&gt; (4,4)</p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] Huffman (1)]]></summary></entry><entry><title type="html">[ALG] 4.2. DP Application</title><link href="http://localhost:4000/ALG-4.2.-DP-Application" rel="alternate" type="text/html" title="[ALG] 4.2. DP Application" /><published>2022-09-29T00:00:00+09:00</published><updated>2022-09-29T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.2.-DP-Application</id><content type="html" xml:base="http://localhost:4000/ALG-4.2.-DP-Application"><![CDATA[<h1 id="alg-45-응용1-longest-common-subsequence-lcs-1">[ALG] 4.5. [응용1] Longest Common Subsequence (LCS) (1)</h1>

<h1 id="longest-common-subsequences-lcs">Longest Common Subsequences LCS</h1>

<blockquote>
  <p>💡 공동으로 갖는 common subsequence의 길이가 얼마나 긴가</p>
</blockquote>

<ul>
  <li><strong>[T. Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009. 16.3]</strong></li>
  <li>Definitions
    <ul>
      <li>Given a sequence $X = &lt;x_1, x_2, …, xm &gt;$ another sequence $Z = &lt;z_1, z_2, …, zk &gt;$ is a <strong>subsequence</strong> of X if there exists a strictly increasing sequence $&lt;i_1, i_2, …, i_k &gt;$ of indices of <em>X</em> such that $\forall j = 1, 2, …, k$, we have $x_{ij} = z_j$
        <ul>
          <li>A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out.</li>
          <li>sequence : 나열한 것 / subsequence : 해당 sequence에서 순서를 유지하며 뽑아낸 형태
            <ul>
              <li>Ex. ABCDEFGHI → ABD, AEFGH, AFI, … 등이 있다.
                <ul>
                  <li>(단, 앞에서부터가 아니라 순서가 뒤바뀐 IHE, BIDEHF 와 같은 문자열은 부분 문자열이 될 수 없다)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>empty sequence : 0개의 element로 구성된 것</li>
          <li>Ex: $\ X=&lt;A,B,C,B,D,A,B&gt;, \ Z=&lt;B,C,D,B&gt;(&lt;2,3,5,7&gt;)$
undefined	- Given two sequences <em>X</em> and <em>Y</em>, we say that a sequence <em>Z</em> is a <strong>common subsequence</strong> of <em>X</em> and <em>Y</em> if <em>Z</em> is a subsequence of both <em>X</em> and <em>Y</em>.</li>
          <li>
            <p>Ex:</p>

            <p>$X = &lt;A, B, C, B, D, A, B&gt;, \ Y = &lt;B, D, C, A, B, A&gt;,\ Z_1 = &lt;B, C, A&gt;,\ Z_2 = &lt;B, C, B, A&gt;,\ Z_3 = &lt;B, D, A, B&gt;$</p>
          </li>
        </ul>
      </li>
      <li>Given a sequence $X = &lt;x_1, x_2, …, x_m &gt;, X_i = &lt;x_1, x_2, …, x_i &gt;$ is the ith <strong>prefix</strong> of <em>X</em>, for $i = 0, 1, …, m$
        <ul>
          <li>prefix 접두사 :
            <ul>
              <li>sequence가 있을 때 앞에서 네개 뽑은 X4가 prefix of sequence</li>
            </ul>
          </li>
          <li>Ex: $X = &lt;A, B, C, B, D, A, B&gt;, \ X_4 = &lt;A, B, C, B&gt;,\ X_0 =$null sequence</li>
          <li>empty vs null : 두 용어 모두 같은 맥락으로 활용됨
undefined- Problem</li>
        </ul>
      </li>
      <li>생물 DNA 염기서열 : 얼마나 둘이 유사한가 비교한다
        <ul>
          <li>metric 정의 : 문제에 따라서, 상황에 따라서 어떻게 결정하느냐에 따라서 알고리즘을 만들어 문제를 해결한다.</li>
          <li>Longest common subsequence를 찾아서, 얼마나 긴가 확인하는 문제</li>
        </ul>
      </li>
      <li>Given two sequences $X = &lt;x_1, x_2, …, x_m &gt;$ and $Y = &lt;y_1, y_2, …, y_n &gt;$
        <ul>
          <li>m, n만큼의 두 개 sequence가 주어졌을 때 가장 긴 common sequence를 찾아서 얼마나 긴가를 가지고 판단할 것이다.</li>
        </ul>
      </li>
      <li>
        <p>find a <strong>longest common subsequence</strong> of <em>X</em> and <em>Y</em>.</p>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/0.png" alt="0" /></p>

        <ul>
          <li>optimal substructure : 어떻게든지 문제 하나 사이즈를 조금씩 줄여서, optimal solution을 찾는다. 가장 긴 것 - maximization problem와 일맥 상통</li>
          <li>problem input size : $(m,n)$
            <ul>
              <li>m : X sequence의 길이, n : Y Sequence의 길이</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Naïve approach
    <ul>
      <li>x의 모든 Subsequence에 대하여 y의 subsequence인지 확인</li>
      <li>Enumerate all subsequences of X and check each subsequence to see if it is also a subsequence of Y, keeping track of the longest subsequence found.
        <ul>
          <li>→ Exponential algorithm!
            <ul>
              <li>$\Theta(n \cdot 2^m)$ :  x의 원소개수 m, y 원소개수 n
                <ul>
                  <li>$2^m$ : x의 모든 Subsequence 개수</li>
                  <li>$\Theta(n)$ : n개의 Element check time</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>The LCS problem can be solved efficiently using dynamic programming.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 중요한 내용 !!</p>
</blockquote>

<ul>
  <li><strong>Optimal substructure of the LCS</strong>
    <ul>
      <li>Let $X = &lt;x_1, x_2, …, x_m &gt;$ and $Y = &lt;y_1, y_2, …, y_n &gt;$ be sequences, and let $Z = &lt;z_1, z_2, …, z_k &gt;$ be any LCS of <em>X</em> and <em>Y</em>.
        <ol>
          <li>If $x_m = y_n$, then $z_k = x_m = y_n$, and $Z_{k-1}$ is an LCS of $X_{m-1}, Y_{n-1}$</li>
          <li>If $x_m \neq y_n$, then an LCS of <em>X</em> and <em>Y</em> is
            <ol>
              <li>either an LCS of $X_{m-1}$ and <em>Y</em></li>
              <li>or an LCS of <em>X</em> and $Y_{n-1}$
       - → pink the longer sequence!</li>
            </ol>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>앞의 것을 하나 빼던지, 뒤에서 하나 빼던지, 앞 뒤에서 각각 하나 빼던지</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![1](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/1.png)
</code></pre></div></div>

<ul>
  <li>Let <em>c</em>[<em>i</em>,<em>j</em>] be the length of an LCS of the sequences <em>Xi</em> and <em>Yj</em></li>
  <li>Optimal substructure for computing $c[i, j]$
    <ul>
      <li>base case : 0 (empty sequence)</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/2.png" alt="2" /></p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">==</span><span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">else</span> 
    <span class="n">retrun</span> <span class="nf">max</span><span class="p">(</span><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">),</span><span class="nc">LCS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="451omnalgorithm">4.5.1. $O(mn)$ Algorithm</h2>

<ul>
  <li>Filling the table
    <ul>
      <li>b, c table 계산 : $\Theta(mn)$</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/3.png" alt="3" /></p>
  </li>
  <li>Printing the LCS
    <ul>
      <li>$\Theta(m+n)$</li>
    </ul>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/4.png" alt="4" /></p>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/5.png" alt="5" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/6.png" alt="6" /></p>

<h2 id="452-c-implementation">4.5.2. C Implementation</h2>

<ul>
  <li>
    <p>Courtesy of <a href="http://www.bioalgorithms.info/downloads/code/">link</a></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/** Copyright (C) 2005 Neil Jones. **/</span>
  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="kt">char</span> <span class="o">*</span><span class="nf">LCS</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
  <span class="cp">#define NEITHER 0
</span>  <span class="cp">#define UP 1
</span>  <span class="cp">#define LEFT 2
</span>  <span class="cp">#define UP_AND_LEFT 3
</span>  <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
  <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">LCS</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
  <span class="p">}</span>
	
  <span class="kt">char</span> <span class="o">*</span><span class="nf">LCS</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
      <span class="kt">int</span> <span class="o">**</span><span class="n">S</span><span class="p">;</span>
      <span class="kt">int</span> <span class="o">**</span><span class="n">R</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">ii</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">lcs</span><span class="p">;</span>
	
      <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
      <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
          <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">jj</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">jj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">jj</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP_AND_LEFT</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">else</span>
              <span class="p">{</span>
	
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">NEITHER</span><span class="p">;</span>
              <span class="p">}</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">jj</span><span class="p">];</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>
              <span class="p">}</span>
	
              <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">])</span>
              <span class="p">{</span>
                  <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
                  <span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">LEFT</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
	
      <span class="n">ii</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">jj</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
      <span class="n">pos</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">];</span>
      <span class="n">lcs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
      <span class="n">lcs</span><span class="p">[</span><span class="n">pos</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="nb">NULL</span><span class="p">;</span>
	
      <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">jj</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">UP_AND_LEFT</span><span class="p">)</span>
          <span class="p">{</span>
	
              <span class="n">ii</span><span class="o">--</span><span class="p">;</span>
              <span class="n">jj</span><span class="o">--</span><span class="p">;</span>
	
              <span class="n">lcs</span><span class="p">[</span><span class="n">pos</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">UP</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ii</span><span class="o">--</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">jj</span><span class="p">]</span> <span class="o">==</span> <span class="n">LEFT</span><span class="p">)</span>
          <span class="p">{</span>
	
              <span class="n">jj</span><span class="o">--</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">ii</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">ii</span><span class="p">]);</span>
          <span class="n">free</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">ii</span><span class="p">]);</span>
      <span class="p">}</span>
	
      <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">lcs</span><span class="p">;</span>
  <span class="p">}</span>
	
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-46-응용2-the-gapped-alignment-problem-1">[ALG] 4.6. [응용2] The Gapped Alignment Problem (1)</h1>

<h1 id="gapped-alignment-problem">Gapped Alignment Problem</h1>

<ul>
  <li>Problem
    <ul>
      <li>Given two sequences, find a gapped alignment that maximize the score!</li>
      <li>Compare two sequences if they are similar (related).</li>
      <li>Gapped alignment
        <ul>
          <li>Example:
            <ul>
              <li>실험을 하다보면 불완전하기 때문에 Gap을 넣는 것을 허용하고 align하자.</li>
              <li>수치적으로 얼마나 유사한지 밝히기 : mismatch가 일어나면 안되니까</li>
              <li>
                <p>Gap에 대해서는 penalty를 크게 준다</p>

                <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/7.png" alt="7" /></p>
              </li>
            </ul>
          </li>
          <li>A possible alignment scoring scheme
            <ul>
              <li>Ex: match score = 2, mismatch penalty = -1, gap penalty = -2</li>
              <li>이러한 점수 기준으 들어갔을 때, 점수를 최대화해주는 Gap Alignment를 찾아라
                <ul>
                  <li>Ex. 각각 Gap을 집어넣으면 1점, 7점인데 이러한 점수를 최대화해주는 Gap 정렬방법 찾기</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/8.png" alt="8" /></p>
      </li>
      <li>
        <p>case : 위치를 일치시키고 / A에다 Gap을 집어넣어 정렬/ B에다 Gap을 집어넣어 정렬</p>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/9.png" alt="9" /></p>
      </li>
    </ul>
  </li>
  <li>경우에 따라 문제 사이즈 줄이기
    <ul>
      <li>$A = a_1 a_2 a_3 … a_m$, $B = b_1 b_2 b_3 … b_m$</li>
      <li>recursive한 구조 구축 : 제일 끝 부분의 character가 $a_i b_j$</li>
      <li>두 sequence의 가장 끈 부분을 어떻게 처리할 것인가</li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/10.png" alt="10" /></p>
      </li>
      <li>$S(i, j)$ : maximize했을 때의 score</li>
      <li>basis :
        <ul>
          <li>$i=0$ → b의 길이에다가 -2배</li>
          <li>$j=0 $ → a의 길이에다가 -2배</li>
        </ul>
      </li>
      <li>a쪽에다가 gap을 집어넣을 수밖에 없다.</li>
      <li>$S(i,j-1)-2 $
        <ul>
          <li>Gap을 넣어 - 이점 받고 b i-1로 maximize하자</li>
        </ul>
      </li>
      <li>$S(i-1,j)-2$
        <ul>
          <li>Gap을 넣어 - 이점 받고 a i-1로 maximize하자</li>
        </ul>
      </li>
      <li>$s(a_i, b_j) $
        <ul>
          <li>a_i, b_j 넣었을 때 나오는 score</li>
          <li>같으면 2점, mismatch하면 -1점, gap penalty -2점</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DP
    <ul>
      <li>recursive top down이면 답을 못보고 문제 작은 것부터 차근차근 풀어내면 얻어낼 수 있음</li>
      <li>table 구성, 초기화, table fill 을 통해 큰 문제의 정답 찾기,
        <ul>
          <li>어디에다가 Gap을 넣어 정보를 정렬할 것인지 : 점수 table이 필요하고, maximum 구했을 때 max(S, S,S)에서 정보를 취했는지 저장하고 어디에 몇번째에 gap을 저장했는지 출력하기</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="alg-47-응용3-longest-increasing-subsequence-lis-1">[ALG] 4.7. [응용3] Longest Increasing Subsequence (LIS) (1)</h1>

<h1 id="problem">Problem</h1>

<ul>
  <li>Given a sequence $A=(a[0], a[1],…,a[n-1])$, find the length of the longest subsequence such that all elements of the subsequence are sorted increasing order.
    <ul>
      <li>순서를 유지한 subsequence : 값이 증가하는 속성을 가진</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>$(10, 22, 9, 33, 21, 50, 41, 60, 80)→(10, 22, 33, 50, 60, 80)$
        <ul>
          <li>(22, 9, 50, 41)은 increasing subsequence가 아님</li>
          <li>80으로 끝나는 LIS</li>
          <li>→ 직전으로 끝나는게 60이었고, 다시 60으로 끝나는 LIS</li>
          <li>→ ..</li>
        </ul>
      </li>
      <li>$(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)\→(0, 2, 6, 9, 11, 15), \(0, 4, 6, 9, 11, 15) …$</li>
    </ul>
  </li>
  <li>Algorithm
    <ul>
      <li>Let $d[i]$ be the length of the LIS that ends in the element at index <em>i</em>. Then, the answer to the LIS problem is the maximum value of $d[i], i=0,1,…,n-1$
        <ul>
          <li>(a[1], a[2] … a[i]) 까지만 생각했을 때 a[i]로 끝나는 LIS 를 생각해보자</li>
        </ul>
      </li>
      <li>increasing subsequence중 가장 길이가 긴 것을 찾아라</li>
    </ul>
  </li>
</ul>

<h1 id="optimal-substructure">Optimal substructure</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$$
d[i] = \max(1, \max_{j=0,...,n-1/ a[j]&lt;a[i]}{(d[j]+1)})
$$


$i=0,1,..., n-1$

- 가장 큰 것 : 그 길이가 가장 긴 것이 좋음
- d[i] : 5로 끝나는 longest increasing subsequence의 길이로 정의 → 각각의 위치에서 해당하는 d[i]의 길이를 정의한 다음 maximum을 취한다. 모든 d[i]를 구해 maximum을 구하는데 그 lis 길이 구하기
- $(0, 8, 4, 12, 2, 10, 6, 14, 1, 9)$
	- a[i]로 끝나는 lis의 바로 전에 오는 애가 되려면 1은 9보다 값이 작아야 함.
	- 나보다 앞에있는 애들 중에 나보다 작은 애들만 고려해야 함 : 9로 끝나는 LIS가 있을 때 바로 앞에 있는 애는
	- 거기에 있는 애들 중에 나보다 값이 작은 애들이 그 앞에 올 대상이 되어야 함
		- 9보다 작은 0, 8, 4, 2, 6, 1
		- ~~~ 4, 9 / ~~~~ 0, 9 / ~~~ 1, 9
		- 복잡해 보이지만 경우의 수를 찾다보면 자연스럽게 나오는 과정
	- recursive하게 1로 끝나는 LIS를 계산한 다음, 1을 더해 위치를 옮기면 9로 끝나는 위치가 됨. - base step : 1
- d[i]를 i=0~n-1에서 계산하는데 max(d[j]+1)을 계산하기 위한 for loop - table 구성
- 2dim table을 많이 봤지만 이 문제에서는 1dim table로 정의
- 1 dim table 원소 n개 : d[0] - d[1] - … d[n-1] - 알고리즘의 시간복잡도 추정
- 각각의 d[i]에 대해서 값을 계산할 것인데, table을 채울 time complexity는 input size n
- $O(n^2)$
- 나보다 작은 아이들가지고 훑기 : a[i]보다 작은 애들을 가지고 훑음. 그럼 해당 element의 비용은 나보다 앞에 잇는 애들이고 모든 element에 대해서 계산하는 것이므로 - code

```c
int LIS(int *a, int N)
{

    int *best, *prev, i, j, max = 0;

    best = (int *)malloc(sizeof(int) * N);
    prev = (int *)malloc(sizeof(int) * N);
    for (i = 0; i &lt; N; i++)
        best[i] = 1, prev[i] = i;

    for (i = 1; i &lt; N; i++)
        for (j = 0; j &lt; i; j++)
            if (a[i] &gt; a[j] &amp;&amp; best[i] &lt; best[j] + 1)
                best[i] = best[j] + 1, prev[i] = j;
    for (i = 0; i &lt; N; i++)
        if (max &lt; best[i])
            max = best[i];

		// Print the LIS using prev[] here. 
		free( best ); 
		free( prev );
		return max;
}
```
</code></pre></div></div>

<ul>
  <li>best array
    <ul>
      <li>= d table</li>
    </ul>
  </li>
  <li>prev array
    <ul>
      <li>= e table : 같은 size</li>
      <li>찾아가는 table</li>
      <li>LIS의 길이가 얼마인가 출력</li>
    </ul>
  </li>
  <li>주어진 input sequence가 있을 때, 길이가 같은데 서로 다른게 있을 수 있음
    <ul>
      <li>같은 길이인데 서로 다른 increasing sequence</li>
      <li>→ unique하진 않더라도, 분명히 최소 하나는 존재한다.</li>
    </ul>
  </li>
</ul>

<p>LIS의 직전의 element를 찾아가면 해당 나머지 subsequence에서 optimal substructure를 찾아라. 지금까지 한 거랑은 약간 달라서 확 와닿지 않겠지만 반복적으로 이해해보자</p>

<h1 id="minimal-triangulation">Minimal Triangulation</h1>

<ul>
  <li><strong>[A. Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983. 10.2]</strong></li>
  <li>Problem
    <ul>
      <li>Given a set of <em>n</em> vertices for <strong>convex</strong> polygon, find a triangulation such that no two chords cross each other, and the total length of the chords selected is a minimum.</li>
    </ul>
  </li>
  <li>
    <p>Counting all possible selections of chords in an inefficient way results in an exponential algorithm.</p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/11.png" alt="11" /></p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/12.png" alt="12" /></p>
  </li>
</ul>

<h1 id="alg-48-응용4-the-0-1-knapsack-problem-1">[ALG] 4.8. [응용4] The 0-1 Knapsack Problem (1)</h1>

<ul>
  <li>Problem
    <ul>
      <li>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \leq W$
        <ul>
          <li>이러한 index 집합의 부분집합을 선택하라, 이 중에 몇 개를 뽑아라</li>
          <li>$\Sigma_{i \in A} p_i$ 을 최대화하면서,  $\Sigma_{i \in A} w_i \leq W$의 조건 만족
            <ul>
              <li>훔친 물건들의 무게를 가방이 허용해야 하고, 조건 하에 물건을 훔쳐서 벌 수 있는 물건들의 가격들을 maximize</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>${w_1, w_2, …, w_n}$ - 0-1 : binary - 훔치지 않을 것인지, 훔칠 것인지</li>
      <li>${p_1, p_2, …, p_n}$ - 선택할 것인지, 말 것인지</li>
      <li>fractional : 물건을 훔칠 것인지 안 훔칠 것인지</li>
    </ul>
  </li>
  <li></li>
</ul>

<p>문제가 이해가 되지 않는다면 이해한 후 다시 들어볼 것을 추천.</p>

<ul>
  <li>Example
    <ul>
      <li>${w_1, w_2, …, w_5} = {6,5,10,3,4}$
        <ul>
          <li>1, 2, 5 weight의 합은 15</li>
        </ul>
      </li>
      <li>${p_1, p_2, …, p_5} = {9,7,11,6,8}, W=15$</li>
      <li>$\rightarrow {1,2,5}$
        <ul>
          <li>각각 1번, 2번, .. , 5번 부분집합을 선택하면 1,2,5 뽑힌것의 w합은</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>An intuitive interpretation
    <ul>
      <li>There are <em>n</em> items in a store. 가 게에 N개의 물건이 있는데</li>
      <li>The <em>i</em> th item weighs <em>wi</em> kilograms and is worth <em>pi</em> wons, where <em>wi</em> and <em>pi</em> are positive integers.
        <ul>
          <li>i번째 물건은 Wi kg이고 Pi원이다.</li>
        </ul>
      </li>
      <li>A thief has a knapsack that can carry at most <em>W</em> kilograms, where <em>W</em> is a positive integer.
        <ul>
          <li>도둑이 W까지만 담을 수 있는 배낭을 가지고 왔다.</li>
        </ul>
      </li>
      <li>What items should the thief take to maximize his “profit”?
        <ul>
          <li>최대한 이윤을 얻을 수 있게 물건을 훔치는 방법</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="0-a-0-1-knapsack-problem-in-real-life">0. A 0-1 Knapsack Problem in Real Life</h1>

<p><a href="http://standardwisdom.com/softwarejournal/2010/03/bang-for-the-buck-knapsacks-in-real-life/">ref</a></p>

<ul>
  <li>Problem
    <ul>
      <li>
        <p>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \leq W$</p>

        <p>각각의 다른 value, weight를 갖는 item 여러 개기 있다. knapsack은 W kg까지 수용 가능할때, knapsack에 담을 최대 value는 얼마인가</p>
      </li>
      <li>You have a marketing budget of 5 million dollars. (500만 불이라는 홍보비)</li>
      <li>You have the following marketing options and their paybacks in new potential customers:</li>
    </ul>
  </li>
  <li>Which marketing campaigns would you choose to <strong>maximize the total expected reach</strong> under the condition that, for each of these marketing campaigns, you either select it or you don’t?
    <ul>
      <li>많은 사람들에게 노출</li>
      <li>내가 지불한 비용의 합이 500만보다 작거나 같게 : 1,2,3, …, N번</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/13.png" alt="13" /></p>

<ul>
  <li>cost (dollar) - expected reach (people)
    <ul>
      <li>노출되는 사람들의 수</li>
    </ul>
  </li>
</ul>

<h1 id="1-how-to-solve-the-0-1-knapsack-problem">1. How to Solve the 0-1 Knapsack Problem</h1>

<ul>
  <li>Naïve approach
    <ul>
      <li>There are $2^n$ subsets of ${1, 2, …, n}!$</li>
      <li>아이템중에 선택할 수 있는 모든 경우의 수는 2^n : 각 경우에 대해서 profit들의 합이 제일 큰 것 선택</li>
      <li>모든 경우를 따져보는 경우 - 순서대로 넣을지 말지를 결정하기 때문에</li>
    </ul>
  </li>
  <li>Dynamic programming approach
    <ul>
      <li>Let $P(i,w)$ be the <strong>maximized profit</strong> obtained when choosing items *<em>only from the first ii</em> items under the restriction that <strong>the total weight cannot exceed w</strong><em><strong>w</strong></em>.
        <ul>
          <li>parameter 2개 :
            <ul>
              <li>i : 1번부터 2번, 3번, … i번까지만 앞의 i개 item중에 선택</li>
              <li>w : 현재 남은 가방의 허용하는 무게 - 나한테 남은 가방의 용량이 w만큼 남았다.</li>
            </ul>
          </li>
          <li>1번부터 i번까지 선택한 것들 중 weight 합이 W보다 같거나 작게 하는 조건에서 최대 profit의 값</li>
        </ul>
      </li>
      <li>If we let <em>A</em>∗ be an optimal subset of ${1, 2, …, n}$
        <ol>
          <li>$n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$
            <ol>
              <li>dynamic programming 내용 집어넣기 : 인자 두개를 집어넣어서 문제 사이즈를 줄여야 함</li>
              <li>이 값을 계산해야하는데, 값을 선택했을 때 profit들의 합을 maximize
                <ul>
                  <li>선택 각각가장 미지막 i번 의 무게
      - 분명히 값을 maximize하는 최적의 선택이 있는데, 가장 마지막의 n번 Item을 선택하던지 안하던지
      - $P(n,W)$ : n번 물체를 선택했다면</li>
                  <li>$p_n $ : n번 item의 Profit이 더해지고</li>
                  <li>$P(n-1, W-w_n)$ :
                    <ul>
                      <li>나머지 상황에서 maximize : 고려할 Item은 n-1개, 최대 W까지 담을 수 있는데 wn을 뺀 남은 용량</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ol>
          </li>
          <li>$n \notin A* : P(n,W) = P(n-1, W)$
            <ol>
              <li>n번 물체는 선택하면 안 되니까 P(n-1,W)</li>
              <li>recursion : 같은 형태로 표현하는데 문제 사이즈가 작아짐
                <ol>
                  <li>n번 item을 선택하든지, 말든지 + 한 물체에 대해서 나머지 item을 고려</li>
                  <li>(작아진 문제 사이즈) recursive formulation</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>Optimal substructure
        <ul>
          <li>$P(i,w)=$
            <ul>
              <li>임의의 i : 0부터 n까지 간다
                <ul>
                  <li>0 : 내가 선택할 수 있는 item이 하나도 없을 때</li>
                  <li>i : 내가 선택할 수 있는 item이 1번부터 i번까지 앞의 i개
                    <ul>
                      <li>i=3 →1,2,3중에 선택할 수 있다.</li>
                      <li>i=0 → 선택할 아이템이 없다</li>
                    </ul>
                  </li>
                  <li>w: 남은 용량 - 0부터 대문자 W까지, 대문자 W는 아직 아무것도 안들어갔을 때</li>
                </ul>
              </li>
              <li>
                <table>
                  <tbody>
                    <tr>
                      <td>0 if $i=0</td>
                      <td> </td>
                      <td>w = 0$</td>
                    </tr>
                  </tbody>
                </table>
                <ul>
                  <li>선택할 아이템이 없다</li>
                  <li>or 가방에 담을 수 없다 (용량이 0)</li>
                </ul>
              </li>
              <li>$P(i−1,w)$
                <ul>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>if $i&gt;0</td>
                          <td> </td>
                          <td>w_i &gt;w$</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                  <li>가장 마지막 물건의 무게인 w_i가 w보다 무거운 경우 자격 미달 (담을 수 없음)</li>
                  <li>i개 물체까지 선택하는 것에 대해서 마지막 것을 선택할것인지
                    <ul>
                      <li>남아있는 가방 무게에 대해서 : I번째 물체는 선택할 요건이 안된다</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>$\max {(P(i-1,w), p_i+P(i-1,w-w_i))}$
                <ul>
                  <li>I&gt;0 : 1,2,…i번 item 중에 선택
                    <ul>
                      <li>i번째 item을 담지 않을 경우 i-1개중에 잘 선택한 ,</li>
                      <li>p_i를 얻고 나머지 i-1개에 대해서 맨 마지막 item을 제외한 무게</li>
                    </ul>
                  </li>
                  <li>담을 수 있는데, 안 담을건지 vs 담을 것인지에 대한 차이
                    <ul>
                      <li>요건은 되는데 i번째 물품을 선택하지 않는게 좋다</li>
                      <li>i번 Item을 선택하는 게 이윤 극대화에 더 좋다.</li>
                    </ul>
                  </li>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>$i&gt;0</td>
                          <td> </td>
                          <td>w_i \geq w$</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>i : 0~4</li>
      <li>w : 0~W(6)</li>
      <li>${w_1, w_2, …, w_4} = {4,3,2,3}$</li>
      <li>${p_1, p_2, …, p_4} = {3,2,4,4}, W=6$</li>
      <li>어떤 순으로 방문해서 채울 것인가
        <ul>
          <li>값을 계산하는데 필요한 게 얼마나 많은지</li>
          <li>i가 하나 빠지고, 하나를 계산하기 위해서는 위에 것이 계산되면 됨
            <ul>
              <li>i-1의 식이 핵심적으로 작용하니까</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/14.png" alt="14" /></p>

<ul>
  <li>0부터 N까지 : 첫 번째 행과 열은 다 0으로 setting하고 좌에서 우로 가면서 setting</li>
  <li>Ex.
    <ul>
      <li>$P(2,4) = \max{(P(1,4), p_2 + P(1, 4-w_2))} = \max{(P(1,4), 2+P(1,1))}=3$
        <ul>
          <li>2 : 1,2중에 선택함, 2번을 담을 자격이 되는지, 안 되는지</li>
          <li>w2=3이니까 가방 용량에는 4니까 담을 수 있음 → (iii)</li>
          <li>P(1,4) : 2번 물체를 담지 않으면 값이 더 커질 것이다
            <ul>
              <li>P(2,4) 위의 줄 : 3</li>
            </ul>
          </li>
          <li>p2+ : 2번을 담겠다 + 2번을 담을 경우 1번을 선택하는 상황에서 w2를 제외한 것 = P(1,1)
            <ul>
              <li>P(1,1) = 3</li>
              <li>P_2 = 2</li>
            </ul>
          </li>
          <li>2번을 담지 않겠다.</li>
        </ul>
      </li>
      <li>$P(4,2) = P(3,2) = 4$
        <ul>
          <li>1,2,3,4중에 선택하는 것인데 4번은 선택할지말지 optimal substructure 중 선택</li>
          <li>남아있는 용량 2 : 4번은 고려 대상도 아님 → 4번은 빼버리고 1,2,3중에 선택하자</li>
        </ul>
      </li>
      <li>$P(3,5) = \max{(P(2,5), p_3 + P(2,5-w_3))} = 6$
        <ul>
          <li>3번 Item의 Weight가 2이니까 담을 수는 있는데 진짜 담을 것인지, 안 담을건지</li>
          <li>p3 =4, P(2, 5-w3) = P(2,3) = 2이므로 6</li>
          <li>두 개중에 뒤에 것이 크다 : 3번을 선택할 것이다라는 의미</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="3-how-to-reconstruct-the-solution">3. How to Reconstruct the Solution</h1>

<ul>
  <li>${w_1, w_2, …, w_4} = {4,3,2,3}$</li>
  <li>${p_1, p_2, …, p_4} = {3,2,4,4}, W=6$</li>
</ul>

<p>i번째 item을 선택할 자격도 안됨 : Weight가 더 큰 경우</p>

<p>i번째 item을 선택할 자격은 되지만: 비교</p>

<ul>
  <li>$P(4,6) = \max{(P(3,6), p_4 + P(3, 6-w_4))} = 8$
    <ul>
      <li>4번의 weight가 3이기 때문에 선택할 자격은 됨 → 4번 선택</li>
      <li>이러한 계산을 통해서 8이 나옴</li>
    </ul>
  </li>
  <li>$P(3,3) = \max{(P(2,3), p_3 + P(2, 3-w_3))} = 4$
    <ul>
      <li>3번의 item은 Weight=2라서 선택할수 있음</li>
      <li>P(2,3-2) = P(2,1) = P(1,1) = P(0,1) = 0 → i는 한 칸씩 올라가면서 선택했는지 아닌지에 대한 번호를 출력함</li>
    </ul>
  </li>
  <li>$P(2,1) = P(1,1) = 0$
    <ul>
      <li>2 X</li>
    </ul>
  </li>
  <li>$P(1,1) = P(0,1) = 0$
    <ul>
      <li>1 X</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/15.png" alt="15" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/16.png" alt="16" /></p>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/17.png" alt="17" /></p>

<h1 id="4-implementation-and-time-complexity">4. Implementation and Time Complexity</h1>

<ul>
  <li>
    <p>$O(nW)$ Time</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">zero_one_knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ww</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">ww</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ww</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">ww</span><span class="o">++</span><span class="p">)</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">ww</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ww</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">ww</span><span class="o">++</span><span class="p">)</span> <span class="c1">//bottleneck - W번 수행</span>
          <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ww</span><span class="p">)</span>
              <span class="p">{</span>
                  <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span> <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
   <span class="o">&gt;</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">])</span>
                      <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                  <span class="k">else</span>
                      <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">];</span>
              <span class="p">}</span>
              <span class="k">else</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">ww</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">W</span><span class="p">];</span>
  <span class="p">}</span>
	
	
</code></pre></div>    </div>

    <ul>
      <li>어떤 값이 상수인지 아닌지의 판단 근거는 N이 커지건 작아지건 고정되는게 상수</li>
      <li>지금 time complexity가 nW가 됨은 명확한데 이는 linear time인가?
        <ul>
          <li>table 하나당 $\Theta (1)$씩 계산</li>
          <li>$(n+1) (w+1)$ table : $\Theta(nw)$</li>
          <li>최종 solution은 table 맨 밑 행부터 하나씩 탐색 : $\Theta (n)$</li>
          <li>→ Theta(nw)</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5-0-1-knapsack-ex-1n--6-w--10n6w10">5. 0-1 Knapsack Ex. 1: n = 6, W = 10<em>n</em>=6,<em>W</em>=10</h1>

<p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/18.png" alt="18" /></p>

<ul>
  <li>쫓아가는 방법 생각해보기</li>
  <li>Selected items: i = 2, 3, 4, 6</li>
  <li>Obtained profit: 19</li>
  <li>Is the time-complexity $O(nW)$ an efficient one?
    <ul>
      <li>efficient : polynomial 시간에 bound 될 때 효율적.
        <ul>
          <li>inefficient : exponential, factorial, // n^4, n^3은 비효율적 practical하게</li>
        </ul>
      </li>
      <li>This is not a linear-time algorithm!
        <ul>
          <li>variable :
            <ul>
              <li>n : 도둑이 물건을 훔칠 때 훔칠 수 있는 물건 개수</li>
              <li>W: 도둑의 가방이 허용하는 가방의 총 용량</li>
            </ul>
          </li>
          <li>→ N에 대해서 상수라면,w를 제거하면 이 알고리즘은 linear time - polynomial이므로 효율적
            <ul>
              <li>n의 크기가 얼마든지 커져도 w가 불변?</li>
              <li>n과 w는 독립적 : w가 n에 대해서 bound가 되어야 하는데, 여기서는 독립적이라고 볼 수 있다. N도 w도 문제 상황에 따라 지정된다.</li>
            </ul>
          </li>
          <li>A problem is that <em>W</em> is not bounded with respect to <em>n</em>.
            <ul>
              <li>Ex. What if <em>n</em>=20 and <em>W</em>=20!? → $O(n∗n!)$
                <ul>
                  <li>factorial time algorithm : 더 비효율적으로 만들 수 있음.</li>
                </ul>
              </li>
              <li>When <em>W</em> is extremely large in comparison with <em>n</em>, this algorithm is worse than the brute-force algorithm that simply considers all subsets.
                <ul>
                  <li>n에 대해서도 linear, w에 대해서도 linear. n에 대해서 Polynomial하지 않다.</li>
                </ul>
              </li>
              <li>This algorithm can be improved so that the worst-case number of entries computed is $O(2^n)$</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>No one has ever found an algorithm for the 0-1 Knapsack problem whose worst-case time complexity is better than exponential, yet no one has proven that such an algorithm is not possible!
        <ul>
          <li>polynomial time alg 는 얻지도 못했고, 증명도 못함</li>
          <li>문제 size n에 대해서 증명도 찾지도 못함 — 아마 Polynomial solution이 없을 것이다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>np complete, np hard, …
    <ul>
      <li>아무도 증명하지 못한 문제</li>
      <li>n의 몇승이라는 poly sol도 못 찾았고,</li>
    </ul>
  </li>
</ul>

<h1 id="6-a-variation-of-the-0-1-knapsack-problem">6. A Variation of the 0-1 Knapsack Problem</h1>

<ul>
  <li>Problem
    <ul>
      <li>Decision Problem</li>
      <li>Given <em>n</em> items of length $l_1, l_2, …, l_n$, is there a subset of these items with total length exactly <em>L</em>?
undefined- Example</li>
      <li>${ 1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993 }, \ L = 138457{1,2,7,14,49,98,343,686,2409,2793,16808,17206,117705,117993},L=138457 → {1, 2, 7, 98, 343, 686, 2409, 17206, 117705}{1,2,7,98,343,686,2409,17206,117705}$</li>
    </ul>
  </li>
  <li>Dynamic programming approach
    <ul>
      <li>Let $P(i,w)$ be the <strong>maximized profit</strong> obtained when choosing items *<em>only from the first ii</em> items under the restriction that <strong>the total weight cannot exceed w</strong><em><strong>w</strong></em>.
undefined	- If we let <em>A</em>∗ be an optimal subset of ${1, 2, …, n}$
        <ol>
          <li>$n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$</li>
          <li>$n \notin A* : P(n,W) = P(n-1, W)$
            <ul>
              <li>$\rightarrow fill (i, j)$</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h1 id="7-a-divide-and-conquer-approach">7. A Divide-and-Conquer Approach</h1>

<ul>
  <li>
    <p>Let <code class="language-plaintext highlighter-rouge">fill(i,j)</code> return TRUE ⟺ ∃ subset of the first <em>i</em> items that has total length <em>j</em>.</p>

    <p>When <code class="language-plaintext highlighter-rouge">fill(i,j)</code> returns TRUE,</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1. If the ith item is used, `fill(i - 1, j -` _`li`_`)` must return TRUE.
  2. If the ith item is not used, `fill(i - 1, j)` must return TRUE.
</code></pre></div>    </div>
  </li>
  <li>
    <p>To solve <code class="language-plaintext highlighter-rouge">fill(int n, int L)</code>,</p>
    <ul>
      <li>$T(n)≥c $if $n=0$</li>
      <li>$T(n) \geq 2T(n-1) +d$ if $n&gt;0$</li>
      <li>$\rightarrow T(n) = \Theta(2^n)$</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fill</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// l[i]: global variable </span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">fill</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-dynamic-programming-approach">A Dynamic Programming Approach</h2>

<ul>
  <li>The optimal substructure :
    <ul>
      <li>F(i,j)=<em>F</em>(<em>i</em>,<em>j</em>)= <code class="language-plaintext highlighter-rouge">FALSE</code> if <em>i</em>=0,<em>j</em>!=0</li>
      <li>F(i,j)=<em>F</em>(<em>i</em>,<em>j</em>)= <code class="language-plaintext highlighter-rouge">TRUE</code> if <em>i</em>=0,<em>j</em>=0</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$F(i,j)= F(i-1,j)</td>
              <td> </td>
              <td>((l_i \geq j)</td>
              <td> </td>
              <td>F(i-1, j-l_i))$ if <em>i</em>&gt;0</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>O(nL) time implementation</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ll</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ll</span><span class="o">++</span><span class="p">)</span>
    <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ll</span> <span class="o">&lt;=</span> <span class="n">L</span><span class="p">;</span> <span class="n">ll</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ll</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="err">–</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ll</span><span class="p">]</span> <span class="o">||</span> <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">ll</span><span class="o">-</span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">L</span><span class="p">]);</span>
	
	
</code></pre></div>    </div>
  </li>
  <li>
    <p>Example</p>

    <p><img src="/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/19.png" alt="19" /></p>
  </li>
</ul>

<h1 id="8-subset-sum">8. Subset Sum</h1>

<p>n에 대해서 polynomial sol도 찾지 못함</p>

<ul>
  <li>Problem
    <ul>
      <li>Given a set of positive integers ${w_1, w_2, …, w_n}$ of size <em>n</em> and a postivie integer <em>W</em>, Find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i\in A}{w_i}$ subject to $\Sigma_{i\in A}{w_i} \leq W$</li>
      <li>양의 정수 n개, 어떤 양의 정수 W가 주어졌을 때 몇 개를 뽑을 것이다. a라는 집합이 뽑은 애들의 index 집합이다. 뽑은 애들의 합을 maximize하라.</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>${w_1, …, w_9} = {20,30,14,70,40,50,15,25,80,60,10,95}, W=99 \\rightarrow {20,14,40,25}$</li>
    </ul>
  </li>
  <li>Application
    <ul>
      <li>There are <em>n</em> jobs, each of which takes <em>wi</em> time.</li>
      <li>Now we have a CPU with <em>W</em> free cycles, and want to choose the set of jobs that minimizes the number of idle cycles.
        <ul>
          <li>w cycle동안에 내가 scheduling해 주어 CPU를 잘 활용해야 한다.</li>
          <li>여러 user들이 들어왔을 때, w1 cycle만큼 소요되고, 2번 user에서 들어오면 w2만큼의 cycle이 필요하고 … n번 user에서 job을 scheduling하면 wn cycle이 필요함</li>
          <li>system을 가장 최적으로 활용하기 위해, w1,, wn 중 몇 개를 뽑아서 scheduling 진행할 것</li>
          <li>뽑은 애들의 합이 W보다 작으면서 maximize : 몇번, 몇번, 몇번 해서 끝에 무수리가 남을 것인데 이 곳에서는 CPU가 idle하는 cycle 발생 : minimize가 목표</li>
        </ul>
      </li>
      <li>→ CPU Cycle이라는 귀한 resource를 낭비하지 않도록 minimize하자</li>
      <li>논외) exact algorithm는 아무도 풀지 못했다. → approximation algorithm, heuristic algorithm</li>
    </ul>
  </li>
  <li>Relation to the 0-1 Knapsack problem
    <ul>
      <li>Given two sets of positive integers ${w_1, w_2, …, w_n}$ and ${p_1, p_2, …, p_n}$ of size <em>n</em> and a positive integer <em>W</em>, find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i \in A} p_i$ subject to $\Sigma_{i \in A} w_i \geq W$</li>
      <li>⟺
        <ul>
          <li>Given a set of positive integers ${w_1, w_2, …, w_n}$ of size <em>n</em> and a postivie integer <em>W</em>, Find a subset <em>A</em> of ${1,2,…,n}$ that maximizes $\Sigma_{i\in A}{w_i}$ subject to $\Sigma_{i\in A}{w_i} \geq W$</li>
        </ul>
      </li>
      <li>0-1 knapsack을 polynomial time에 풀 수 있으면, subset sum도 풀 수 있다</li>
    </ul>
  </li>
  <li>참고
    <ul>
      <li>If it is possible to solve the <strong>0-1 knapsack</strong> problem in <strong>polynomial time</strong>, the <strong>subset sum</strong> problem can be solved in <strong>polynomial time</strong> too.</li>
      <li>Somebody has already proven that the subset sum problem is very hard.</li>
      <li>In other words, the subset sum problem is <strong>NP</strong>complete. → Hence, the 0-1 knapsack problem is also a very hard problem. In other words, the 0-1 knapsack problem is also <strong>NP</strong>complete.
undefined</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[[ALG] 4.5. [응용1] Longest Common Subsequence (LCS) (1)]]></summary></entry><entry><title type="html">[ALG] 4.1. DP - Concepts</title><link href="http://localhost:4000/ALG-4.1.-DP-Concepts" rel="alternate" type="text/html" title="[ALG] 4.1. DP - Concepts" /><published>2022-09-28T00:00:00+09:00</published><updated>2022-09-28T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-4.1.-DP---Concepts</id><content type="html" xml:base="http://localhost:4000/ALG-4.1.-DP-Concepts"><![CDATA[<ul>
  <li>divide and conquer: top - down
    <ul>
      <li>효율적이기도 하나 매우 비효율적이 되기도 함</li>
      <li>splitted된 사례들이 서로 관련 없는 문제를 풀때 잘 통함</li>
    </ul>
  </li>
  <li>dynamic programming : bottom -up
    <ul>
      <li>아래에서 위로 올라가며 효율을 추구하자는 방식</li>
    </ul>
  </li>
  <li>NOW
    <ul>
      <li>Divide-and-Conquer Method</li>
      <li><strong>Dynamic Programming Method</strong></li>
      <li>Greedy Method</li>
      <li>Backtracking Method</li>
      <li>Local Search Method</li>
      <li>Branch-and-Bound Method</li>
      <li>Etc.</li>
    </ul>
  </li>
  <li>From <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Wikipedia</a>: Dynamic programming is both a
    <ul>
      <li><u>mathematical optimization method and a computer programming method.</u></li>
    </ul>
  </li>
  <li>A complicated problem is <strong>broken down into simpler sub-problems in a recursive manner</strong>.</li>
  <li>Overlapping subproblems
    <ul>
      <li>A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.</li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.</li>
    </ul>
  </li>
  <li>When applicable, the method <u>**takes far less time than other methods**</u> that don’t take advantage of the subproblem overlap <strong>like the divide- and-conquer technique</strong>.</li>
</ul>

<p>→ 문제 몇개 풀어보고, 이 고상한 말들이 별 것 아닌 자연스러운 원리임을 체득하자!</p>

<h1 id="alg-42-approaches-for-recursive-formulation-1">[ALG] 4.2. Approaches for Recursive Formulation (1)</h1>

<p>Two Approaches for Recursive Formulation</p>

<ul>
  <li>Top Down Approach</li>
  <li>Bototm up Approach</li>
</ul>

<h2 id="421-top-down-approach">4.2.1. Top Down Approach</h2>

<ul>
  <li>$T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j \geq 1$</li>
  <li>$T(i,0) = T(0,j) = 1$ for $i,j≥0$</li>
  <li>recursive하게 똑같이 문제 두개를 푼다 : 빨간 것 하나, 녹색 하나. 그리고 그 결과를 combine하여 원래 문제를 푼다. 문제가 겹치는게 보인다.
    <ul>
      <li>divide and conquer : 상당히 많이 overlap됨을 확인할 수 있다.</li>
      <li>undefined- Easily becomes exponential!</li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/0.png" alt="0" /></p>
  </li>
</ul>

<p>recursive function call : 내려갔다 올라갔다 depth first search하다가 하염없이 돌아오는 것을 의미한다.</p>

<h2 id="422-bottom-up-approach">4.2.2. Bottom Up Approach</h2>

<ul>
  <li>$T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j≥1$</li>
  <li>$T(i,0) = T(0,j) = 1$ for $i,j \geq 0$</li>
  <li>
    <p>Often much more efficient!</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/1.png" alt="1" /></p>
  </li>
  <li>그러나 bottom up은 Top Down과 대비하여 쭉 쭉 쭉 한 줄로 내려가며 잘 풀리게 된다.
    <ul>
      <li>bottom up으로 올라오면서, 그리고 모든 경우에 divide n conquer에 비효율적이고 dp가 효율적인건 아니다.</li>
    </ul>
  </li>
  <li>Bottom up vs. Top down 공통: 둘다 어떤 문제가 재귀적인, recursive한 형태로 문제가 풀리게 된다.
    <ul>
      <li>작게 똑같이 풀어서 합치자 : recursion 한 solution이 나타나게 된다</li>
      <li>solution을 만드는데 재귀적으로 나타난다.</li>
    </ul>
  </li>
  <li>몇 개 안 되는 것을 풀면 되는데, 똑같은것을 반복적으로 보나?
    <ul>
      <li>이를 계산하는 프로그램: 이를 풀기 위해서 필요한 것은 왼쪽 하부, 오른쪽 하부</li>
      <li>거꾸로 생각해보면 : 왼쪽 아래 + 오른쪽 아래 활용해서 그 위 가운데 노드를 구할 수 있다. (아래에서 위로)</li>
    </ul>
  </li>
  <li>아무리 부정하려고 하더라도 인정할 수밖에 없는 원리.</li>
</ul>

<h2 id="423-examples">4.2.3. Examples</h2>

<h3 id="4231-ex1-world-series-odds">4.2.3.1. [ex1] World Series Odds</h3>

<ul>
  <li>Problem
    <ul>
      <li>Dodgers and Yankees are playing the World Series in which either team needs to win <em>n</em> games first.</li>
      <li>Suppose that each team has a $50%$ % chance of winning any game.</li>
      <li>Let <em>P</em>(<em>i</em>,<em>j</em>) be the probability that if Dodgers needs <em>i</em> games to win, and Yankees needs <em>j</em> games, Dodgers will eventually win the Series.
        <ul>
          <li>i번을 더 이겨야 다저스는 우승할 수 있구 양키스는 세번 이기는데 이 때 다져스기 우승할 확률은
  ?</li>
        </ul>
      </li>
      <li>Ex: $P(2, 3) = \frac {11}{16}$야
        <ul>
          <li>키스는 두번, 다저스는 3번</li>
        </ul>
      </li>
      <li>
        <p>Compute $P(i,j) 0≤i,j≤n ∀n$</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/2.png" alt="2" /></p>

        <ul>
          <li>임의의 n에 대해서 확률을 계산하라 : 그림을 보고, recursion 구조가 떠오르는가?
            <ul>
              <li>문제 사이즈 $( i,j) = (i-1,j) + (i, j-1)$</li>
              <li>0.5, 0.5 : dodgers이거나 yankees인데 dodgers가 이기면 $(i-1,j)$</li>
              <li>조건부 확률 : $P(i,j) = 0.5 P(i-1,j) + 0.5P(i, j-1)$ rl기본적인수식</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/3.png" alt="3" /></p>

<h3 id="4232-worse-a-divide-and-conquer-approach">4.2.3.2. [Worse] A Divide-and-Conquer Approach</h3>

<ul>
  <li>Recursive formulation
    <ul>
      <li>$P(i,j) =1 if i=0,j&gt;0$</li>
      <li>$P(i,j) =0 if i=0,j=0$</li>
      <li>
        <p>$P(i,j)= \frac{P(i-1,j)+P(i,j-1)}{2}=2P(i−1,j)+P(i,j−1)$</p>

        <p>if $i&gt;0, j&gt;0$</p>
      </li>
    </ul>
  </li>
  <li>overlap subproblem : overlapping하지 않으면서 size가 줄었던 dnc와 달리 overlapping된다. 굉장히 안 좋은 상황. 그래서 이를 recursive fn call 함수를 짜서 $P(100,100), P(50,50)$짜보라
    <ul>
      <li>→ 사실 돌려지지도 않는다. 시간이 너무 걸려 컴퓨터가 죽어버린다.</li>
    </ul>
  </li>
  <li>If we solve this recurrence relation in the divide-and-conquer way,
    <ul>
      <li>Let <em>T</em>(<em>n</em>) be the maximum time taken by a call to <em>P</em>(<em>i</em>),where <em>i</em>+<em>j</em> =<em>n</em>.</li>
      <li>Then we can prove that <em>T</em>(<em>n</em>) is exponential!</li>
      <li>$T(1)=1, T(n) = 2T(n-1) + c \rightarrow O(2^n)$</li>
    </ul>
  </li>
  <li>What is the problem of this approach?</li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/4.png" alt="4" /></p>

<h3 id="4323-better-a-dynamic-programming-approach">4.3.2.3. [Better] A Dynamic Programming Approach</h3>

<ul>
  <li>핵심 개념 Table
    <ul>
      <li>1D, 2D, 3D</li>
    </ul>
  </li>
  <li>$T(4,4) $: table setup 후 이를 채워나가서 (fill)
    <ul>
      <li>단ㄷ순하게 생각하면 2 중 for loop 활용하여 진행한다.</li>
      <li>0,0은 양쪽 다 우승한 것이기에 고려할 필요 없다.</li>
    </ul>
  </li>
  <li>한칸 여펴 왼쪽에 있는 애와, 한칸 아래 밑쪽에 잇는 애를 통해 계싼할 수 있다.</li>
  <li>$P(i,j) = 1 $ if $i=0, j&gt;0$</li>
  <li>$P(i,j) = 0$ if $i&gt;0, j=0$</li>
  <li>$P(i,j) = \frac{P(i-1,j) + P(i, j-1)}{2}$ if $i&gt;0, j&gt;0$</li>
  <li>fill 하는 방식
    <ul>
      <li>좌→우 (밑에서 위로): 가능</li>
      <li>밑→위 (좌에서 위로) : 가능</li>
      <li>기존의 플로우는 대각선 우상향이기때문에 가능!</li>
      <li>기교를 부리고 싶으면 ㄹor loop을 복잡하게 해서 구현할 순 있다.
        <ul>
          <li>그러나 단순하면서 잘 작동하는것이 더 중요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$T(n,n) = O(n^2)$d임을 바로 확인해야한다.
    <ul>
      <li>table 원소가 가로 n, 세로 n일 때</li>
      <li>n+1, n+1개가 있고</li>
      <li>상수시간이므로 시간 복잡도는 n자승이 된다. → 시간복잡도는</li>
    </ul>
  </li>
  <li>Instead of computing the same repeatedly, fill in a table as suggested below:
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/5.png" alt="5" /></p>
      </li>
    </ul>
  </li>
  <li>Time Complexity
    <ul>
      <li>For input size $(m, n)$, computing $P(m, n)$ takes $O(mn)$-time.</li>
      <li>
        <p>By far better than the Divide-and-Conquer approach.</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/6.png" alt="6" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>undefined
<img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/7.png" alt="7" /></p>

<ul>
  <li>DP 문제를 푸는데 이러한 recursive structure가 존재하고, 이를 divide and conquer 로 top down으로 풀어야 한다면 overlapping subproblem의 문제가발생한다.
    <ul>
      <li>상당한 양의 문제가 있다 : divide and conquer로 가지 말고 dp로 가는건 어떨까?</li>
      <li>어떤 문제를 subproblem을 통해 recursive하게 풀려 하는데 문제가 어떻게 풀리더라: dnc가 아니라 bottom up 방식으로 풀도록 생각하고</li>
      <li>table을 1차-3ㅏ차원으로 구성하고, 초기화하고, 일반화된 공식으로부터 fill 하느 방식을 알아 원소를 채워 나간다</li>
    </ul>
  </li>
  <li>각각의 subproblem
    <ul>
      <li>문제를 각각 한 번씩만 푼다 : bottom up 방식으로 table을 채워나가서 목적을 달성하는 것 : DP의 시작과 끝이다</li>
      <li>overlapping substructure 등 복잡한 거 생각할 필요 없이, 이것이 전부!</li>
    </ul>
  </li>
</ul>

<h1 id="alg-43-concepts-of-dynamic-programming-1">[ALG] 4.3. Concepts of Dynamic Programming (1)</h1>

<h1 id="dynamic-programming">Dynamic Programming</h1>

<blockquote>
  <p>Top-down → Bottom-up</p>
</blockquote>

<ul>
  <li>When the <strong>divide-and-conquer</strong> approach produces an <strong>exponential algorithm</strong> where <strong>the same sub-problems are solved iteratively</strong>,
    <ul>
      <li>Take the recursive relation from the divide-and-conquer algorithm, and</li>
      <li>replace <strong>the recursive calls with table lookups</strong> by recording a value in a table entry instead of returning it.</li>
    </ul>
  </li>
  <li>master theorem과도 연계
    <ul>
      <li>overlapping 나쁜거 (a&gt;c)</li>
    </ul>
  </li>
  <li>Three elements to consider in designing a dynamic programming algorithm
    <ul>
      <li>Recursive relation
        <ul>
          <li>Optimal substructure</li>
        </ul>
      </li>
      <li>Table setup</li>
      <li>Table fill order</li>
      <li>$B(i,j)=B(i-1,j-1) + B(i-1,j)$ if $0&lt;j&lt;i$</li>
      <li>$B(i,j)=1$ if $j=0$ or $j=i$</li>
    </ul>
  </li>
  <li>[Neapolitan] DP Procedure
    <ul>
      <li>input case에 대해 solution을 계산하는 recursive property 세우기</li>
      <li>작은 input case부터 먼저 해결하는 bottom up을 통한 전체 Input에 대해 Solution 구축</li>
    </ul>
  </li>
</ul>

<h1 id="application-of-dp">Application of DP</h1>

<h1 id="431-the-manhattan-tourist-problem">4.3.1. The Manhattan Tourist Problem</h1>

<ul>
  <li>
    <p>Courtesy of [Jones &amp; Pevzner 6.3]</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/8.png" alt="8" /></p>
  </li>
  <li>
    <p>Problem:</p>
    <ul>
      <li>Given two street corners in the borough of Manhattan in New York City, find the path between them with the maximum number of attractions, that is, a path of maximum overall weight.</li>
      <li>Assume that a tourist may <u>**move either to east or to south only**</u></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>🏝️ 어떻게 하면 많은 관광지를을 최대로 방문할 수 있겠는가?</p>
</blockquote>

<ul>
  <li>(1) A <u>brute force</u> approach
    <ul>
      <li>모든 경로 다 따져보기 : 몇개 나올까? 각각 n, m칸이라고 할때(세로, 가로)
        <ul>
          <li>이를 따져보면 : $2^n, 2^m, n!, m!$이 나온다 → 모든 경우를 따지면 exponential, factorial time이 나오기에 풀 수 없다.</li>
        </ul>
      </li>
      <li>Search among all paths in the grid for the longest path!</li>
      <li>n이 조금 커도 알 수 있다.</li>
    </ul>
  </li>
  <li>(2) A greedy approach
    <ul>
      <li>다음 강의 주제</li>
    </ul>
  </li>
  <li><u>A formal description of this problem</u>
    <ul>
      <li>Given a weighted graph (grid) <em>G</em> of size (<em>n</em>,<em>m</em>) with two distinguished vertices, a source (0,0) and a sink (<em>n</em>,<em>m</em>), <u>**find a longest path between them**</u> in its weighted graph. (0,0)
        <ul>
          <li>find ‘a’ : 하나만 찾기</li>
        </ul>
      </li>
      <li>graph : vertex-vertex 간 관계를 나타내주는 edge로 edge는 directional/nondirectional일 수 있다
        <ul>
          <li>undirected / directed edge : arc
            <ul>
              <li>directed graph : digraph</li>
              <li>edge에 방향성이 있는가 없는가는 vertex 관계를 나타낸다.</li>
              <li>directed : ex. a는 b를 좋아하고, b는 c를 좋아하고,, : 방향성 존재</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>weighted : 각 edge에 값이 잇는경우</li>
      <li>→ weighted digraph</li>
    </ul>
  </li>
  <li>
    <p>원래 문제에 대해서 두 개의 subproblem 으로 푸는 것</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/9.png" alt="9" /></p>
  </li>
  <li>경로는 달라도 길이는 같은 longest path는 존재할 수 있다.
    <ul>
      <li>둘중에 하나로 출발하거나 도착함
        <ul>
          <li>1) 아래로 출발하거나</li>
          <li>2) 오른쪽으로 출발하거나</li>
        </ul>
      </li>
      <li>알고리즘을 어떻게 생각해냈을까에 대하여 접근해보자!</li>
      <li>둘 중에 하나인데, 오른쪽에서 오는 것이 최종 longest path라면
        <ul>
          <li>(4,4) 까지 이르는 방법에는 (4,3) - (3,4)이므로 각각에 대한 ㅣongest path를 구해보면 된다</li>
          <li>→ divide and conquer로 풀이</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>생각의 흐름
    <ul>
      <li>divide and conquer를 썼을 때, overlapping subproblem을 활용햇기에 worse 됨</li>
      <li>recursive top-down 이면 똑같은 식으로 (4,2) 혹은 (3,3)의 형태의 longest path를 찾아야 한다</li>
      <li>→ 심각해지는 overlapping problem</li>
    </ul>
  </li>
  <li>solution : DP (bottom up)
    <ul>
      <li>0,0 에서 4,3 에 이르기까지의 문제를 한 번씩만 풀고 밑에서부터 위로 올라가자.</li>
    </ul>
  </li>
  <li>divide and conquer의 overlapping subproblem으로 상당히 매칭
    <ul>
      <li>top down: overlapping subproblem → 상당히 많이 겹치는 포인트</li>
      <li>bottom up : 서로 서로를 계싼하며 결괏값 산출</li>
    </ul>
  </li>
  <li>An example grid of size (4,4)
    <ul>
      <li>
        <p>GRID : 특수한 형태의 격자처럼 생긴 graph</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/10.png" alt="10" /></p>
      </li>
    </ul>
  </li>
  <li>shortest path가 아닌 longest path 문제
    <ul>
      <li>DP 문제와 어떤 관계가 있을까?</li>
      <li>recursive solution이 보이는가?</li>
    </ul>
  </li>
  <li>A possible selection determined by a greedy approach</li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/11.png" alt="11" /></p>

<ul>
  <li><u>**Basic idea**</u>
    <ul>
      <li>How can you use the solutions of smaller problems to build a solution of a problem?
        <ul>
          <li>

            <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/12.png" alt="12" /></p>
          </li>
        </ul>
      </li>
      <li>$s_{i,j} = \max{s_{i-1,j}+ w_{i,j} , }$</li>
      <li>directed edge = arc</li>
      <li>위에서 i,j로 내려올 때의 weight,</li>
      <li>왼쪽에서 i,j로 올 때의 weight</li>
      <li>A given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
        <ul>
          <li>최적화 문제
            <ul>
              <li>리턴값을 최대로 해 주는 solution을 찾아라,</li>
              <li>solution을 극대화해주는/극소화해주는 solution을 찾아라</li>
            </ul>
          </li>
          <li>최적화가 아니나 DP를 활용
            <ul>
              <li>다저스 문제 : 최적화 문제가 아니지만 DP를 사용함</li>
            </ul>
          </li>
          <li>최적의 solution을 얻기 위해 문제를 풀어감</li>
          <li>→ optimal substructure</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/13.png" alt="13" /></p>

<ul>
  <li>Optimal substructure : $S_{n,m} =?$
    <ol>
      <li>$i,j \geq 1$
        <ul>
          <li>$S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$</li>
        </ul>
      </li>
      <li>$i=0, j=1,2,…,n$
        <ul>
          <li>$S_{0,j} = S_{0,j-1}+W({(0,j-1)},{(0,j)})$</li>
        </ul>
      </li>
      <li>$j=0, i=1,2,…,m$
        <ul>
          <li>$S_{i,0} = S_{i-1,0}+W({(i-1,0)},{(i,0)})$</li>
        </ul>
      </li>
      <li>$i=j=0$
        <ul>
          <li>$S_{0,0} = 0$</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>💡 Induction, Base step에 관한 것들도 정확하게 기술해주어야 함.</p>
</blockquote>

<ul>
  <li>Table setup and fill
    <ul>
      <li>맨 위, 맨 옆 line에서는 unique한 path cost가 나옴</li>
      <li>divide and conquer = top down → 큰 문제부터 작은 문제로 (merge sort : 큰 것을 반으로 반으로 쪼개가며 merge) ↔ DP</li>
      <li>정보의 흐름 : 내 값을 계산하기 위해서 j 인덱스가 작은 것, i 인덱스가 작은 것을 계산해두면 됨</li>
      <li>각각의 Node가 subproblem을 나타낸다.</li>
      <li>어떻게 각각의 원소를 채울 것인가: 한 원소 값을 계산하기 위해서는 나보다 왼쪽에 있는 애와 위쪽에 잇는 애의 값을 알고 있어야 함.</li>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/14.png" alt="14" /></p>
      </li>
    </ul>
  </li>
  <li>Pseudocode
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/15.png" alt="15" /></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">MANHATTANTOURIST</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
		
		
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Given a (<em>n</em>,<em>m</em>) grid, what is the time complexity T(n, m)?
undefined- So far, we have found the <strong>cost of the longest path</strong> from source to each vertex in the grid.</li>
  <li>길이가 34인 longest path는 어떻게 출력할 수 있을까?
    <ul>
      <li>조금만 더 노력하면 longest path 길이 + 대각선 까지의 거리를 출력할 수 있는 정보를 추출해낼수 있음</li>
      <li>알고리즘에서 정보를 더 끄집어 낼 수 있는 부분 :
        <ul>
          <li>$S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$
            <ul>
              <li>둘 중에 큰 것을 선택하는 statement</li>
              <li>왼쩍 것이 더 크다면 → 위에서부터 내려온 것</li>
              <li>오른쪽 것이 더 크다면 → 왼쪽에서 내려온 것</li>
            </ul>
          </li>
          <li>optimal substructure와 연관
            <ul>
              <li>나의 optimal solution은 나보다 작은 subproblem들의 optimal solution을 통해 출력</li>
              <li>거기서로부터 수식이 나타난다:이를 program화하여 각 table 원소를 계산할 때 선택됨에 따라서 각 또 다른 table 하나를 기록해두면 +1, -1 등을 줄줄 쫓아가면 됨</li>
            </ul>
          </li>
          <li>recursion : 굉장히 compact하게 표현해주는 좋은 방식
            <ul>
              <li>물론 overlapping subproblem의 경우 개념을 compact하게 햐해주지만 조심하면서 써야지 안 복잡해짐</li>
            </ul>
          </li>
          <li>최종 것까지 가는 길 : (-1→ 1) + (이전 노드까지의 최단거리)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Time complexity
    <ul>
      <li>Input size (m,n)</li>
      <li>Time Complexity : O(mn)
        <ul>
          <li>각 노드마다 계산하는데 걸리는 상수시간</li>
          <li>node의 복잡도가 시간 복잡도</li>
        </ul>
      </li>
      <li>Space Complexity : O(mn)
        <ul>
          <li>50.50으로 divide and conquer하면, 과연 실행의 끝을 볼 수 있을가 모르겠다!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Then, how can you print out the <strong>actual optimal path</strong> from source to sink?
undefined
      <img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/16.png" alt="16" /></li>
</ul>

<h1 id="432-chained-matrix-multiplication">4.3.2. Chained Matrix Multiplication</h1>

<p>[Neapolitan 3.4] dp의 대표적인 문제</p>

<ul>
  <li>In general, to multiply an <em>a</em> x <em>b</em> matrix with a <em>b</em> x <em>c</em> matrix using the standard method, it is necessary to do <em>abc</em> elementary multiplications.
    <ul>
      <li>a<em>b, b</em>c 행렬을 곱하면 a<em>c 행렬이 나오는데 가장 단순하게 연산하면 a</em>b*c만큼의 곱셈이 수행</li>
      <li>matrix multplication
        <ul>
          <li>$A_1 \times A_2 \times … \times A_n$
            <ul>
              <li>1번, 2번 곱셈, … n-1번 곱 : 누구를 제일 마지막에 연산할것인가?</li>
              <li>최소비용으로 곱한 다음 곱하는 데 활용된 비용을 더하면 결과 비용
                <ul>
                  <li>3번 이전 + 3번 이후</li>
                </ul>
              </li>
              <li>이 중에 제일 작은 것을 선택한다.</li>
              <li>matrix multiplication에는 결합법칙 성립 : 어떤 것을 먼저 곱해도 상관 없으나 비용이 달라짐</li>
            </ul>
          </li>
          <li>$A_i = d_{i-1} \times d_i$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/17.png" alt="17" /></p>

<ul>
  <li>Problem
    <ul>
      <li>Determine the minimum number of elementary multiplications, needed to multiply $n$ matrices where $A_i \in R^{d_{i-1} \times d_i}$</li>
      <li>optimal substructure를 통해 최적의 solution을 도출</li>
    </ul>
  </li>
  <li>Examples:  $A_1 (20 \times 2) \cdot A_2 (2 \times 30) \cdot A_3 (30 \times 12) \cdot A_4 (12 \times 8)$해
    <ul>
      <li>행렬의 곱셈에서는 결합법칙이 성립한다
        <ul>
          <li>$(a+b)+c = a+(b+c) $: a+b+c</li>
          <li>binary operation (이진 연산 : 두 피연산자에 대해 연산하면 한 연ㅅ나)</li>
          <li>빼기는 결합법칙 성립 x → 어떤 빼기를 먼저 하느냐에 따라 결과 달라짐</li>
          <li>행렬의 곱셈의 교환법칙 성립 X, 결합법칙은 성립 O</li>
        </ul>
      </li>
      <li>제일 먼저 곱하는 게 몇 번이냐고 생각할 수 있고,</li>
      <li>최소 횟수를 구하는 것이니 minimization problem : 최소 횟수의 곱셈 → 최적화 문제로 대입</li>
      <li>어떤 친구를 제일 먼저 곱할 것인가 생각할 수 있다.</li>
      <li>곱셈을 곱하는 순서 : 곱셈을 순서대로 나열한 것과 동일
        <ul>
          <li>최적의 해 : 곱셈의 개수가 작은 것으로 선택할 것이다.</li>
        </ul>
      </li>
      <li>$A_1: 20 \times 2, A_2: 2 \times 30$</li>
      <li>$A_1(A_2(A_3 A_4)) : 30 \times 12 \times 8 + 2 \times 30 \times 8 + 20 \times 2 \times 8 = 3,680$ multiplications
        <ul>
          <li>3, 2, 1</li>
        </ul>
      </li>
      <li>$(A_1 A_2)(A_3 A_4) : = 8,880$ multiplications</li>
      <li>$A_1((A_2 A_3 )A_4) : = 1,232$ <u>multiplications</u>
        <ul>
          <li>2, 3, 1</li>
        </ul>
      </li>
      <li>$((A_1 A_2)A_3 )A_4 := 10,320$ multiplications</li>
      <li>$(A_1(A_2 A_3 ))A_4 := 3,120$ multiplications</li>
      <li>The order of multiplication is very important!
        <ul>
          <li>$(a \times b) \times c = a \times (b \times c)$</li>
        </ul>
      </li>
      <li>$O((n-1)!)=O(n!)$ : 프로그램 열심히 설계하는 데에는 얼마 안 걸릴지 모르지만 n factorial만큼 기다려야 결과가 나온다
        <ul>
          <li>곱셈을 할 수 있는게 $(n-1)!$의 경우의 수인데 이들을 어떻게 분류해서 exponential보다 무시무시한 factorial을 polynomial time으로 변환하여 어떻게 잘 분리해 판단할것인가?</li>
          <li>분류 방법 : Ex. $A_1 \cdot A_2 \cdot A_3 \cdot A_4 \cdot A_5 \cdot A_6 \cdot A_7$
            <ul>
              <li>(1) 어떤 애를 가장 먼저 나눌 것인가
                <ul>
                  <li></li>
                </ul>
              </li>
              <li>(2) 어떤 애를 가장 나중에 나누어 곱할 것인가
                <ul>
                  <li>최소 곱셈을 하고자 하는데, 만일 제일 마지막에 곱하는 것이라면 앞의 것을 다 곱하고 뒤의 것을 나중에 곱해야 하는데 우리의 목적이 최소 곱셉을 원하는 것이므로 각각의 partition에 대해서 최소 횟수로 곱하게 됨
                    <ul>
                      <li>→ 자연스로운 recursive 사고방식</li>
                    </ul>
                  </li>
                  <li>$(A_1 \cdot A_2 \cdot A_3) \cdot (A_4 \cdot A_5 \cdot A_6 \cdot A_7) = A_{13} \cdot A_{37}$</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/18.png" alt="18" /></p>
  </li>
  <li>Divide and Conquer, Dynamic Programmping
    <ul>
      <li>problem → <u>**recursive structure**</u> → optimal substructure → dynamic programming</li>
      <li>~를 최대로 해 주는 최적화 문제에 많이 쓰이는 DP</li>
      <li>최적의 구조 이런 것들이 있을 경우, 경우에 따라서는 divide and conquer가 유리할 수 있다</li>
      <li>exponential alg이 나오기 때문에 dp를 한 번 써보자.</li>
    </ul>
  </li>
  <li>Divide and Conquer → Top-down</li>
  <li>Dynamic Programming → Bottom-up</li>
  <li>Recursive : 나랑 같이 생겼는데, 나보다 사이즉 작은 문제를 해결한다.
    <ul>
      <li>작은 문제부터 풀 것인가 (Bottom Up), 큰 문제부터 내려올 것인가 (Top Down)</li>
    </ul>
  </li>
  <li>directed graph라고 봤을 때, 최소 횟수로 건너가는 문제
    <ul>
      <li>n에서 1까지의 shortest path 찾는 문제</li>
      <li>분명 shortest path는 존재하는데, 6→ 5,3,2</li>
      <li>$P_n = \min{ P_{n-1}, P_{\frac n 2}, P_{\frac n 3}}+1$
        <ul>
          <li>if $n\%2 ==0$ → $P_{\frac n 2}$</li>
          <li>if $n\%3 ==0$ → $P_{\frac n 3}$</li>
        </ul>
      </li>
      <li>나보다 사이즈 작은 것들의 최적의 solution을 찾느다 : optimal substructure</li>
      <li>문제 사이자 즉은 거부터 값을 계산해본다. 이러한 P_n의 식을 통해서 계산
        <ul>
          <li>n을 k로 대치하여 생각</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/19.png" alt="19" /></p>
  </li>
</ul>

<h1 id="433-dynamic-programming-approach">4.3.3. Dynamic programming approach</h1>

<ul>
  <li>Definition
    <ul>
      <li>$M(i, j)$
        <ul>
          <li>the minimum number of multiplications needed to multiply $A_i$ through $A_j (i \leq j )$</li>
          <li>랑 같이 행렬 i부터 j까지 최소 횟수를 곱할 때, 그 때 필요한 곱셈의 홋수를 M(i,j)로 정의</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Optimal subtructure
    <ul>
      <li>지금까지 본 것이랑 조금 다른 형태의 substructure가 나오더라</li>
      <li>최적화 문제의 경우 dp 느낑인데 그렇지 않을수도 있더라 : 경우의 수를 따지고 recursive한 개념이 들어가는 경우
        <ul>
          <li>i, j가 같으면 곱셈이 필요 없다.</li>
          <li>i&lt;j이면
            <ul>
              <li>i에서 k까지 최소횟수 → $M(i,k) = d_{i-1} \cdot d_k $</li>
              <li>k에서 j까지 최소횟수 → $M(k+1, j) = d_k \cdot d_j$</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>→ $M(1,n) = ?$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/20.png" alt="20" /></p>

<ul>
  <li>Example: $M(2, 7)$
    <ul>
      <li>
        <p>$M(2,7) = \min_{2\leq k \leq 6}{{ M(2,k) + M(k+1,7)+d_1 d_k d_7}}$</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/21.png" alt="21" /></p>
      </li>
      <li>dp : 작은 문제부터 풀어감</li>
      <li>table을 만들어서 동일한 subproblem을 딱 한 번만 푸는 것: table을 어떻게 만들 것인가?</li>
      <li>우리가 필요한 것 : 세로 i, 가로 j → 필요한 subproblem을 다 모아두면, M(i,j)이다. $M(i,j) i\leq j$
        <ul>
          <li>대각선 우하향으로 내려갈수록 작은 문제이다</li>
          <li>table을 어떻게 훑으며 작은 문제에서 큰 문제로 변환할 것인가?</li>
          <li>optimal substructure의 구조가 어떻게 table을 쫓아갈 것인가 고민해보는 문제</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>M(2,7)
    <ul>
      <li>가로로 시작하면 안 됨 : 가로의 M(2,2,) M(2,3) .. 은 다 되지만 세로의 것들은 한번에 못 채우기 때문</li>
      <li>세로로 시작하면 될까? : 세로로 순서대로 이 식을 활용해 계싼할 것인데 왼쪽의 것들과 밑의 쪽의 것들이 계산될 것 같다.</li>
    </ul>
  </li>
  <li>
    <p>Table fill order</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/22.png" alt="22" /></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">g</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">g</span><span class="o">++</span><span class="p">){</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">g</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                          <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">g</span><span class="p">;</span>
                          <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">BIG_NUM</span><span class="p">;</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
          		        <span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span>
                             <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
              				        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                      				<span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                          <span class="p">}</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Time complexity
    <ul>
      <li>$n + (n-1) \cdot 1 + (n-2) \cdot 2 + … + (n-(n-1))\cdot (n-1)n+(n−1)⋅1+(n−2)⋅2+…+(n−(n−1))⋅(n−1)\= n + \Sigma_{g=1}^{n-1}{(n-g)g} \= O(n^3)$
undefined- Chained matrix multiplication problem</li>
      <li>$O(n^3)$ by Godbole (1973)</li>
      <li>$O(n^2)$ by Yao (1972)</li>
      <li>$O(n \log n)$ by Hu and Shing (1982, 1984)</li>
    </ul>
  </li>
  <li>Printing optimal order
    <ul>
      <li>$M(2,7) = \min_{2\leq k \leq 6}{{ M(2,k) + M(k+1,7)+d_1 d_k d_7}}$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">order</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">A_</span> <span class="o">%</span> <span class="n">d</span><span class="err">”</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="k">else</span>
      <span class="p">{</span>
          <span class="n">k</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"("</span><span class="p">);</span>
          <span class="n">order</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
          <span class="n">order</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">")"</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/23.png" alt="23" /></p>
  </li>
</ul>

<p>→ $O(n)$ time</p>

<p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/24.png" alt="24" /></p>

<h1 id="alg-44-principles-of-dynamic-programming-1">[ALG] 4.4. Principles of Dynamic Programming (1)</h1>

<h1 id="44-principles-of-dynamic-programming">4.4. Principles of Dynamic Programming</h1>

<ul>
  <li>$C_{ij}$ = the cost of the shortest path from (0,0) to (<em>i</em>,<em>j</em>)
    <ul>
      <li>각 directed edge에서 shortest path를 찾아라</li>
      <li>
        <p>Then $C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$rkr</p>

        <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/25.png" alt="25" /></p>
      </li>
    </ul>
  </li>
  <li>Recursive formulation</li>
  <li>Optimal substructure
    <ul>
      <li>나의 최적의 해를 구하기 위해서 나보다 크기가 작은 subproblem들의 optimal solution을 통해서 최적의 해를 구하는 과정을 가능케해주는 구조</li>
    </ul>
  </li>
  <li>Overlapping subproblems
    <ul>
      <li>굉장히 안 좋은 형태로 풀이될수 있음(무한 loop)</li>
      <li>subproblem의 개수는 각 node만큼 있으니가</li>
    </ul>
  </li>
  <li>Bottom-up approach
    <ul>
      <li>작은 문제부터 풀자</li>
    </ul>
  </li>
  <li>Table Fill-up
    <ul>
      <li>각 node에 대한 최단 거리를 table에 계산해두고 기록되어 있는 것들에 대해 채워가며 수행하자</li>
    </ul>
  </li>
</ul>

<h2 id="441-optimal-substructurewiki">4.4.1. Optimal Substructure <a href="https://en.wikipedia.org/wiki/Optimal_substructure">(wiki)</a></h2>

<p>쭉 읽고 아는척 해봐자 !! (dynamic programming)</p>

<ul>
  <li>문제에 대해서 DP를 적용하기 위해서는 optimal substructure를 찾아내야 한다
    <ul>
      <li>나의 optimal solution을 찾는 구조 : recursion이 들어가 있음</li>
      <li>recursion을 divide and conquer로 top-down으로 하던가, bottom-up으로 올라가던가</li>
    </ul>
  </li>
  <li>Dynamic programming algorithms are often <strong>used for optimization</strong>.
    <ul>
      <li>~를 최대로 해 주는 optimal problem을 푸는 데에 주로 쓰인다</li>
    </ul>
  </li>
  <li>A problem is said to have <strong>optimal substructure</strong>
    <ul>
      <li>if a solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.</li>
    </ul>
  </li>
  <li>Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.
    <ul>
      <li>Such optimal substructures are <strong>usually described by means of recursion</strong>.</li>
      <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
    </ul>
  </li>
</ul>

<h2 id="442-overlapping-subproblemswiki">4.4.2. Overlapping Subproblems <a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">(wiki)</a></h2>

<blockquote>
  <p>💡 큰 문제를 푸는데, recursive하게 작은 문제를 계속해서 top down식으로 풀 때 같은 식으로 반복적으로 나오는 경우 : overlapping problem 문제가 심각할 때</p>
</blockquote>

<ul>
  <li>To solve a problem, we often need to <strong>solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution</strong>.</li>
  <li>A problem is said to have <u>**overlapping subproblems**</u> if
    <ul>
      <li>the problem can be broken down into subproblems which are reused several times or</li>
      <li>a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.</li>
      <li>한 번만 풀고 이를 table에 집어넣어 점차 size를 키워 문제 원래 것을 푸는 방식</li>
      <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
    </ul>
  </li>
  <li>The dynamic programming approach seeks to <strong>solve each subproblem only once</strong>, thus reducing the number of computations:
    <ul>
      <li>(i) once the solution to a given subproblem has been computed, it is stored or “<strong>memoized</strong>”:</li>
      <li>(ii) the next time the same solution is needed, it is simply <strong>looked up</strong>.</li>
    </ul>
  </li>
  <li>This approach is <strong>especially useful when the number of repeating subproblems grows exponentially</strong> as a function of the size of the input.</li>
  <li><strong>If a problem can be solved by combining optimal solutions to non-overlapping sub-problems</strong>, the strategy is called “divide-and- conquer” instead. This is why merge sort and quick sort are not classified as dynamic programming problems.
    <ul>
      <li>overlapping subproblem이 거의 발생하지 않음 : merge sort, selection
        <ul>
          <li>merge sort : 큰 문제를 반으로 반으로 나누고 해당 subproblem들이 overlap되지 않음</li>
          <li>selection : 큰 부분들에 대해서 부분을 선택하고 한 부분은 다른 것과 겹치지 않음</li>
          <li>quick sort : pivot을 제외한 나머지 부분들은 overlap하지 않음
            <ul>
              <li>굳이 DP로도 갈 필요 없이 divide and conquer로 쉬이 풀리게 됨</li>
              <li>이분법적 사고 지양 :
                <ul>
                  <li><u>위에서 아래로 내려가는데 subproblem이 반복적으로 나타나는 경우 exponentially 한 시간 복잡도가 걸릴 수 있기에 이럴 때는 dp를 써라</u></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>$C_{ij} = min {C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} }$</li>
</ul>

<h2 id="443-the-checkerboard-problem">4.4.3. The Checkerboard Problem</h2>

<p>[Courtesy of Wikipedia]</p>

<ul>
  <li>체스판</li>
  <li>Restrictions
    <ul>
      <li>A checker can start at any square on the first row (i= 1).</li>
      <li>It can move only diagonally left forward, diagonally right forward, or straight forward.
        <ul>
          <li>내려가는 방법 제한 : 남서쪽으로만 내려가던가, 남쪽으로 내려가던가, 남동쪽으로 내려가던가</li>
        </ul>
      </li>
      <li>It must pay the cost <em>c</em>[i] when visiting the (i, j)-position.</li>
    </ul>
  </li>
  <li>
    <p>Cost table $c [i] [j]$</p>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/26.png" alt="26" /></p>
  </li>
  <li>Problem
    <ul>
      <li>Given a checkerboard with $n \times n$ squares, and a cost function <code class="language-plaintext highlighter-rouge">c[i][j]</code>, <strong>find the minimum-cost path from the first row to the last row</strong>.</li>
      <li>내가 어떤 지점을 방문했을 때에는 화살표가 지나간 cost를 summation한 것
        <ul>
          <li>가장 길이가 짧은 적은 비용의 path 찾는것이 목표</li>
        </ul>
      </li>
      <li>recursive 구조, optimal substructure을 찾아보자
        <ul>
          <li>가장 작게 해주는 minimization problem</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Ex. 1 까지의 최소비용 [4][4]
    <ul>
      <li>최소 비용의 path는 셋 중 하나 : 남쪽으로 오거나, 남서쪽에서 오거나, 남동쪽에서 오거나</li>
      <li>내가 최소 비용을 찾고자 하는 것이니 각각에 이르기까지의 최소 비용 path의 총 비용의 계산
        <ul>
          <li>각각 상황에 대한 총 비용을 안다면, ㅐptimal substructure로 어떻게 나타낼까?</li>
          <li>minimum cost path에 대한 총 비용은 올 수 있는건 세 가지 경로인데 가장 작은 것에다가 이를 선택해서</li>
          <li>나를 방문할 때 1을 더하면 되더라</li>
        </ul>
      </li>
      <li></li>
    </ul>
  </li>
  <li>Optimal substructure
    <ul>
      <li>$q(i,j) = \min { q(i-1, j-1), q(i-1,j), q(i-1, j+1)} + c(i,j)$
        <ul>
          <li>$c(i,j)$ :</li>
          <li>table size는 어떻게 할 것인가 : 각 subproblem마다 원소에 대응되게 table을 잡으면 됨</li>
          <li>총 비용에 해당하는 q(i,j) : (i,j) 까지 위치 까지의 총 비용 계산
            <ul>
              <li>min (남쪽으로 내려오는, 남동쪽, 남서쪽)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>$q(i,j) = c(i,j)$
        <ul>
          <li>i=1일 때 : 자기 자신 - 맨 윗줄
            <ul>
              <li>그 지점까지 오는 최소 비용은 자기 자신 cost만 지불하면 됨</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>dummy
        <ul>
          <li>수학적으로 무한대 값을 설정해 둠</li>
          <li>이런식으로 설정하고 programming하면 각 끝에 값들에 선택되지 않음</li>
          <li>사실 수학적으로 쓸 때 필요는 없지만, dummy값을 넣어주는 게 편리
            <ul>
              <li>boundary 체크해도 상관은 없지만 각 왼쪽, 오른쪽 끝에서 boundary로부터 오는 값들을 계산하기 곤란함</li>
            </ul>
          </li>
          <li>각 cost table 위치마다 subproblem이 하나 생성됨</li>
        </ul>
      </li>
      <li>table setup &amp; table fill
        <ul>
          <li>어떤식으로 loop을 돌면서 할까</li>
        </ul>
      </li>
      <li>(if) 수직으로 for loop를 돌겠다고 하면
        <ul>
          <li>남동, 남서로 내려오는 것들에 대해서는 고려하지 못하므로 안됨</li>
        </ul>
      </li>
      <li>(if) 수평으로 for loop를 돌겠다고 하면
        <ul>
          <li>특정 원소를 계산하고자 할 때, 나에게 필요한 정보가 미리 준비되어 있음</li>
          <li>q table이 계산되더라</li>
        </ul>
      </li>
      <li>q table이 계산된 후 할일 : 아무데서나 시작해도 상관없으니 위에서 내려와서 최소비용으로 가게하자
        <ul>
          <li>아무데서나 시작해서 가는 minimum cost path</li>
          <li>→ 8</li>
        </ul>
      </li>
      <li>q table을 계싼함과 동시에 p table 계산
        <ul>
          <li>어느 방향에서 왔는지
            <ul>
              <li>가장 작은 것을 선택하는 경우</li>
            </ul>
          </li>
          <li>-1 : 북서에서 내려온거다 / 0 : 북에서 내려온거다 / 1 : 북동에서 내려온거다</li>
        </ul>
      </li>
      <li>optimal substructure를 찾은 다음 table을 setup하고 base step 정보를 가지고 initialize하고 table을 적당한 순서로 정리한 다음 적정한 최단 optimal path를 찾는다.</li>
      <li>이후 table fill을 할 때 table을 하나 잡아서 어떤 node를 선택해서 내려왔음을 표기함 (p table)</li>
      <li>→ shortest path를 알게 된다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/27.png" alt="27" /></p>

    <ul>
      <li>나보다 사이즈가 작은 최적의 솔루션들로 표현하는 것</li>
      <li>code
        <ul>
          <li>c/c++는 recursion이 좋은 tool이지만 보편적으로 굉장히 개념을 compact하게 잘 표현해준다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>  <span class="cp">#define N 5
</span>  <span class="cp">#define INFTY 100000
</span>  <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	
  <span class="kt">int</span> <span class="nf">min3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="nf">ComputeCBCosts</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFTY</span><span class="p">;</span>
          <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFTY</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">min3</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span>
                      <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
              <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
              <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">else</span>
                  <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">PrintShortestPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">imin</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">" (%d, %d) &lt;-"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">" (%d, %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imin</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
      <span class="k">else</span>
          <span class="n">PrintShortestPath</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">imin</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">ComputeCBShortestPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">min</span><span class="p">;</span>
      <span class="n">ComputeCBCosts</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="n">imin</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">imin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"*** The cost of the shortest path is %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">imin</span><span class="p">]);</span>
      <span class="n">PrintShortestPath</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">imin</span><span class="p">);</span>
  <span class="p">}</span>
	
  <span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
      <span class="n">ComputeCBShortestPath</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[divide and conquer: top - down 효율적이기도 하나 매우 비효율적이 되기도 함 splitted된 사례들이 서로 관련 없는 문제를 풀때 잘 통함 dynamic programming : bottom -up 아래에서 위로 올라가며 효율을 추구하자는 방식 NOW Divide-and-Conquer Method Dynamic Programming Method Greedy Method Backtracking Method Local Search Method Branch-and-Bound Method Etc. From Wikipedia: Dynamic programming is both a mathematical optimization method and a computer programming method. A complicated problem is broken down into simpler sub-problems in a recursive manner. Overlapping subproblems A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems. Optimal substructure A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems. When applicable, the method **takes far less time than other methods** that don’t take advantage of the subproblem overlap like the divide- and-conquer technique.]]></summary></entry><entry><title type="html">[ALG] 3.3. Master Theorem</title><link href="http://localhost:4000/ALG-3.3.-Master-Theorem" rel="alternate" type="text/html" title="[ALG] 3.3. Master Theorem" /><published>2022-09-26T00:00:00+09:00</published><updated>2022-09-26T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-3.3.-Master-Theorem-</id><content type="html" xml:base="http://localhost:4000/ALG-3.3.-Master-Theorem"><![CDATA[<h1 id="master-theorem-1">Master Theorem 1</h1>

<p>[Neapolitan 2.8]</p>

<ul>
  <li>Let a, b, and c be nonnegative constants.</li>
  <li>The solution to the recurrence $T (1)=1$, and $T(n)=aT(\frac n c)+bn$, for <em>n</em>&gt;1 for <em>n</em> a power of <em>c</em> is
    <ul>
      <li>$T(n)=O(n)$, if $a&lt;c$
        <ul>
          <li>a=3, b=4 → n ⇒ $\frac n 3, \frac n 3$</li>
        </ul>
      </li>
      <li>$T(n)=O(n \log n)$ if $a=c$
        <ul>
          <li></li>
        </ul>
      </li>
      <li>$T(n) = O(n \log_c a)$ if a &gt; c
        <ul>
          <li>$a=4, c=2$면? → $O(n^{\log_2 4})$</li>
          <li>a&gt;c이면 log_c a &gt; 1이게 됨
            <ul>
              <li>$O(n \log n)$ vs $O(n^{1.00000000001})$</li>
              <li>$\lim_{n\rightarrow \infty}{\frac {f(n)}{g(n)}} = \infty, c, 0$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>o(n) &lt; O(n \log n) &lt; O(n \log_c a)</p>

<p>$T(n) = T(\frac n 5) + T(\frac 3 4 n) + bn$</p>

<p>Prove this by induction!</p>

<ul>
  <li>Avoid divided-and-conquer if, for example–
    <ul>
      <li>An instance of size n is divided into two or more instances each almost of size <em>n</em>.</li>
      <li>An instance of size n is divided into almost <em>n</em> instance of size $\frac n c$, where <em>c</em> is a constant.</li>
    </ul>
  </li>
  <li>The divide-and-conquer strategy often leads to efficient algorithms, although not always!</li>
</ul>

<h1 id="master-theorem-2">Master Theorem 2</h1>

<p>212p</p>

<p>Theorem</p>

<p>if $T(n) \leq a \cdot T(\frac n b) + O(n^d) $ for $a \geq 1, b&gt;1$ and $d \geq 0$</p>

<p>→ then</p>

<p>$T(n) = O(n^d \log n) $ if $a = b^d$</p>

<p>$T(n) = O(n^d) $ if $a &lt; b^d$</p>

<p>$T(n) = O(n^d \log n) $ if $a &gt; b^d$</p>

<p>divide and conquer : linear time이라는 보장은 없다.</p>

<p>스스로 한번 이해해보고, 이해가 안 됐을 때 또 다시 생각해보기 (숙제!)</p>

<ul>
  <li>직관적으로, 논리적으로 맞느지 스스로 이해를 해보라,</li>
</ul>

<h1 id="alg-34-miscellaneous-1">[ALG] 3.4. Miscellaneous (1)</h1>

<h1 id="finding-the-closest-pair-of-2d-points">Finding the Closest Pair of 2D Points</h1>

<h2 id="1-내용">1. 내용</h2>

<p><strong>[J. Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005. 5.4]</strong></p>

<ul>
  <li>Problem
    <ul>
      <li>
        <p>Given <em>n</em> points in the plane, find the pair that is closest together.</p>

        <p>n</p>
      </li>
    </ul>
  </li>
  <li>Notation</li>
  <li>Naïve algorithm
    <ul>
      <li>Compute the distance between each pair of points</li>
      <li>take the minimum → $O(n^2)$ time
undefined
        <h2 id="2-applying-the-divide-and-conquer-strategy">2. Applying the Divide-and-Conquer Strategy</h2>
      </li>
    </ul>
  </li>
  <li>[Shamos and Hoey]</li>
  <li>Simple assumption for an easy explanation
    <ul>
      <li>No two points in <em>P</em> have the same _x_coordinate or the same _y_coordinate.</li>
    </ul>
  </li>
  <li>General idea
    <ul>
      <li>[Preprocessing]
        <ul>
          <li>Build a list <em>Px</em> in which all the points in <em>P</em> have been sorted by increasing _x_coordinate→ $O(n \log n)$</li>
          <li>Build another list <em>Py</em> in which all the points in <em>P</em> have been sorted by increasing _y_coordinate→ $O(n \log n)$</li>
        </ul>
      </li>
      <li>[Recursion for <em>P</em> with $∣P∣=n$]
        <ul>
          <li>[Divide] Partition <em>P</em> into two subsets <em>Q</em> and <em>R</em> → <em>O</em>(<em>n</em>)</li>
          <li>[Conquer] Find the closest pairs in <em>Q</em> and <em>R</em>, respectively→ $2T(\frac n 2)$</li>
          <li>[Combine] Use this information to get the closest pair in P→ <em>O</em>(<em>n</em>)</li>
          <li>Time-complexity
            <ul>
              <li>$O(n \log n) + T(n)$ where $T(n) = cn +2T(n/2) → O(n \log n)$</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The stage [Divide]: Partition <em>P</em> into two subsets <em>Q</em> and <em>R</em>.
    <ul>
      <li>Create <em>Q</em> and <em>R</em>, where
        <ul>
          <li>Q: the set of points in the first  $\lceil(\frac n 2)\rceil$positions of the list $P_x$ (the “left half”),</li>
          <li>R_R_: the set of points in the final $\lfloor(\frac n 2) \rfloor$positions of the list $P_x$ (the “right half”).</li>
        </ul>
      </li>
      <li>Furthermore, create $Q_x, Q_y, R_x$, and $R_y$, where
        <ul>
          <li>$Q_x$ consisting of the points in <em>Q</em> sorted by increasing _x_coordinate,</li>
          <li>$Q_y$ consisting of the points in <em>Q</em> sorted by increasing _y_coordinate,</li>
          <li>$R_x$ consisting of the points in <em>R</em> sorted by increasing _x_coordinate,</li>
          <li>$R_y$ consisting of the points in <em>R</em> sorted by increasing _y_coordinate.</li>
        </ul>
      </li>
      <li>✓ Can be done in $O(n)$</li>
    </ul>
  </li>
  <li>The stage [Conquer]: Find the closest pairs in <em>Q</em> and <em>R</em>, respectively.
    <ul>
      <li>Recursively determine a closest pair $(q_0, q_1)$ of points in <em>Q</em></li>
      <li>Recursively determine a closest pair $(r_0, r_1)$ of points in <em>R</em>.
        <ul>
          <li>Can be done in $2T(\frac n 2)$.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>The stage [Combine]: Use the obtained info. to get the closest pair in <em>P</em>.
    <ul>
      <li>Question : are there points $q \in Q, r \in R$ for which $d(q,r)&lt;\delta$?
        <ul>
          <li>How can we answer this question in linear time?</li>
        </ul>
      </li>
      <li>[Fact 1] (Why?)
        <ul>
          <li>if there $∃q∈Q,r∈R $for which $d(q,r)&lt;\delta$</li>
          <li>then each of <em>q</em>,<em>r</em> lies within a distance $\delta$ of $L$</li>
        </ul>
      </li>
      <li>[Fact 2]
        <ul>
          <li>$∃q∈Q,r∈R$ for which $d(q,r)&lt;\delta⟺ ∃s,s′∈S$ for which $ d(s,s′)&lt;δ$</li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/0.png" alt="0" /></p>
          </li>
          <li>$x^*$: the x-coordinate of the rightmost point in <em>Q</em></li>
          <li>$\delta=min(d(q_0^<em>,q_1^</em>),d(r_0^<em>,r_1^</em>))$</li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/1.png" alt="1" /></p>
          </li>
        </ul>
      </li>
      <li>[Fact 3]
        <ul>
          <li>if $s, s^{‘ } \in S$ have the property that $d(s, s^{‘})&lt;\delta$, then $s, s^{‘}$ re within 15 positions of each other in the sorted list $S_y$
            <ul>
              <li>$S_y$ : the list consisting of the points in <em>S</em> sorted by increasing _y_coordinate.</li>
              <li>Each box contains at most one point of <em>S</em>. (Why?)</li>
              <li>If two points in <em>S</em> are at least 16 positions apart in $S_y$ , …</li>
            </ul>
          </li>
          <li>

            <p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/2.png" alt="2" /></p>
          </li>
        </ul>
      </li>
      <li>
        <p>[merge] : <em>O</em>(<em>n</em>)</p>

        <p>O(n)</p>

        <ol>
          <li>For each $s \in S_y$ , compute its distance to each of the next 15 pts in $S_y$</li>
          <li>Let $s, s^{‘}$ be the pair achieving the minimum of these distances</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>Compare $d(s, s^{‘})$ with $δ$</p>

<p><img src="/assets/img/2022-09-26-[ALG]-3.3.-Master-Theorem-.md/3.png" alt="3" /></p>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[Master Theorem 1]]></summary></entry></feed>