<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-30T18:00:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Kyuhwan Shim</title><subtitle>Kyuhwan Shim is a senior undergraduate in CS at Sogang University.
</subtitle><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><entry><title type="html">회고와 대회</title><link href="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C" rel="alternate" type="text/html" title="회고와 대회" /><published>2023-11-16T00:00:00+09:00</published><updated>2023-11-16T00:00:00+09:00</updated><id>http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C</id><content type="html" xml:base="http://localhost:4000/%ED%9A%8C%EA%B3%A0%EC%99%80-%EB%8C%80%ED%9A%8C"><![CDATA[<h1 id="블로그">블로그</h1>

<ul>
  <li>리디자인</li>
</ul>

<h1 id="대회">대회</h1>

<ul>
  <li>2022
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2022 빅콘테스트</li>
    </ul>
  </li>
  <li>2023
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />강서구 데이터 공모전</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />LG Aimers</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Samsung AI Challenge</li>
    </ul>
  </li>
</ul>

<h1 id="일">일</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Nota ITS ML Engineer 인턴 후기
    <ul>
      <li>들어가야 하는 내용
        <ul>
          <li>지원 계기
            <ul>
              <li>타 기업에 대비하여 가질 수 있었던 이점</li>
            </ul>
          </li>
          <li>가서 주로 맡은 업무</li>
          <li>가서 배운 일</li>
          <li>앞으로의 할 일</li>
        </ul>
      </li>
    </ul>
  </li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />앞으로 할 일에 대한 정리
    <ul>
      <li>대학원과 취업 사이의 기로</li>
      <li>전공</li>
      <li>ML</li>
    </ul>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="경험" /><category term="일상기록" /><summary type="html"><![CDATA[블로그]]></summary></entry><entry><title type="html">[ALG] 1.3. Order of Algorithms (1)</title><link href="http://localhost:4000/ALG-1.3.-Order-of-Algorithms-(1)" rel="alternate" type="text/html" title="[ALG] 1.3. Order of Algorithms (1)" /><published>2022-09-08T00:00:00+09:00</published><updated>2022-09-08T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-1.3.-Order-of-Algorithms-(1)</id><content type="html" xml:base="http://localhost:4000/ALG-1.3.-Order-of-Algorithms-(1)"><![CDATA[<ul>
  <li>제일 먼저 생각
    <ul>
      <li>Input Size
        <ul>
          <li>Problem을 풀고자 하는데 이를 sol하고자 하는 algorithm에서, 알고리즘에 들어오는 data의 크기는 어떻게 되는가.
            <ul>
              <li>문제 상황에 따라 가로 n, 세로 m의 데이터가 들어오면 (n,m) n일수도 nm일수도 있다.</li>
            </ul>
          </li>
          <li>data size가 커짐에 따라 얼마나 시간이 걸리는가 분석 : 얼마난 크기의 데이터가 들어왔을 때, 얼마나 시간이 걸리는가.</li>
          <li>시간 분석의 기본 요소 : data의 수</li>
        </ul>
      </li>
      <li>Cost : $g(n)$
        <ul>
          <li>문제가 있을 때 n에 대하여 어느 정도의 비용이 걸리는가.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="obigonotation"><em>O</em> (Big $O$ Notation)</h1>

<blockquote>
  <p>💡 for given two functions $f(n)$ and $g(n)$,</p>

  <p>$g(n) = O(f(n))\iff \exists c \in \mathbb{R}, N \in \mathbb{N}\quad g(n)\leq c\cdot f(n), \forall n \geq N$</p>
</blockquote>

<ul>
  <li>complexity를 따질 때, data size가 작을 때 보다는 커질 때 문제가 발생함을 확인하고 싶음.
    <ul>
      <li>→ 모든 n일 필요는 없고, 그 N보다 큰 모든 input size에 대해서 이러한 조건을 만족하면.</li>
    </ul>
  </li>
  <li>then we say that :$g(n)$ is big O of $f(n)$</li>
  <li>예)
    <ul>
      <li>코드의 비용을 분석해 봤더니
        <ul>
          <li>for loop 1, for loop n 자승만큼 돌게 된다.</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>비용 : $g(n) = c_0 + c_1 n + c_2 n^2$</li>
  <li>예 : $g(n) = 5 + 6 + 7n^2 \leq 8n^2 \quad \forall n \geq 8$
    <ul>
      <li>$8 \cdot n^2 = c \cdot f(n), N = 8$
        <ul>
          <li>n이 커지면 g(n)이 압도적으로 다른 친구들을 누르게 된다.</li>
          <li>다시한번 이야기하지만, n이 커질 때, 내가 분석한 비용은 f(n)이라는 함수에 눌리게 되는 upper bound 개념</li>
        </ul>
      </li>
      <li>$g(n) = O(n^2)$</li>
    </ul>
  </li>
  <li>$g(n) = O(n^{1000})$?
    <ul>
      <li>정의에 의하면 맞음 : 그래프상 확인해보아도 맞음.</li>
      <li>$f(n)\geq g(n) \cdot c$</li>
    </ul>
  </li>
</ul>

<h2 id="notes-for-big-o">Notes for big O</h2>

<ul>
  <li>[Note 1] The big O puts an <u>**asymptotic**</u> <u>upper bound</u> on a function.
    <ul>
      <li>복잡도를 따질 때 ‘몇 초’가 걸린다기 보다는 얼마나 효율적인가를 따지는 척도
        <ul>
          <li>PL, HW 상황에 대해서 implementation 관점에서 개인 차 발생</li>
        </ul>
      </li>
      <li>Asymptotic analysis (from Wikipedia)
        <ul>
          <li>asymptotic : 점근적인</li>
          <li>
            <p>data size가 커질 때, 이 알고리즘이 시간이나 필요로 하는 메모리 사이즈가 얼마나 나빠지는가? → 알고리즘이 요구하는 시간, 메모리 양 등이 얼마나 나쁜 형태로 변화하는지 ‘형태’</p>

            <blockquote>
              <p>If $f(n) = n^2 + 3n$, then as n becomes very large, the term $3n$ becomes insignificant compared to $n^2$. The function f(n)f(n) is said to be “asymptotically equivalent to n^2n2, as $n→∞$”. This is often written symbolically as $f(n) -&gt; n^2$, which is read as “$f(n)$ is asymptotic to $n^2$”.</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>계산 비용이 $0.01n^2$ 과 $100n$ 알고리즘 중 어떤 것이 더 효율적인가?
        <ul>
          <li>이론적인 관점에서 $100n = O(n), 0.01n^2 = O(n^2)$</li>
          <li>input size $n=3$: $0.09 \quad 300$</li>
          <li>input size $n=10^6$: $0.01 \cdot (10^6)^2 = 10^{10}$, $100 \cdot 10^6 = 10^8$</li>
        </ul>

        <p>→ 결국 $O(n^2)$</p>
      </li>
      <li>(Tight) upper bound
        <ul>
          <li>$37log n + 0.1n = O(n)$
            <ul>
              <li>n이 커지면 $\log n$은 상당히 작아짐</li>
            </ul>
          </li>
          <li>$n^2 + 10n = O(n^2)$</li>
          <li>$4(\log n)^2 + n \log n + 100n = O(n \log n)$
            <ul>
              <li>$\log n$ vs $n$ → 당연하게 $\log n$</li>
              <li>$n \log n &gt; {\log n} ^2$</li>
            </ul>
          </li>
          <li>$n^2 + 10n = O(n^{200})$???
            <ul>
              <li>upper bound 맞아 틀린 말은 아니지만, 일반적으로 O Notation을 활용할 때에는 tight upper bound를 선택하여 표현한다.</li>
            </ul>
          </li>
        </ul>

        <blockquote>
          <p>💡 Dominating Term</p>
          <ul>
            <li>지배하는 term을 찾아 Upper Bound를 찾는다.</li>
          </ul>
        </blockquote>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 지배하는 term을 찾아 Upper Bound를 찾는다.   - $\log _en $등 base는 왜 고려하지 않느냐 → 상수에 해당하므로 상관 없기 때문에.
  - $\log _2 n = \frac {\log_e n }{\log_e2}$
</code></pre></div>        </div>
      </li>
    </ul>

    <p>### Growth Rates of Some Common Complexity Functions</p>

    <ul>
      <li>이론적으로는 $n^3$은 efficient하지만 현실적으로는 문제가 발생할 수 있을만한 복잡도</li>
      <li>감당할 수 없을 정도로 커지네 등 asymptotic 특성을 분석하기 위함</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-08-[ALG]-1.3.-Order-of-Algorithms-(1).md/0.png" alt="0" /></p>

<ul>
  <li>[Note 2] Given a cost function g(n), how do you find the proper complexity function f(n) such that $g(n) = O(f(n))$?
    <ul>
      <li>Suppress lower-order terms and constant factors!</li>
      <li>Example:
        <ul>
          <li>$10^3 + 10^3n + 10^-3 n^2 = O(n^2)$
            <ul>
              <li>then $lim_{n \to \infty} \frac{n^2}{n} = \infty$</li>
            </ul>
          </li>
          <li>$5n \log_3 n + 3(\log_2 n)^2 + n + 6n^2 = O(n^2)$
            <ul>
              <li>then $lim_{n \to \infty} \frac{n}{log_en} = lim _{n \to \infty} = \infty$</li>
            </ul>
          </li>
          <li>$3(log_2 n)^2+ 0.1n = O(?)$
            <ul>
              <li>Dominate Term이 무엇일까?</li>
              <li>$\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}}$ =$\infty, c, 0$
                <ul>
                  <li>$\infty$ : $(\log n)^2$ , $0$ : $n$ , $c$ :</li>
                  <li>L’Hospital Theorem : $\lim _{n \rightarrow \infty}{\frac {f(n)}{g(n)}} = \lim _{n \rightarrow \infty}{\frac {f’(n)}{g’(n)}} $
                    <ul>
                      <li>$\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}} = \lim = \lim _{n \rightarrow \infty} {\frac {2}{n}{}}0$</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>→ Linear Time</li>
            </ul>
          </li>
          <li>$2^{n+5} = O(2^n)$ ??</li>
          <li>$2^{5n} = O(2^n)$??</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="comparing-orders-of-growth">Comparing Orders of Growth</h2>

<ul>
  <li>How do you compare orders of growth of two functions?
    <ul>
      <li>One possible way is to compute the limit of the ratio of two functions in question.</li>
      <li>$x = lim_{n \to \infty } \frac{f_1(n)}{f_2(n)}$
        <ul>
          <li>if <em>x</em>=0, _f_1 has a smaller order of growth than _f_2</li>
          <li>if $x=c$, $f_1$ has a same order of growth than $f_2$</li>
          <li>if $x=\infty$, $f_1$ has a larger order of growth than $f_2$</li>
        </ul>
      </li>
      <li>Ex.1: $\log_2 n $ vs. $\sqrt{n}$
        <ul>
          <li>$lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} = lim_{n \to \infty} \frac{(log_2 n)’}{(\sqrt(n))’} = lim_{n \to \infty} \frac{(log_2 e)\frac{1}{n}}{\sqrt\frac{1}{2\sqrt(n)}} $</li>
        </ul>
      </li>
      <li>Ex.1.2.: $\log_2 n $ vs. $n^{0.0001}$
        <ul>
          <li>$lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} $</li>
        </ul>
      </li>
      <li>Ex.2: $n!$ vs $2^n$ - factorial vs. exponential
        <ul>
          <li>$lim_{n \to \infty} \frac{ n!}{2^n} = lim_{n \to \infty} \frac{\sqrt{2 \pi n} (\frac {n}{e})^n}{2^n}=lim_{n \to \infty }\sqrt{2 \pi n} \frac{({n})^n}{2^n e^n}$</li>
          <li>stirling’s formula : $n! \approx \sqrt{2 \pi n} (\frac {n}{e})^n$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="ωbig-omega-notation">$Ω$ (Big Omega Notation)</h1>

<p>→ Lower Bound</p>

<ul>
  <li>for two given functions $f(n), g(n)$</li>
</ul>

<blockquote>
  <p>💡 $g(n) = \Omega(f(n))g(n)=Ω(f(n)) ⟺ \exists c \in \mathbb{R}, ∃c∈R,$ and $N \in \mathbb{Z^+ \cup {0}}$, s.t. $g(n) \geq cf(n) \forall n \geq N$</p>
</blockquote>

<ul>
  <li>We say that g(n)<em>g</em>(<em>n</em>) is <em>ω</em> of $f(n)$.</li>
  <li>The Ω puts an asymptotic lower bound on a function.</li>
  <li>Ex:
    <ul>
      <li>$37\log n+0.1n=\Omega(n)$</li>
      <li>$n^2 + 10n = \Omega(n^2)$</li>
      <li>$4(logn)^2 +nlogn+100n=\Omega(nlogn)$</li>
      <li>$n^{200} +10n=\Omega(n^2)$</li>
      <li>

        <p><img src="/assets/img/2022-09-08-[ALG]-1.3.-Order-of-Algorithms-(1).md/1.png" alt="1" /></p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="θbig-theta-notation">$Θ$ (Big Theta Notation)</h1>

<ul>
  <li>for two given functions f(n)<em>f</em>(<em>n</em>) , g(n)<em>g</em>(<em>n</em>)
    <ul>
      <li>위에서 누르고</li>
      <li>아래에서 누르고</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 $g(n) = \Theta(f(n))g(n)=Θ(f(n)) \iff⟺ g(n) = O(f(n))g(n)=O(f(n)) and g(n) = \Omega (f(n))$</p>
</blockquote>

<ul>
  <li>
    <p>that is,</p>

    <blockquote>
      <p>💡 $g(n) = \Theta (f(n))g(n)=Θ(f(n)) \iff⟺ \exists c,d \in \mathbb{R}∃c,d∈R and N \in \mathbb{Z^+ \cup {0}}N∈Z+∪0 s.t. g(n) \geq cf(n)g(n)≥cf(n) \forall n \geq N∀n≥N$</p>
    </blockquote>
  </li>
  <li>We say that g(n)<em>g</em>(<em>n</em>) is order of f(n)<em>f</em>(<em>n</em>).</li>
  <li>The \ThetaΘ puts an asymptotic bound on a function.</li>
  <li>$0.1n + 10n^2 = O(n^{1000}) / O(n^2)$
    <ul>
      <li>Big O 로 N 자승이다 하며는 tight upper bound를 이야기한다.</li>
    </ul>
  </li>
  <li>Ex:
    <ul>
      <li>$37\log n+0.1n=\Theta(n)$
        <ul>
          <li>$O(n), \Omega(n)$</li>
        </ul>
      </li>
      <li>$n^2 + 10n = \Theta(n^2)$</li>
      <li>$4(logn)^2 +nlogn+100n=\Theta(nlogn)$</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 $\Theta(1)&lt;\Theta(log n)&lt;\Theta(n)&lt;\Theta(n log n)&lt;\Theta(n^2)&lt;\Theta(n^3)&lt;\Theta(n^j)&lt;\Theta(n^k)&lt;\Theta(a^n)&lt;\Theta(b^n)&lt;\Theta(n!)$</p>
</blockquote>

<ul>
  <li>for $k&gt;j&gt;3 , b&gt;a&gt;1$</li>
  <li>O(1) or <em>O</em>(<em>c</em>) : constant
    <ul>
      <li>$g(n) = 0.000001 \cdot n$</li>
      <li>g(n) = 1000000<em>g</em>(<em>n</em>)=1000000</li>
    </ul>
  </li>
  <li>Ref. Neapolitan Ex. (pp.42) 19, 24, 26, 28]</li>
</ul>

<h1 id="big-o-omega-and-order">Big O, Omega, and Order</h1>

<ul>
  <li>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.3.-Order-of-Algorithms-(1).md/2.png" alt="2" /></p>
  </li>
  <li>Ref.<em>Ref</em>. [ Neapolitan Chapter 1.]</li>
</ul>

<h2 id="execution-times-for-algorithms-with-the-given-time-complexities">Execution Times for Algorithms with the Given Time Complexities</h2>

<ul>
  <li>n의 k승, 이를 polynomial time (다항 시간)이라고 칭한다.</li>
  <li>n log n, log는 다항식이 아닌데 왜 polynomial이라고 하는가?
    <ul>
      <li>upperbound : n 자승보다 빠르니까 polynomial time에 들어가게 됨.</li>
    </ul>
  </li>
  <li>실제적으로 회사 가서 이 문제를 풀어주는 SW를 해서, 제출한다고 했을 때, n이 커짐에 따라 이러한 효율적인 알고리즘들은 그 피해가 덜한데, 뒤는 피해가 현실적으로 받아들일 수 없을 정도로 커진다. 우리가 이론적으로 구별은 무엇이냐 하면은 polynomial - nonpolynomial alg.를 구분
    <ul>
      <li>$n^6$은 이론적으로는 polynomial - 안 좋긴 하지만</li>
    </ul>
  </li>
  <li>exponential, factorial algorithm은 inefficient, polynomial algorithm은 algorithm
    <ul>
      <li>현실적으로는 cubic도 빡셈</li>
    </ul>
  </li>
  <li>알고리즘 :
    <ul>
      <li>이론적인 측면에서 polynomial time 에 쓰이는가</li>
      <li>프로그램을 구현해서 돌릴 때, 당연히 cuvic보다는 효유적으로 돌아갈 것이다</li>
    </ul>
  </li>
  <li>현실적으루 n이 작을 때에는 그렇게 큰 지장이 없지만, n이 점차 커질 때 log, linear는 잘 버티는 데에 반해 exp, factorial
    <ul>
      <li>processor가 좋아진다 한들 풀고자 하는 문제가 더 커지기 때문에 시대적 needs라기 보다는 항상 우리 곁의 needs</li>
    </ul>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.3.-Order-of-Algorithms-(1).md/3.png" alt="3" /></p>

    <ul>
      <li>logarithmic, linear, n log n, quadratic, cubic « exp « factorial</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-08-[ALG]-1.3.-Order-of-Algorithms-(1).md/4.png" alt="4" /></p>

<h1 id="worst-case-vs-average-case-time-complexity">Worst-Case vs. Average-Case Time Complexity</h1>

<ul>
  <li>complexity : time, space complexity
    <ul>
      <li>편의상 time complexity를 따짐</li>
    </ul>
  </li>
  <li><strong>Expected value</strong> (from Wikipedia)
    <ul>
      <li>let X_X_ be a random variable with a finite number of finite outcomes $x_1, x_2, …, x_k$ occuring with probabilities $p_1, p_2, … p_k$ respectively.</li>
      <li>the Expectation of X is defined as :
        <ul>
          <li>$E(X) = \sum_{i=1}^{k }{x_i p_i} = x_1p_1+ x_2 p_2 + … + x_k p_k$</li>
        </ul>
      </li>
      <li>since the sum of all probabilities $p_i$ is 1 (\sum_{i=1}^{k} {p_i}=1∑<em>i</em>=1<em>k__pi</em>=1) , the expected value is the weighted sum of the x_i_xi_ values, with the p_i_pi_ values being the weights</li>
      <li>$a_1, a_2, a_3 \rightarrow b_1 , b_2, b_3$
        <ul>
          <li>input size n에 대해서 모든 가능한 input들의 집합을 S_n</li>
          <li>임의의 input $I$</li>
          <li>$c(I) $ :</li>
          <li>$p(I):$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Worst-case complexity :
    <ul>
      <li>모든 가능한 인풋중에 최악으로 가장 많은 시간이 걸리는 경우. 가장 시간이 많이 걸리는 경우</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$T_W (n) = max { c(I)</td>
              <td>I \in S_n }$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>Average-case complexity
    <ul>
      <li>모든 input에 대해서 일어날 확률 등에 대해 평균을 낸 것.</li>
      <li>$T_A (n) = \sum_{I \in S_n} p(I) c(I)$</li>
    </ul>
  </li>
  <li>Problem
    <ul>
      <li>Find the index of a given value <em>a</em> in a givven array $(a_0, a_1, …,a <em>{n-1})$. if _a</em> doesn’t exist in the array return −1</li>
    </ul>
  </li>
  <li>Cost for a linear search algorithm
    <ul>
      <li>let P_i_Pi_ be the probability such that a= a_i_a_=<em>ai</em></li>
      <li>
        <p>then the average cost is :</p>

        <p>$g(n) = 1 \cdot P_0 + 2 \cdot P_1 + 3 \cdot P_2 + …+ n \cdot P_{n-1} + n (1 - \sum_{k=0}^{n-1} P_k)$</p>

        <p>$= \sum_{k=0}^{n-1} (k+1)P_k + n (1 - \sum_{k=0}^{n-1} P_k)=∑k=0n−1(k+1)Pk+n(1−∑k=0n−1Pk)$</p>

        <ul>
          <li>Ex.1. $n = 10^9$, $P_0 + P_1 + …+ P_{10^3} = 1$ so $g(n)=O(1)$</li>
          <li>Ex.2. $n = 10^9$, $P_0 + P_1 + …+ P_{\frac n {100} }= 1$, so g(n) = O(n)<em>g</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 배우게 될 내용, 중요</p>
</blockquote>

<ul>
  <li>[중요] <strong>참고: Quick sort 알고리즘 →</strong>
    <ul>
      <li>Worst-case : $O(n^2)$</li>
      <li>Average-Case : $O(n \log n)$</li>
    </ul>
  </li>
</ul>

<h1 id="reviews">Reviews</h1>

<h2 id="summation">Summation</h2>

<ul>
  <li>Sums of powers
    <ul>
      <li>$\sum_{i=1}^{n} i = \frac {n(n+1)} {2}$</li>
      <li>$\sum_{i=1}^{n} i^2 = \frac {n(n+1)(2n+1)} {6}$</li>
      <li>$\sum_{i=1}^{n} i^3 = (\frac {n(n+1)} {2})^2$</li>
      <li>$\sum_{i=1}^{n} i^4 = \frac {n(n+1)(2n+1)(3n^2+3n-1)} {30}$</li>
      <li>$\sum_{i=1}^{n} i^s = \frac {(n+1)^{s+1}} {s+1} + \sum_{k=1}^{s} \frac {B_k} {s-k+1} {s \choose k} (n+1)^{s-k+1}$
        <ul>
          <li>$B_k$ is the $k^{th}$ Bernoulli Number.</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} i^{-s} = \prod_{p prime} \frac {1} {1 - p^{-s}} = \zeta(s)$
        <ul>
          <li>$\zeta_k$ is the Riemann zeta function</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Growth rates
    <ul>
      <li>$\sum_{i=1}^{n} i^c \in \Theta(n^{c+1})$
        <ul>
          <li>for real c greater than 1−1</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} \frac 1 i \in \Theta(log n)$</li>
      <li>$\sum_{i=1}^{n} c^i \in \Theta( n \cdot log(n)^{c+1})$
        <ul>
          <li>for real c_c_ greater than 11</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} log(i)^c \in \Theta(n \cdot log(n)^{c})$ for nonnegative real $c$</li>
      <li>$</li>
    </ul>

    <p>\sum_{i=1}^{n} log(i)^c \cdot i^d \in \Theta(n^{d+1} \cdot log(n)^{c})$ for nonnegative real $c, d$</p>
    <ul>
      <li>$\sum_{i=1}^{n} log(i)^c \cdot i^d \cdot b^i \in \Theta(n^{d} \cdot log(n)^{c} \cdot b^n) $for nonnegative real $b&gt;1, c, db&gt;1,c,d$</li>
    </ul>
  </li>
  <li><strong>Read</strong> <a href="http://en.wikipedia.org/wiki/Summation"><em>Summation</em></a>, <a href="http://en.wikipedia.org/wiki/List_of_mathematical_series."><em>Mathematical Series</em></a></li>
</ul>

<h2 id="run-time-analysis">Run Time Analysis</h2>

<p>What is the worst-case time complexity of each loop?</p>

<ul>
  <li>어디가 dominate한가 : SW를 개발 할 때 최적화를 해 주어야 함. program이 도는 것을 보면 어디가 bottleneck이 되어 비효율적인가</li>
  <li>
    <p>(1) Matrix Addition : $O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>(2)$O(n^2)$
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x+= i+j</code>가 i번 수행되고, $\Sigma_{i=1}^N i = \frac{N(N+1)}{2} = \frac {N^2} 2 + \frac N 2$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">x</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(3) $O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">else</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="c1">// N^2</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
      <span class="c1">// N^2</span>
</code></pre></div>    </div>
  </li>
  <li>(4) $O(n^3)$
    <ul>
      <li>$\frac N 2 \cdot N$ . $\frac N 2 N^2$ → $n^3$이 dominate</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span>
          <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="p">{</span>
                  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>(5)
    <ul>
      <li>$\Sigma_{i=1}^N \Sigma_{j=1}^i j= O(N^3)$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="c1">//What if this is i*i?</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>(6)$ \rightarrow O(N^4)$
    <ul>
      <li>$\Sigma_{i=1}^N \Sigma_{j=1}^{i^2} \Sigma_{k=1}^j k= O(N^4)$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//j가 i의 배수이면</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>n 이 작냐, 크냐에 따라서 10만이냐 100만이냐 할 때 어떤 속도로 나빠질 것인가? 얼마나 잘 유지될 것인가?</li>
      <li>항상 j가 1부터 i^2까지 도는데, j%i ==0 일 때 까지만 돈다 : j가 i의 배수인 경우</li>
      <li>j가 i의 배수일 때 :
        <ul>
          <li>$i = 1,2, … n$</li>
          <li>$j = 1, i, 2i, …, i^2$</li>
          <li>$\Sigma_{i=1}^{N}{(1 + i + … + i^2)}$</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>What is the worst-case time complexity of each loop?</p>

<ul>
  <li>
    <p>(1)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n = 2^k for some positive</span>
      <span class="c1">// integer k</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="c1">// some O(1) computation</span>
              <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(2)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n = 2^k for some positive</span>
      <span class="c1">// integer k</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="c1">// some O(1) computation</span>
              <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(3) Could this be faster?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//</span>
      <span class="kt">float</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="err">–</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(4) Magic square : Could this be faster?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n: odd integer</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">key</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span> <span class="n">key</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">])</span>
              <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
          <span class="k">else</span>
          <span class="p">{</span>
              <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
              <span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(5)$ O(\log n)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// compute x^n (n &gt;= 0)</span>
      <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>
          <span class="p">{</span>
              <span class="n">m</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
              <span class="n">z</span> <span class="o">*=</span> <span class="n">z</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">m</span><span class="o">--</span><span class="p">;</span>
          <span class="n">power</span> <span class="o">*=</span> <span class="n">z</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>time complexity. : $c_0 + c_1 n + c_2 n^2 = O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
              <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>time complexity. : $c( ⌊{log_2 n}⌋+1) \cdot n^2 = O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// n &gt; 0</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>for k=1;k≤n;k=k*2</li>
      <li>floor : 3.7 → 3, ceil : 3.7 → 4</li>
      <li>$n=15 \rightarrow \lfloor log_2 15 \rfloor = \lfloor 3.*** \rfloor = 3$</li>
      <li>1 2 4 8 15</li>
    </ul>
  </li>
  <li>
    <p>time complexity. : $??= O( \sqrt n)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// n &gt; 0</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">i</span><span class="o">++</span><span class="p">;</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
          <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[제일 먼저 생각 Input Size Problem을 풀고자 하는데 이를 sol하고자 하는 algorithm에서, 알고리즘에 들어오는 data의 크기는 어떻게 되는가. 문제 상황에 따라 가로 n, 세로 m의 데이터가 들어오면 (n,m) n일수도 nm일수도 있다. data size가 커짐에 따라 얼마나 시간이 걸리는가 분석 : 얼마난 크기의 데이터가 들어왔을 때, 얼마나 시간이 걸리는가. 시간 분석의 기본 요소 : data의 수 Cost : $g(n)$ 문제가 있을 때 n에 대하여 어느 정도의 비용이 걸리는가.]]></summary></entry><entry><title type="html">[ALG] 1.4. MSS (1)</title><link href="http://localhost:4000/ALG-1.4.-MSS-(1)" rel="alternate" type="text/html" title="[ALG] 1.4. MSS (1)" /><published>2022-09-08T00:00:00+09:00</published><updated>2022-09-08T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-1.4.-MSS-(1)</id><content type="html" xml:base="http://localhost:4000/ALG-1.4.-MSS-(1)"><![CDATA[<blockquote>
  <p>최대 부분 수열의 합 Maximum Subsequence Sum</p>
</blockquote>

<ul>
  <li>어떠한 알고리즘을 설계하느냐에 따라서 어떻게 결과가 달라지는지.</li>
</ul>

<h1 id="maximum-subsequence-sum-mss-problem">Maximum Subsequence Sum (MSS) Problem</h1>

<ul>
  <li><em>Ref</em>. <strong>[M. Weiss,</strong> <strong>Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]</strong>
    <ul>
      <li>Given $N$ (possiblly negative) $A_0, A_1, …, A_{N-1} \in \mathbb{Z}$</li>
      <li>find the maximum value of $\sum_{k=i}^{j} {A_k }$ for $0 \leq i \leq j \leq N-1$</li>
      <li>for convenience, the max subseuqence sum is 0 if all the integers ‘re &lt;0</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>$(-2, 11, -4, 13, -5, -2). → MSS = 20$</li>
      <li>$(a_1, …, a_6)$ : 수열의 모든 가능한 부분수열 중 $\Sigma_{k=i}^j {A_k}$ 임의의 i에서 시작해서 j에서 끝나는 것들을 더했는데 그런 것들 중 제일 큰 것을 찾아라.
        <ul>
          <li>sequence element들은 정수일 때 subsequence를 찾는다.: subsequence의 합이 최대가 되게하는 수열.</li>
          <li>주어진 수열의 정수가 모두 음수이면 mss=0 간주</li>
        </ul>
      </li>
      <li>length = 0, 1, 2로 시작하거나,,
        <ul>
          <li>아무리 빨라도 $n^2$보다 빠르게는 못 만들겠다는 생각이 들 수 있다.
            <ul>
              <li>n개 data 중 가장 작은 것 뽑기 : 한 번씩 sequential search를 해야 하므로 n</li>
              <li>n^2개의 경우는 n^2가 될 것 같은데,</li>
              <li>divide n conquer : $O(N \log N), $ DP : $O(n)$</li>
            </ul>
          </li>
          <li>→ $n + (n-1) + (n-2) + … + 2 + 1 = \frac {n(n+1)}{2} = O(n^2)$</li>
        </ul>
      </li>
      <li>
        <p>이 안에 모든 존재하는 subsequence 중에 합을 가장 크게 하는 subsequence를 찾아라.</p>

        <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/0.png" alt="0" /></p>
      </li>
    </ul>
  </li>
  <li>Maximum Subarray Problem</li>
  <li>Maximum Positive Sum Subarray Problem</li>
  <li>Max. Sum Subsequence versus Max. Subsequence Sum</li>
</ul>

<h1 id="alg-of-maximum-subsequence-sum">Alg of Maximum Subsequence Sum</h1>

<ul>
  <li>길이 n인 정수의 수열 $a_0, a_1, …, a_{n-1}$이 입력으로 주어져 있다.</li>
  <li>여기서 부분 수열 $[i, j]$ 라는 것은 $ a_i, a_{i+1}, a_{i+2}…, , a_{j}$를 말한다.</li>
  <li>a의 최대값을 구하는 문제이다.
    <ul>
      <li>(이때 주어진 수열의 정수가 모두 음수이면 최대 부분 수열의 합은 0 이라고 간주한다)</li>
      <li>예를 들어 다음과 같은 수열이 주어졌을 때, $+ 31, −41, +59, +26, −53, +58, +97, −93, −23, +84$  최대 부분 수열은 [2,6]이며 수열의 합은 187 이 된다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/1.png" alt="1" /></p>
  </li>
  <li>이 문제는 최대 부분 수열의 합을 구하는 것이지만, 앞으로 소개할 알고리즘을 조금만 수정하면 최대 부분 수열도 쉽게 구할 수 있다.
    <ul>
      <li>empty string : letter char=0, NULL String</li>
      <li>substring</li>
      <li>string</li>
      <li>length</li>
    </ul>

    <blockquote>
      <p>Algorithm1 : 모든 경우의 수 찾기 - $O(N^3) $</p>
    </blockquote>

    <blockquote>
      <p>Algorithm2 : Sum구할 때 중복 조금 피하기 - $O(N^2)$ </p>
    </blockquote>

    <ul>
      <li>simple counting
        <ul>
          <li>$O(n^2)$ : SS 여러 개가 있는데 한 번씩 모두 보자.</li>
          <li>$i$에서 시작하는 것들 1, 2, … 개를 모두 보자 : $n^2$개를 모두 본 것.</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/2.png" alt="2" /></p>

    <blockquote>
      <p>Algorithm3 : Divide n Conquer - $O(N \log N)$ </p>
    </blockquote>

    <ul>
      <li>Divide n Conquer
        <ul>
          <li>경우를 나눈다 : MSS subsequence가 존재하는데 이를 반으로 잘라서 분명히 어딘가 존재한다 → 왼쪽 혹은 오른쪽, 아니면 양다리 걸치던지.</li>
          <li>왼쪽 중 제일 큰 것 찾고, 오른쪽 존재 중 제일 큰 것 ㅈ찾고, 양다리 중 제일 큰 것 찾고.</li>
          <li>그중에 제일 큰 것을 찾았는데 O(Nlog N)걸리더라</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/3.png" alt="3" /></p>

    <blockquote>
      <p>Algorithm4 : Dynamic Programming - $O(N)$</p>
    </blockquote>

    <ul>
      <li>DP
        <ul>
          <li>각각의 i에 대해서 i번째 끝나는 애들</li>
          <li>분명히 maximum sum을 해주는 것은 하나 존재하는데 첫 번째 원서로 끝나던지, … 몇 번째쯤에 끝날 것이다. n번째에서 끝나는 것들 각각을 보자는 의미이다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/4.png" alt="4" /></p>

    <ul>
      <li>algorithm을 만들 때, 효율을 신경쓰지 말고 하나하나 따져본다. 고등학교 때 순열과 조합으로 경우의 수를 따지는데, 전공에서 매우 중요한 요소이다.
        <ul>
          <li>문제를 어떻게 접근해 해결함에 따라 n^2개가 있음에도 불구하고 훨씬 더 효율적으로 문제를 해결할 수 있다.</li>
        </ul>
      </li>
      <li>이런 수열이 주어졌을 때 분명 답은 존재한다:</li>
      <li>alg 1, 2
        <ul>
          <li>모두 -라면 정답은 0이고 :
            <ul>
              <li>-임을 확인하는 비용은 linear time</li>
            </ul>
          </li>
          <li>양수가 하나라도 있으면 찾아보아야 한다</li>
        </ul>
      </li>
    </ul>

    <p>0에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고, —- 1, 2 번째에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고. n-1 까지 중 제일 작은 거</p>
  </li>
</ul>

<h1 id="mss-1---simple-counting">MSS 1 - simple counting</h1>

<ul>
  <li>Strategy
    <ul>
      <li>Enumerate all possibilities one at a time.</li>
      <li>
        <p>No efficiency is considered, resulting in a lot of unnecessary computation!</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Maxsum</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">Thissum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">j</span><span class="p">])</span>
              <span class="n">Maxsum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Thissum</span><span class="p">,</span> <span class="n">Maxsum</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>모든 경우의 수를 하나하나 모두 따져보는 방법.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
      <span class="c1">// i = 리스트 왼쪽 끝 인덱스, j = 리스트 오른쪽 끝 인덱스,</span>
      <span class="c1">//  ThisSum = 고려 대상 부분 리스트 합, MaxSum = 문제 최종결론</span>
      <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
                  <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>Is this for-loop OK for you?</li>
      <li>Time Complexity : $O(N^3)$
        <ul>
          <li>𝑖와 관련된 반복문은 𝑛n번, 𝑗와 관련된 반복문은 최대 𝑛번, Thissum을 구할 때 최대 𝑛개의 요소를 계산해야 하기에</li>
          <li>
            <p>$\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>$\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// for (i = 0; i &lt; N; i++)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
     <span class="c1">// {</span>
       <span class="c1">//   ThisSum = 0;</span>
         <span class="c1">// for (k = i; k &lt;= j; k++)</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>$\sum_{k=i}^{j} 1 = j-i+1$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//for (i = 0; i &lt; N; i++)</span>
  <span class="c1">//    for (j = i; j &lt; N; j++)</span>
  <span class="c1">//    {</span>
  <span class="c1">//        ThisSum = 0;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>0번째에서 시작해서 Max 구한 것,…, n번째에서 시작하여 Max 구한 것.</li>
      <li>크게 바깥쪽에서 for loop이 돌면서 i번째부터 시작해서 i 하나, 두개, 세개, … 모든 것을 다 봐서 i번째에서 시작하는 것 중 가장 큰 것을 찾으려 한다.</li>
      <li>for loop은 i, i+1, i - i+2, i - n-1… 까지 더해 봄.</li>
    </ul>

    <blockquote>
      <p>💡 [개선점] 이전에 더한것에다가 하나만 더 더하면 되지 않을까</p>
    </blockquote>
  </li>
</ul>

<p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/5.png" alt="5" /></p>

<h1 id="mss-2">MSS 2</h1>

<ul>
  <li>
    <p>Strategy</p>

    <blockquote>
      <p>💡 이전 스택에서 하나만 더 더하면 되는 것 아닌가?</p>
    </blockquote>

    <ul>
      <li>Get rid of the inefficiency in the innermost for-loop. Algorithm 1보다 중복을 줄이는 방법</li>
      <li>
        <p>for loop가 하나 사라지게 됨.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Maxsum</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">Thissum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">j</span><span class="p">])</span>
              <span class="n">Maxsum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Thissum</span><span class="p">,</span> <span class="n">Maxsum</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>Notice that $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
      <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
                  <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
      <li>time complexity : $O(N^3) \rightarrow O(N^2)$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/6.png" alt="6" /></p>

<h1 id="mss--3--divide-n-conquer">MSS  3 : Divide n Conquer</h1>

<p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/7.png" alt="7" /></p>

<ul>
  <li>Divide and Conquer
    <ul>
      <li>경우의 수를 따짐 : 전부 다 음수가 아니라면 분명히 하나 존재한다.</li>
      <li>0번 원소부터 n-1 원소까지 있는데 이를 반으로 1/2로 뚝 자르고,
        <ul>
          <li>홀수 개수면 정확히 나눠지지 않음, 짝수 개수이면 정확히 둘로 나누어짐</li>
        </ul>
      </li>
      <li>left segment에 있던지 right segment에 있던지 양다리 걸치던지. 의 세가지 케이스 중 제일 큰 값을 찾는다.</li>
      <li>→ 이 전체에서 mss를 찾고자 하는데, 일단 왼쪽하고 오른쪽 각각에서 MSS 찾고</li>
    </ul>
  </li>
  <li>원래 플고자 하는 문제와 problem size만 다르다
    <ul>
      <li>전체 subsequence를 반으로 잘라 left- right segment 각각 영역에서의 MSS를  찾고자 함.</li>
      <li>결국 같은 문제 : problem size 만 1/2, 1/2된 케이스</li>
      <li>전체 문제 사이즈 2인것을 1, 1로 divide하여 각각의 segment에서 conquer하여 찾는다</li>
      <li>with - ‘Recursion’
        <ul>
          <li>자기 자신을 부른다 :</li>
          <li>항상 recursive call을 할 때는 problem size를 작게 하여 부른다.</li>
          <li>양다리 걸치는 것 중 제일 큰 것을 찾아 비교</li>
          <li>각 동네에서 MSS를 찾아 그 중 제일 큰 것을 돌린다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why is Log N
    <ul>
      <li>[사진]</li>
      <li>Binary Tree에서 각 depth별로 $1 , 2, 4, 8, …$</li>
      <li>$O (N \log N)$</li>
    </ul>
  </li>
  <li>Strategy
    <ul>
      <li>Use the <strong>Divide-and-Conquer</strong> strategy.
        <ul>
          <li>원 문제를 작은 문제로 나눠 풀고, 그 결과를 합쳐 문제를 해결하는 알고리즘</li>
        </ul>
      </li>
      <li>The maximum subsequence sum can be in one of three places.</li>
      <li>교재에 탑재되어 있지만 그렇게 좋은 코드가 아닌듯 하다 !</li>
      <li>leaf node 1개까지 내려왔을 경우 양수이면 그대로 return하고 음수이면 0</li>
      <li>Divide and Conquer
        <ul>
          <li>center를 찾아 중앙 지점 : 똑같은 문제 [index left-right] 를 풀지만 [left-center], [center-right]로 원래 풀고자 하는 문제를 divide해서 푼다.</li>
          <li>recursion의 묘미 : 막아주는 부분 (else return 0)이 있어야 top-down으로 내려갈 수 있는 divide and conquer</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">Left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Right</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">MaxLeftBorderSum</span><span class="p">,</span> <span class="n">MaxRightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">LeftBorderSum</span><span class="p">,</span> <span class="n">RightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">Center</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">//종료조건if (Left == Right){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">];</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// divide n conquer</span>
  <span class="n">Center</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="o">+</span> <span class="n">Right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//왼쪽, 오른쪽, 중간</span>
  <span class="n">MaxLeftSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Center</span><span class="p">);</span>
  <span class="n">MaxRightSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Right</span><span class="p">);</span>
		
  <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">LeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 1. left ending 끝으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">LeftBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LeftBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxLeftBorderSum</span><span class="p">)</span>
          <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">LeftBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
  <span class="c1">// 2. right ending 시작으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">RightBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RightBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxRightBorderSum</span><span class="p">)</span>
          <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="n">RightBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">Max3</span><span class="p">(</span><span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">,</span> <span class="n">MaxLeftBorderSum</span> <span class="o">+</span> <span class="n">MaxRightBorderSum</span><span class="p">);</span>
  <span class="c1">// MaxLeftSum - left segment의 sum</span>
  <span class="c1">// MaxRighttSum - right segment의 sum</span>
  <span class="c1">// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대</span>
  <span class="err">}</span>
  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것
            <ul>
              <li></li>
            </ul>
          </li>
        </ul>

        <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/8.png" alt="8" /></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">Left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Right</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">MaxLeftBorderSum</span><span class="p">,</span> <span class="n">MaxRightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">LeftBorderSum</span><span class="p">,</span> <span class="n">RightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">Center</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">//종료조건if (Left == Right){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">];</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// divide n conquer</span>
  <span class="n">Center</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="o">+</span> <span class="n">Right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//왼쪽, 오른쪽, 중간</span>
  <span class="n">MaxLeftSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Center</span><span class="p">);</span>
  <span class="n">MaxRightSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Right</span><span class="p">);</span>
		
  <span class="c1">// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것</span>
		
  <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">LeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 1. left ending 끝으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">LeftBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LeftBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxLeftBorderSum</span><span class="p">)</span>
          <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">LeftBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
		
  <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
  <span class="c1">// 2. right ending 시작으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">RightBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RightBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxRightBorderSum</span><span class="p">)</span>
          <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="n">RightBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">Max3</span><span class="p">(</span><span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">,</span> <span class="n">MaxLeftBorderSum</span> <span class="o">+</span> <span class="n">MaxRightBorderSum</span><span class="p">);</span>
  <span class="c1">// MaxLeftSum - left segment의 sum</span>
  <span class="c1">// MaxRighttSum - right segment의 sum</span>
  <span class="c1">// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대</span>
  <span class="err">}</span>
  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>cost : $T(n) = 2T(\frac n 2) + cn$, $T(1) = d$</li>
  <li>why O(N log N)<em>O</em>(<em>NlogN</em>) ?
    <ul>
      <li>$T(n) = 2T(\frac n 2) + cn$</li>
      <li>
        <p>$T(1) = d$</p>

        <p>$= 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$</p>

        <p>$= 2^2 T [ \frac n {2^2}] + 2cn$</p>

        <p>$= 2^3 T [ \frac n {2^3}] + 3cn =…$</p>

        <p>$= 2^i T [ \frac n {2^i}] + icn$</p>

        <p>$= 2^{\log_2 n} T(1) + \log_2 n \cdot cn$</p>

        <p>$=nT(1) + \log_2 n \cdot cn$</p>

        <p>$= O(n) + O(n \log_2 n) = O(n \log_2 n)$</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="mss--4-kadanes-algorithm">MSS  4; Kadane’s algorithm</h1>

<ul>
  <li>
    <p>i번째 원소로 끝나는 가장 합이 큰 subsequence가 얘라면, 다른 나머지를 분리했을 때 i-1로 끝나는 subsequence이다.</p>

    <p><img src="/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/9.png" alt="9" /></p>

    <ul>
      <li>아니다 → 모순 증명 : 고등학교 proof by contradiction 귀류법으로</li>
      <li>i원소로 끝나는 합이 제일 큰 subsequence는 얘인데, 합이 제일 큰 subsequence가 되어야 한다.</li>
      <li>합이 제일 큰 부분을 찾는데, 나보다 하나 앞애 있는 i-1까지의 sequence로 바뀐다.
        <ul>
          <li>recursion이랑 비슷 : 같은 문제룰 푸는데 문제 크기가 달라짐. 이를 어떤 형식으로 해결하느냐에 따라서 달라지게 됨.</li>
        </ul>
      </li>
      <li>i번째 끝나는 subsequence중에 여러가지 있을 수 있는데, 그 중 가장 합이 큰 것을 Bi라고 할 때
        <ul>
          <li>$B[i]$ : the sum of the maximum subsequence that ends at index $i$</li>
          <li>$B[i] = \max { B[i-1] + A[i], 0}$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Strategy</p>
    <ul>
      <li>Use the Dynamic Programming strategy.</li>
      <li>subsequence sum&lt;0인 경우, 논리적으로 최대값이 될 수 없음에 착안한 전략</li>
      <li>
        <p>만약에 sum이 음수라도 무방하고 1개 이상의 원소로 구성된 Subsequence (subarray)를 구하는 문제라면?</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		
      <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// j번째 원소르 끝나는 것 중 합이 제일 큰 것</span>
          <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 지금까지의 원소르 끝나는 것 중 합이 제일 큰 것</span>
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
          <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
              <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="c1">// if (ThisSum&lt;0) ThisSum=0; </span>
              <span class="c1">// else if (ThisSum&gt;MaxSum) MaxSum = ThisSum;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>thissum : j 번째 돌 때 j-1번째 원소로 끝나는 것 중 제일 합이 큰 것.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">ThisSum += A[j]</code></li>
        </ul>
      </li>
      <li>ThisSum → 0, j번째 원소로 끝나는 것 중 가장 큰 거보다 크면 바꿔치기하고..</li>
      <li>최소한 모든 원소를 한 번씩은 봐야 하기 때문에 linear보다 더 빠른 alg는 없다.</li>
      <li>Time Complexity : $O(n)$
        <ul>
          <li>for i, iteration n times, and $ O(1$) for 1 calculation</li>
        </ul>
      </li>
      <li>C Implementation
        <ul>
          <li>
            <p>Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">kadane</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">finish</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
			
      <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">local_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="n">local_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">maxSum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
              <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">local_start</span><span class="p">;</span>
              <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">finish</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
  <span class="c1">// at least one non-negative number.</span>
			
  <span class="c1">// When all numbers in the array are negative</span>
      <span class="n">maxSum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">maxSum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
              <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="c1">// Empty subsequence를 허용하면 0을 리턴 (원래 문제)</span>
  <span class="c1">// Empty subsequence를 허용하지 않으면 음수 중 가장 큰 원소를 리턴</span>
          <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
  <span class="p">}</span>
			
			
			
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="so-why-do-we-bother-with-the-time-complexity">So, why do we bother with the time complexity?</h3>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[최대 부분 수열의 합 Maximum Subsequence Sum]]></summary></entry><entry><title type="html">[ALG]</title><link href="http://localhost:4000/ALG" rel="alternate" type="text/html" title="[ALG]" /><published>2022-09-07T00:00:00+09:00</published><updated>2022-09-07T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-</id><content type="html" xml:base="http://localhost:4000/ALG"><![CDATA[<h1 id="1-how-to-think-and-solve-problems-with-computer"><strong>1. How to think and solve problems with computer</strong></h1>

<h2 id="data-structurealgorithmtheory-of-computation"><strong>Data Structure→Algorithm→Theory of Computation</strong></h2>

<ul>
  <li>어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?
    <ol>
      <li>[Data Structure] 주어진 추상적인 문제를 <strong>어떠한 자료 구조</strong>를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?</li>
      <li>[Algorithm] 주어진 추상적인 문제를 어떠한 <strong>알고리즘을</strong> 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까</li>
      <li>[Complexity] 과연 컴퓨터가 주어진 문제를 <strong>효율적으로</strong> 해결할 수 있을까 ?</li>
      <li>[Computability] 과연 컴퓨터가 세상의 <strong>모든 문제를 해결</strong>할 수 있을까?</li>
    </ol>
  </li>
  <li>Data Structure &amp; Algorithm → 1, 2, 3</li>
  <li>Automata Theory → 4</li>
</ul>

<h1 id="2-def-of-algorithm"><strong>2. Def. of Algorithm</strong></h1>

<h2 id="definition-of-algorithm"><strong>Definition of Algorithm</strong></h2>

<p>from [Horowitz 1.2]</p>

<ul>
  <li>An <strong>algorithm</strong> is a <strong>finite set of instructions that</strong>, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:
    <ol>
      <li><strong>Input</strong>.
        <ul>
          <li>Zero or more quantities from the outside.</li>
          <li>외부로부터 0개 이상의 수량이 입력으로서 들어온다.</li>
        </ul>
      </li>
      <li><strong>Output</strong>.
        <ul>
          <li>At least one quantity is produced.</li>
          <li>하나 이상의 결과값이 수행된다.</li>
        </ul>
      </li>
      <li><strong>Definiteness</strong>.
        <ul>
          <li>Each instruction is clear and unambiguous.</li>
          <li>각 지침은 모두 명확하며, 애매하게 쓰여 있지 않다.</li>
        </ul>
      </li>
      <li><strong>Finiteness</strong>.
        <ul>
          <li>If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.</li>
          <li>제한된 수의 단계 후 종료된다.</li>
        </ul>
      </li>
      <li><strong>Effectiveness</strong>.
        <ul>
          <li>Every instruction must be basic enough to be carried out, in principle, by a person using only pencil and paper.</li>
          <li>손으로 풀 수 있을 만큼 효과적이어야 한다.</li>
          <li>It is not enough that each operation be definite as in (3);</li>
          <li>it also must be feasible. 또한 실현 가능하여야 한다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="thoughts-on-4-finiteness-computability"><strong>Thoughts on 4) Finiteness: [Computability]</strong></h2>

<ul>
  <li>Problem (<a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Post’s correspondence problem</a> 포스트 대응 문제)
    <ul>
      <li>결정 불가능한 결정 문제의 예시, 1946년 emil post 에 의해 고안</li>
      <li>Consider a finite set <em>P</em> of ordered pairs of nonempty strings such as <em>P</em>={(<em>a</em>,<em>ab</em>),(<em>b</em>,<em>c__a</em>),(<em>c__a</em>,<em>a</em>),(<em>ab__c</em>,<em>c</em>)}</li>
      <li>A match of <em>P</em> is any string w such that, for some <em>m</em>&gt;0 and some pairs (<em>u_1,_v_1),(_u_2,_v_2),…,(_u__m</em>,<em>v__m</em>)∈<em>P</em>, <em>w</em>=<em>u_1_u_2…_u__m</em>=<em>v_1_v_2…_v__m</em>.</li>
      <li>Design an algorithm that determine, given P, whether P has a match.</li>
    </ul>
  </li>
  <li>
    <p>Cheolsu’s algorithm</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">For</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">...</span> <span class="k">do</span>
    <span class="n">For</span> <span class="n">each</span> <span class="n">permutation</span> <span class="n">of</span> <span class="n">P</span> <span class="n">of</span> <span class="n">length</span> <span class="n">i</span><span class="p">,</span> <span class="k">do</span>
      <span class="n">If</span> <span class="n">it</span> <span class="n">is</span> <span class="n">a</span> <span class="n">match</span><span class="p">,</span> <span class="n">print</span> <span class="err">‘</span><span class="n">yes</span><span class="err">’</span> <span class="n">and</span> <span class="n">exit</span><span class="p">.</span>
      <span class="n">If</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span><span class="p">.</span>
	
</code></pre></div>    </div>

    <ul>
      <li>Can this be regarded as an algorithm?</li>
    </ul>
  </li>
</ul>

<h2 id="thoughts-on-efficiency-complexity"><strong>Thoughts on Efficiency: [Complexity]</strong></h2>

<ul>
  <li><strong>An algorithm is regarded as efficient or good</strong> if there exist a polynomial <em>P</em>(<em>n</em>) such that the time required for solving any instance of size <em>n</em> is bounded above by <em>P</em>(<em>n</em>).</li>
  <li>NP-Complete problems:
    <ul>
      <li>Nobody has found so far any good algorithm for any problem in this class.</li>
      <li>It has been proved that if a good algorithm exists for some algorithm in this class, then a good algorithm exists for all NP-Complete Problem.</li>
    </ul>
  </li>
  <li>Examples
    <ul>
      <li>Suppose a CD-ROM can store up to 720MBytes of data. You have a sequence of n files of sizes <em>s_1,_s_2,…,_s__n</em> Mbytes, to dump into backup CDs. What is the minimum number of necessary CDs to store all the files?</li>
      <li>Consider n tasks to be executed on CPU. All the tasks must be finished within the time requirement L (seconds). If the <em>i_th task takes _s__i</em> seconds, and you can harness multiple processors, what would be the minimum number of processors needed to accomplish this?</li>
      <li>Ex. <em>L</em>=10, <em>n</em>=6, and $(s_1, s_2, s_3, s_4, s_5, s_6) = (5, 6, 3, 7, 5, 4) $</li>
      <li>then (5,5),(6,4),(7,3)</li>
    </ul>
  </li>
</ul>

<p>어떻게 하면 좀 더 “효율적으로” 문제를 해결할까?</p>

<h2 id="efficient-algorithm-design"><strong>Efficient Algorithm Design</strong></h2>

<p><strong>Example 1</strong></p>

<ul>
  <li>Sequential search vs binary search
    <ul>
      <li>Problem: Determine whether <em>x</em> is in the sorted array <em>S</em> of <em>n</em> keys.</li>
      <li>Inputs: positive integer <em>n</em>, sorted (nondecreasing order) arrays of keys S indexed from 0 to <em>n</em>−1, a key <em>x</em>.</li>
      <li>Outputs: the location of <em>x</em>∈<em>S</em> (−1 if <em>x</em>∈/<em>S</em>).</li>
    </ul>
  </li>
  <li>Sequential search: <em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
  <li>Binary search: <em>T</em>(<em>n</em>)=<em>O</em>(<em>l__o__g__n</em>)</li>
  <li>

    <p><img src="/assets/img/2022-09-07-[ALG]-.md/0.png" alt="0" /></p>

    <ul>
      <li>[From Neapolitan] The number of comparisons done by Sequential &amp; Binary Search when <em>x</em> is larger than all the array items
        <ul>
          <li>40억 개의 element가 array에 있을 때, Sequential Search는 40억 개 항목과 비교하는 반면에 Binary Search는 단 33개의 항목만을 비교한다.</li>
          <li>컴퓨터가 1ns에 whlie loop를 통과할 수 있다고 가정한들 Binary search는 즉각적으로 결정을 내리는 반면 Sequential Search는 4s가 걸린다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why is the binary search more efficient? 왜 이진검색이 더 효율적인가?</li>
</ul>

<p><strong>Example 2:The Fibonacci Sequence</strong></p>

<ul>
  <li>Problem: Determine the _n_th term in the Fibonacci sequence.</li>
  <li>Inputs: a nonnegative integer <em>n</em></li>
  <li>
    <p>Outputs: the nth term of the Fibonacci sequence.</p>

    <p><em>f_0=0_f_1=1_f__n</em>=<em>f__n</em>−1+<em>f__n</em>−2 for <em>n</em>≥2</p>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//&lt;recursive: divide-and-conquer&gt;</span>
<span class="kt">int</span> <span class="nf">fib</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//&lt;iterative: dynamic programming&gt;</span>
  <span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">index</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="n">n</span><span class="p">];</span>
  <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  	<span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
  <span class="p">}</span><span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>Recursive: $T(n) = O(2^n) $</li>
  <li>Iterative: <em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
  <li>Why is the iterative version more efficient?
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-07-[ALG]-.md/1.png" alt="1" /></p>
      </li>
      <li><em>T</em>(<em>n</em>)&gt;22<em>n</em> for <em>n</em>≥2</li>
      <li>Mathematical induction을 써서 증명해볼 것!</li>
    </ul>
  </li>
  <li>Linear versus exponential
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-07-[ALG]-.md/2.png" alt="2" /></p>
      </li>
      <li>[From Neapolitan] This table compares these expressions for various values of n. The execution times are based on the simplifying assumption that one term can be computed in 10−9 second.</li>
      <li>The table shows the time it would take ‘Iterative Algorithm’ to compute the nth term on a hypothetical computer that could compute each term in a nanosecond, and it shows a lower bound on the time it would take to execute ‘Iterative Algorithm’.</li>
      <li>By the time n is 80, ‘Recursive Algorithm’ takes at least 18 minutes. When n is 120, it takes more than 36 years, an amount of time intolerable compared with a human life span. Even if we could build a computer one billion times as fast, ‘Recursive Algorithm’ would take over 40,000 years to compute the 200th term. This result can be obtained by dividing the time for the 200th term by one billion.</li>
      <li>We see that regardless of how fast computers become, ‘Recursive Algorithm’ will still take an intolerable amount of time unless n is small. On the other hand, ‘Iterative Algorithm’ computes the nth Fibonacci term almost instantaneously.</li>
    </ul>

    <p>This comparison shows why the efficiency of an algorithm remains an important consideration regardless of how fast computers become</p>
  </li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[1. How to think and solve problems with computer]]></summary></entry><entry><title type="html">[ALG]</title><link href="http://localhost:4000/ALG" rel="alternate" type="text/html" title="[ALG]" /><published>2022-09-02T00:00:00+09:00</published><updated>2022-09-02T00:00:00+09:00</updated><id>http://localhost:4000/%5BALG%5D-</id><content type="html" xml:base="http://localhost:4000/ALG"><![CDATA[<h1 id="10-computational-thinking"><strong>1.0. Computational Thinking</strong></h1>

<h2 id="definition-of-computational-thinking"><strong>Definition of computational thinking</strong></h2>

<p>The thought processes involved in (i) formulating a problem and (ii) expressing its solutions in such a way that a computer –human or machine- can effectively carry out.</p>

<ol>
  <li>Problem formulation (abstraction)</li>
  <li>Solution expression (automation)</li>
  <li>Solution execution &amp; evaluation (analyses)</li>
</ol>

<h2 id="characteristics-of-computational-thinking"><strong>Characteristics of computational thinking</strong></h2>

<ul>
  <li>Formulating problems in a way that enables us to use a computer and other tools to help solve them</li>
  <li>Logically organizing and analyzing data → Data structure</li>
  <li>Representing data though abstractions such as models and simulations → Data Structure</li>
  <li>Automating solutions through algorithmic thinking (a series of ordered steps) → Algorithm</li>
  <li>Identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and effective combination of steps and resources → time and space complexity</li>
  <li>Generalizing and transferring the problem solving process to a wide variety of problems</li>
</ul>

<h2 id="problem-solving-in-computer-science-and-engineering"><strong>Problem Solving in Computer Science and Engineering</strong></h2>

<p>문 제 (Problem) → 해 (Solution)</p>

<ul>
  <li>Problem : 가상 현실, 문서작성, 홈뱅킹, 인터넷 신문, 문서 번역, 회로 설계, 유전자 분석, 무인 자동차, 온라인 게임, 비디오 편집, 자료 검색, 영화 제작, 음성 인식, 가상 수술, 건축 설계, 기상 예측, 주가 예측, 인공 지능, 대용량 과학 계산, …</li>
</ul>

<h2 id="problem-solving-pipeline"><strong>Problem Solving Pipeline</strong></h2>

<p><img src="/assets/img/2022-09-02-[ALG]-.md/0.png" alt="0" /></p>

<h1 id="도강-문제"><strong>도강 문제</strong></h1>

<p>한 어부(M)가 늑대(W), 염소(G), 양배추(C)를 강 한 쪽에서 다른 쪽으로 옮기려 한다. 어부가 배를 타고 강을 건널 때 어부 자신 외에 늑대, 염 소, 양배추 중 하나만 배에 가지고 갈 수가 있는데, 문제는 어부가 늑대 를 싣고 가는 동안, 염소가 양배추를 같은 쪽에 남겨두면 염소가 양배 추를 먹어버리게 되고, 양배추를 싣고 갈 때 늑대와 염소를 같은 쪽에 남겨둘 경우 늑대가 염소를 잡아 먹게 된다. 과연 어떻게 하면 어부가 가장 적은 회수로 강을 건너면서 세 가지를 모두 안전하게 옮길 수 있을까?</p>

<h2 id="문제-분석"><strong>문제 분석</strong></h2>

<p><img src="/assets/img/2022-09-02-[ALG]-.md/1.png" alt="1" /></p>

<ul>
  <li></li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-.md/2.png" alt="2" /></p>

<h2 id="해법-고안"><strong>해법 고안</strong></h2>

<ul>
  <li>Graph, search, and so on → Which data structures and algorithms?</li>
  <li>Cost, time, space, and so on → What complexities?</li>
</ul>

<p>[연습] 이 문제에 대한 알고리즘과 시간/공간 복잡도를 컴퓨터학의 용 어를 써서 기술한다면, ???</p>

<ul>
  <li>무슨 말인지 전혀 모르겠으면 [43-080 자료구조]를 재수강한 후 이 과목을 들을 것!</li>
</ul>

<h1 id="구현---programming-is-an-art"><strong>구현 : ✓ Programming is an art!</strong></h1>

<ul>
  <li>어떻게 하면 주어진 알고리즘을 가장 효과적으로 구현을 할 수 있을까?</li>
  <li>어떻게 하면 C/C++를 사용하여 주어진 알고리즘을 가장 최적으로 구현할 수 있을까?
    <ul>
      <li>원시 코드 레벨의 측면</li>
      <li>어셈블러 레벨의 측면</li>
      <li>시스템 레벨의 측면</li>
      <li>기타</li>
    </ul>
  </li>
  <li>✓ 과연 내가 <a href="http://acm.uva.es/problemset/%EC%97%90">http://acm.uva.es/problemset/에</a> 있는 문제들을 스스로 “문제 분석 → 해법 고안 → 구현” 과정을 통하여 효과적으로 해결할 수 있을까???
    <ul>
      <li>Programming Challenges by S. Skiena and M. Revilla, Springer, 2003.</li>
    </ul>
  </li>
  <li>어떻게 하면 좋은 구현 결과를 얻을 수 있는가?
    <ul>
      <li>동일한 프로세서 상에서 더 빠르게</li>
      <li>적은 메모리만 사용하게</li>
      <li>안정적이게</li>
    </ul>
  </li>
  <li>
    <p>구현 예</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-.md/3.png" alt="3" /></p>

    <p><img src="/assets/img/2022-09-02-[ALG]-.md/4.png" alt="4" /></p>
  </li>
</ul>

<p>19 0.265968초 4.862961초 3.4GHz Intel Core i7 CPU</p>

<h1 id="data-structure--algorithm--theory-of-computation"><strong>Data Structure → Algorithm → Theory of Computation</strong></h1>

<ul>
  <li>어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?
    <ol>
      <li>[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?</li>
      <li>[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까?</li>
      <li>[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?</li>
      <li>[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결할 수 있을까?</li>
    </ol>
  </li>
  <li>✓ 이 과목에서는 [CSE3080 자료구조] 과목에 이어, 1번과 2번을 집중적으로 살펴보 고, 3번 문제에 대하여 어느 정도 살펴볼 예정임.</li>
  <li>4번 문제는 [CSE3085 자동장치이론] 과목에서 다룸.</li>
</ul>]]></content><author><name>Kyuhwan Shim</name><email>kyuhwan.shim@sogang.ac.kr</email></author><category term="Notes" /><category term="Algorithm" /><summary type="html"><![CDATA[1.0. Computational Thinking]]></summary></entry></feed>