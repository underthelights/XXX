<h2 id="selection-treeschapter-58">Selection Trees(Chapter 5.8)</h2>

<h3 id="581-introduction">5.8.1 Introduction</h3>

<ul>
  <li>A selection tree is a tree where the key of a parent node is equal to one of the keys of its child nodes.</li>
  <li>A typical application of a selection tree is sorting.</li>
  <li>There are two kinds of selection trees : winner trees and loser trees.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/135758098-29ac27d8-f5be-439a-86a1-f205f5be7a65.png" alt="image-20211002200428453" /></p>

<h3 id="582-winner-trees">5.8.2 Winner Trees</h3>

<ul>
  <li>
    <p>A winner tree is a complete binary tree with n external nodes and n - 1 internal nodes.</p>
  </li>
  <li>
    <p>External nodes represent tournament players.</p>
  </li>
  <li>
    <p>Each internal node represents a match played between its two children; the winner of the match is stored at the internal node.</p>
  </li>
  <li>
    <p>The root node has the overall winner.</p>

    <p><img width="352" alt="image-20211002200822734" src="https://user-images.githubusercontent.com/46957634/135758198-bcda0821-c4d0-4a1d-826a-e8ad97508207.png" /></p>
  </li>
  <li>
    <p>Suppose we have a list of 16 numbers that are not sorted.</p>

    <ul>
      <li>In a tournament game, the smaller number wins the match.</li>
    </ul>
  </li>
  <li>
    <p>How many games do we need to play in order to decide the overall winner ?</p>

    <p><img width="435" alt="image-20211002200838531" src="https://user-images.githubusercontent.com/46957634/135758200-bbd3efe1-6987-4912-b5f2-aa586fdf35a5.png" /></p>
  </li>
  <li>
    <p>We need to play 15 games.</p>

    <p><img width="435" alt="image-20211002200904464" src="https://user-images.githubusercontent.com/46957634/135758202-c6429729-6d1f-4339-adff-adf7ed06afc9.png" /></p>
  </li>
  <li>Initializing the winner tree takes O(n), when n is the number of players entering the tournament.</li>
  <li>
    <p>After initializing the winner tree, we remove the key at the root.</p>
  </li>
  <li>Then, we remove the player that eventually won the tournament.
    <ul>
      <li>The internal nodes should remember the player(array index or pointer to the node) as well as its key.</li>
      <li>We can replace the key of the winner with a large number.</li>
      <li><img src="https://user-images.githubusercontent.com/46957634/135758216-8cb02d02-c1a4-41a7-b10a-d27bb52dc3af.png" alt="image-20211002200520333" /></li>
    </ul>
  </li>
  <li>
    <p>After removing the winner, we do a rematch along the branches from the previous winner to the root.</p>

    <ul>
      <li>Other matches do not need to be redone.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/46957634/135758235-91914425-fc54-4151-af40-fc29474dbd43.png" alt="image-20211002200503259" /></p>
  </li>
  <li>
    <p>Similarly, remove the winnerand do a rematch.</p>

    <p><img src="https://user-images.githubusercontent.com/46957634/135758244-c79c06b9-7a4d-4d3c-affc-db1496390b3f.png" alt="image-20211002200552689" /></p>
  </li>
  <li>
    <p>We continue this until all players are removed(changed to 99).</p>

    <ul>
      <li>We have sorted the numbers.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/46957634/135758257-3cd33665-5cac-4752-a2c4-1419a4a0892f.png" alt="image-20211002200559191" /></p>
  </li>
</ul>

<h4 id="analysis-of-winner-tree">Analysis of Winner Tree</h4>

<ul>
  <li>Initializing takes O(n) time.</li>
  <li>Removing the winner and replaying takes O(log n) time.
    <ul>
      <li>Move along the branches from the removed node to the root.</li>
    </ul>
  </li>
  <li>We need to repeat “removing the winner and replaying” n times.
    <ul>
      <li>This will take O(n log n) time.</li>
    </ul>
  </li>
  <li>Total sort time is O(n log n).</li>
</ul>

<h3 id="583-loser-trees">5.8.3 Loser Trees</h3>

<p><img src="https://user-images.githubusercontent.com/46957634/135758270-aa135bc4-b10d-4f2f-ab5e-4766a15ab9f4.png" alt="image-20211002200658462" /></p>

<ul>
  <li>In a loser tree, each internal node stores the loser of the match.
    <ul>
      <li>Don’t get confused: we are still looking for the overall winner.</li>
    </ul>
  </li>
  <li>Suppose we have moved the winner with key = 1, and replaced the node with key = 99.</li>
  <li>Then, we need to do replays along the branches from the replaced node to the root.</li>
  <li>In a winner tree, in order to do replay, we needed to compare the keys between the replaced nodeand its sibling.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/135758272-b1200b66-a1c9-4b16-afdf-b6ab84ea125a.png" alt="image-20211002200638949" /></p>

<ul>
  <li>However, in a loser tree, you do not need to compare keys with the sibling.</li>
  <li>Instead, you can directly move to the parentand update the winner since the parent remembers the previous loser.</li>
  <li>A loser tree avoids accessing siblings during replays, which makes it slightly more efficient than winner trees.</li>
</ul>

