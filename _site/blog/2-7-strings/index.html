<h2 id="strings-chapter-27">Strings (Chapter 2.7)</h2>

<h3 id="271-adt-strings">2.7.1 ADT Strings</h3>

<script src="https://gist.github.com/underthelights/63bd8ae579587d167def274566c83519.js"></script>

<h3 id="272-strings-in-c---representation">2.7.2 Strings in C - Representation</h3>

<ul>
  <li>
    <p>In C, strings are represented as character arrays terminated with the null character.</p>
  </li>
  <li>
    <p>Example</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_SIZE 100
</span><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">"dog"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">t</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">"house"</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>Internal representation in C</li>
</ul>

<p><img width="338" alt="image-20211003143908910" src="https://user-images.githubusercontent.com/46957634/135751703-279339f6-c668-4478-876d-91980769d529.png" /></p>

<ul>
  <li>Alternative declaration
    <ul>
      <li>If the character array variable is initialized at the time of declaration, we do not need to specify the array size.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"dog"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">t</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"house"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">u</span><span class="p">[];</span>   <span class="c1">// compile error!</span>
</code></pre></div></div>

<ul>
  <li>
    <p>If no initialization is done, we need to specify the array size, or we get a compile error.</p>
  </li>
  <li>
    <p>Contenating two strings</p>
    <ul>
      <li>You can use strcat(s, t), which adds string t at the end of string s. The result is stored in s.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // need to include this in order to use string functions.
# define MAX_SIZE 100
</span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">"dog"</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">t</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="s">"house"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="ex013">[ex013]</h4>

<ul>
  <li>You should be careful when using functions such as strcat.</li>
  <li>What is the problem with the following code?
    <ul>
      <li>(For brevity, the following code does not show #include statements.)</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"dog"</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">t</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"house"</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">u</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"rainbow"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>How can you modify the code to remove the problem?
    <ul>
      <li>Try using dynamic memory allocation to allocate just enough amount of memory.</li>
      <li>Beware that a string has a null character at the end.</li>
    </ul>
  </li>
</ul>

<h4 id="string-insertion">String insertion</h4>

<ul>
  <li>
    <p>Suppose we want to implement a function that inserts a string in between another string.</p>

    <p><img width="338" alt="image-20211003144036070" src="https://user-images.githubusercontent.com/46957634/135751705-ec15156c-1232-403b-aebd-da3777c821df.png" /></p>
  </li>
  <li>
    <p>We want to insert t to s at the position after ‘a’, so that the resulting string is “automobile”.</p>
  </li>
  <li>
    <p>Function prototype</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* insert string t into string s at position i*/</span>
<span class="kt">void</span> <span class="nf">strnins</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="string-insertion-design">String insertion: design</h5>

<ul>
  <li>We will use a temp string, and library functions such as strncpy and strcat to implement this function</li>
  <li>strncpy(temp, s, i): copy i bytes from string s to string temp.</li>
</ul>

<p><img width="395" alt="image-20211003144145691" src="https://user-images.githubusercontent.com/46957634/135751707-e91b1217-88b6-4c50-a821-79c884735025.png" /></p>

<h4 id="ex014">[ex014]</h4>

<ul>
  <li>This function implementation has a potential problem. Can you identify the problem and fix it?</li>
</ul>

<script src="https://gist.github.com/underthelights/338f492772c96d4f56c462e0825cdf01.js"></script>

<h4 id="ex015">[ex015]</h4>

<ul>
  <li>
    <p>In the problem of pattern matching, we check whether a string pattern appear inside a string.</p>

    <ul>
      <li>Does the pattern “ello” exist in the string “hello, world!”? YES</li>
      <li>Does the pattern “abab” exist in the string “abbabba”? NO</li>
    </ul>
  </li>
  <li>
    <p>A library function strstr implements this operation.</p>

    <ul>
      <li>t = strstr(string, pat)</li>
      <li>if pat is not in string, a null pointer is returned.</li>
      <li>if pat is in the string, a pointer to the start of pat in string is returned.</li>
    </ul>
  </li>
</ul>

<h3 id="273-pattern-matching">2.7.3 Pattern Matching</h3>

<ul>
  <li>
    <p>Let us assume there was not strstr function provided by the library, and we need to make our own function.</p>
  </li>
  <li>
    <p>A simple matching algorithm</p>

    <ul>
      <li>At each position i of string, check if pat is equal to string[i] ~ string[i+strlen(pat)-1]</li>
      <li>strlen: a library function that returns number of characters in the given string.</li>
    </ul>
  </li>
  <li>
    <p>In the worst case, which is when pat is not in string, the algorithm will have a time complexity of O(nm), where n is the length of pat and m is the length of string.</p>
  </li>
  <li>
    <p>Slight improvements</p>

    <ul>
      <li>
        <p>Quitting when strlen(pat) is greater than the number of remaining characters in the string.</p>
      </li>
      <li>
        <p>Checking the first and last characters of pat before checking the remaining characters.</p>
      </li>
    </ul>
  </li>
</ul>

<p><img width="395" alt="image-20211003144337055" src="https://user-images.githubusercontent.com/46957634/135751708-4473cd0d-f95c-4302-a98f-25f2f675519d.png" /></p>

<h4 id="ex016">[ex016]</h4>

<script src="https://gist.github.com/underthelights/d99045420751a658299a3b16fc5a9490.js"></script>

<ul>
  <li>Analysis of function nfind
    <ul>
      <li>
        <p>For string = “aa…a” and pat = “aa…ab”, the computing time is $O(m)$.</p>
      </li>
      <li>
        <p>But for string = “aa…a” and pat = “aa…aba”, the computing time is still $O(nm)$.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="kmp-knuth-morris-pratt-algorithm">KMP (Knuth-Morris-Pratt) Algorithm</h3>

<ul>
  <li>
    <p>KMP algorithm: A better algorithm for finding a pattern in a string.</p>
  </li>
  <li>Idea: When a mismatch occurs, use our knowledge of the characters in the pattern and the position in the pattern where the mismatch occurred, to determine where we should continue the search.</li>
  <li>
    <p>We want to search the string for the pattern <strong>without moving backwards</strong> in the string.</p>
  </li>
  <li>Consider the following example.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String: A B C F A B C D A B F A B C D A B C D A B D E
Pattern: A B C D A B D
</code></pre></div></div>

<ul>
  <li>Before looking at the KMP algorithm, we will see how the “naive” algorithm finds the pattern in the string.
    <ul>
      <li>The “naive” algorithm is the one we’ve looked at.</li>
      <li>It has the time complexity of O(mn) where m is len(string) and n is len(pattern).</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String: A B C F A B C D A B F A B C D A B C D A B D E
Pattern: A B C D A B D
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="naive-algorithm">Naive algorithm</h4>

<ul>
  <li>It will start from the beginning of the string and iterate through the string, looking for the pattern. We will call this the outer iteration. (Blue arrow)</li>
  <li>For each starting position of string, it will iterate through the string and the pattern until there is a mismatch of a full match has been found. We will call this the inner iteration. (Green arrow)</li>
</ul>

<p><img width="410" alt="image-20211003141915378" src="https://user-images.githubusercontent.com/46957634/135751741-6ebae69f-593e-4e4a-a3fc-d16388caae39.png" /></p>

<ul>
  <li>The first inner iteration ends when a mismatch is found at the fourth character.</li>
</ul>

<p><img width="391" alt="image-20211003141934058" src="https://user-images.githubusercontent.com/46957634/135751742-fab567f2-948d-41f6-bed3-89d4ab811a75.png" /></p>

<ul>
  <li>Once the inner iteration ends, we move on to the next outer iteration.</li>
  <li>The inner iteration begins again.</li>
  <li>This time, the first character is a mismatch, so the inner iteration ends there.</li>
</ul>

<p><img width="402" alt="image-20211003141950876" src="https://user-images.githubusercontent.com/46957634/135751743-c96fcf44-f71f-4fb2-82e1-078139082e70.png" /></p>

<ul>
  <li>We move on to the next outer iteration… and so on.</li>
</ul>

<p><img width="402" alt="image-20211003142017765" src="https://user-images.githubusercontent.com/46957634/135751745-43005bac-974e-4bb6-9d69-6d1a4b4a85c8.png" /></p>

<ul>
  <li>When the starting position is the fifth character, the string matches the pattern until the last character, which is a mismatch.</li>
</ul>

<p><img width="402" alt="image-20211003142032488" src="https://user-images.githubusercontent.com/46957634/135751746-28bcc872-4c3d-43df-ab32-8ef78a890d3d.png" /></p>

<ul>
  <li>When the starting position is 15, we find a match. Then, the program terminates.</li>
  <li>We can see that in the worst case, we need to compare characters for:
    <ul>
      <li>number of outer iterations x number of inner iterations</li>
    </ul>
  </li>
</ul>

<p><img width="402" alt="image-20211003142102365" src="https://user-images.githubusercontent.com/46957634/135751748-7492651f-81b8-4c0e-bb7b-d13ae0d0264a.png" /></p>

<ul>
  <li>The following case shows an example of almost the worst case.
    <ul>
      <li>For each outer iteration, we need to compare 5 characters until we find a mismatch.</li>
      <li>Time complexity: $O(mn)$</li>
    </ul>
  </li>
</ul>

<p><img width="402" alt="image-20211003142125299" src="https://user-images.githubusercontent.com/46957634/135751750-0507b642-ccb7-462e-9f80-4d700d6b617b.png" /></p>

<h4 id="can-we-do-better">Can we do better?</h4>

<p><img width="402" alt="image-20211003142140561" src="https://user-images.githubusercontent.com/46957634/135751753-49e3bf1b-6a8b-4429-9aa2-7170baa858a6.png" /></p>

<ul>
  <li>Suppose we have done the first iteration.</li>
</ul>

<p><img width="402" alt="image-20211003142147609" src="https://user-images.githubusercontent.com/46957634/135751834-f1102e5f-cab2-4762-a96d-da0680d34a2a.png" /></p>

<ul>
  <li>Do we need to move the blue arrow just one position and restart search from there?</li>
</ul>

<p><img width="402" alt="image-20211003142202790" src="https://user-images.githubusercontent.com/46957634/135751836-3cebbe5a-6e03-4578-9ba5-1a78cab705bd.png" /></p>

<ul>
  <li>Can’t we just move to the position where the mismatch occurred?</li>
</ul>

<p><img width="402" alt="image-20211003142214668" src="https://user-images.githubusercontent.com/46957634/135751838-592961a6-272e-4845-832c-42f1b4cd41c5.png" /></p>

<ul>
  <li>In this case, moving to the fourth position is possible. Why?</li>
  <li>
    <p>It is because the starting character ‘A’ does not appear in the pattern (‘ABC’) after the first character.</p>
  </li>
  <li>Let’s look at the next case where the search begins at position 5 of the string. There was a mismatch at the last character of the pattern.</li>
</ul>

<p><img width="402" alt="image-20211003142305793" src="https://user-images.githubusercontent.com/46957634/135751839-bc234e32-cd68-46f5-aa51-17772e9b3522.png" /></p>

<ul>
  <li>In this case, can we skip the characters and move to the position where mismatch has occurred?</li>
</ul>

<p><img width="402" alt="image-20211003142316117" src="https://user-images.githubusercontent.com/46957634/135751842-88f945ec-dbf5-45b3-84d2-9c3c61517d4e.png" /></p>

<ul>
  <li>No! we must consider the possibility that there is a pattern match that starts from position 9, because the character at position 9 is an ‘A’.</li>
</ul>

<p><img width="402" alt="image-20211003142329938" src="https://user-images.githubusercontent.com/46957634/135751844-fdf54f5e-e738-4222-80fd-f2e9a04d3028.png" /></p>

<ul>
  <li>No! we must consider the possibility that there is a pattern match that starts from position 9, because the character at position 9 is an ‘A’.</li>
</ul>

<p><img width="402" alt="image-20211003142336752" src="https://user-images.githubusercontent.com/46957634/135751845-b825a5d4-33ae-4bca-9329-f832dd73c8e5.png" /></p>

<ul>
  <li>But that means we are moving the pointer backwards, and we don’t want to do this!</li>
  <li>
    <p>Can we avoid moving the green arrow backwards?</p>
  </li>
  <li>Suppose we know that if we start searching from position 9, the first two characters match the pattern.</li>
  <li>Then, we do not need to compare these two characters, and we can start from the position where the green arrow was already at!</li>
</ul>

<p><img width="402" alt="image-20211003142401145" src="https://user-images.githubusercontent.com/46957634/135751848-6c90e0a6-f3d4-4c67-bc69-c625b6b07911.png" /></p>

<ul>
  <li>So how do we know that if we start searching from a certain position, the first few characters already match the pattern?</li>
  <li>Let’s look at the pattern.</li>
</ul>

<p><img src="/Users/kyuhwanshim/Library/Application Support/typora-user-images/image-20211003142418081.png" alt="image-20211003142418081" /></p>

<ul>
  <li>In the previous iteration, suppose we had a match in the first three characters, and the fourth character was a mismatch.</li>
</ul>

<p><img src="/Users/kyuhwanshim/Library/Application Support/typora-user-images/image-20211003142425846.png" alt="image-20211003142425846" /></p>

<ul>
  <li>
    <p>Then, we know that we can just move three places for the next outer iteration, because the <strong>first part of the pattern is not repeated in the searched pattern</strong>.</p>
  </li>
  <li>
    <p>Now, suppose we had a match in the first six characters, and the seventh character was a mismatch.</p>
  </li>
</ul>

<p><img src="/Users/kyuhwanshim/Library/Application Support/typora-user-images/image-20211003142449251.png" alt="image-20211003142449251" /></p>

<ul>
  <li>Then, we know that the last two letters are the first part of the pattern.
    <ul>
      <li>We say the prefix two letters and the suffix two letters match.</li>
    </ul>
  </li>
</ul>

<p><img src="/Users/kyuhwanshim/Library/Application Support/typora-user-images/image-20211003142515534.png" alt="image-20211003142515534" /></p>

<ul>
  <li>
    <p>In this case, the search should start from the character A, but we do not need to compare the first two characters because they are already a match.</p>
  </li>
  <li>We can find out where to begin the next search and how many characters are already matched by analyzing the pattern itself.</li>
  <li>We calculate what we call a “failure function” or a “partial match function” which is basically a number of each index of the pattern. We will denote this index as T[ ].</li>
  <li>The value of the first index is -1. This means that when the search finds a match up to this letter, there is no partial match to be considered in the next iteration.</li>
</ul>

<p><img width="251" alt="image-20211003142418081" src="https://user-images.githubusercontent.com/46957634/135751867-daf4765a-c544-4449-bc2b-7cdd9ef14da1.png" /></p>

<ul>
  <li>We start an iteration from j=1 to j&lt;n. n is the number of letters in the pattern.</li>
  <li>When j=1,wesetitoT[j-1]whichis-1.</li>
  <li>This means that the previous position was not a part of a suffix that matches the prefix of the pattern.</li>
  <li>In this case, all is left is to see whether this character matches the start of the pattern. Since the character is not ‘A’, then T[1] is set to -1.</li>
  <li>We compare pat[j] and pat[i+1], and if they are the same character we set T[j] = i+1. Otherwise T[j] = -1.</li>
</ul>

<p><img width="386" alt="image-20211003142743476" src="https://user-images.githubusercontent.com/46957634/135751899-77d7eb3e-635d-47d3-893f-9cd9d93b7c30.png" /></p>

<ul>
  <li>T[2] also becomes -1 based on the same logic.</li>
</ul>

<p><img width="386" alt="image-20211003142735753" src="https://user-images.githubusercontent.com/46957634/135751931-d7a6b430-f4ad-419b-9050-78311b56a65b.png" /></p>

<ul>
  <li>T[3] also becomes -1 based on the same logic.</li>
</ul>

<p><img width="386" alt="image-20211003142757242" src="https://user-images.githubusercontent.com/46957634/135751938-421ca511-e118-43f4-b52e-2b69c506cb51.png" /></p>

<ul>
  <li>Now for T[4], i is also set to -1 because T[3] = -1.</li>
  <li>However, since pat[j] == pat[i+1], we set T[j] = i+1. Thus T[4] becomes 0.</li>
  <li>We can think of this 0 as: “the suffix matches the prefix up to index 0”.</li>
</ul>

<p><img width="386" alt="image-20211003142810253" src="https://user-images.githubusercontent.com/46957634/135751943-eeb12560-a27f-4f54-ba34-a5a759097019.png" /></p>

<ul>
  <li>
    <p>Now we go to j=5 which is’B’.</p>
  </li>
  <li>In this case, i = T[4] = 0, which means before this character there is a suffix that matches the prefix up to index 0.</li>
  <li>So we check if current letter matches index 1. In this case, it does!</li>
  <li>Since pat[j] == pat[i+1], we set T[5] to be i+1 which is 1.</li>
</ul>

<p><img width="386" alt="image-20211003143002475" src="https://user-images.githubusercontent.com/46957634/135751948-a2bb292e-cb68-4944-887a-e15af8cbc33e.png" /></p>

<ul>
  <li>Now we go to j=6 which is ‘D’.</li>
  <li>In this case, i = T[5] = 1, which means before this character there is a suffix that matches the prefix up to index 1.</li>
  <li>So we check if current letter matches index 2. In this case, it does not.</li>
  <li>Then, we update i to be T[i]. This is basically looking for a previous ‘AB’ sequence. Updating i is done repeatedly using a while loop.</li>
  <li>Since T[1] = -1, i becomes -1.</li>
  <li>Then, we check whether pat[j] == pat[i+1]. Since they are not equal, T[6] becomes -1.</li>
</ul>

<p><img width="386" alt="image-20211003143053815" src="https://user-images.githubusercontent.com/46957634/135751954-df28ebd1-75d4-472e-b8a1-7a656b56ebfc.png" /></p>

<ul>
  <li>Now we have the failure function for the pattern.</li>
  <li>We will use this information to do pattern matching.</li>
</ul>

<p><img width="399" alt="image-20211003143119077" src="https://user-images.githubusercontent.com/46957634/135751962-9e764ced-6321-4f71-8c18-6ce15c578a7d.png" /></p>

<ul>
  <li>In the first iteration, a mismatch occurs at the fourth character (index 3).</li>
</ul>

<p><img width="399" alt="image-20211003143133856" src="https://user-images.githubusercontent.com/46957634/135751964-283caf38-e39d-4ea9-b08d-0ffb7f6c7a58.png" /></p>

<ul>
  <li>Then, we just move the blue arrow to index 3. (blue moves along with green.)</li>
  <li>The green arrow will be set to T[j-1] + 1. In this case, it is 0.</li>
</ul>

<p><img width="399" alt="image-20211003143258371" src="https://user-images.githubusercontent.com/46957634/135751970-11e34469-dcc4-4a5f-b807-fb955f2e0cf4.png" /></p>

<ul>
  <li>In the following iteration, since the first characters do not match (‘F’ ≠ ‘A’), we just move the blue arrow one position.</li>
</ul>

<p><img width="399" alt="image-20211003143316522" src="https://user-images.githubusercontent.com/46957634/135751974-28bd5cfd-8cc2-4327-8740-85450d9e8fff.png" /></p>

<ul>
  <li>In the next iteration, the mismatch occurs at the last character.</li>
</ul>

<p><img width="399" alt="image-20211003143328961" src="https://user-images.githubusercontent.com/46957634/135751982-67eac9d1-3c05-43f7-889a-1a1a2572b0ba.png" /></p>

<ul>
  <li>In this case, T[j-1] = 1. Thus, i becomes 10 and j becomes 2.</li>
</ul>

<p><img width="399" alt="image-20211003143342749" src="https://user-images.githubusercontent.com/46957634/135751985-c04b6553-43dd-4c21-bdb0-3560ff9bcb87.png" /></p>

<ul>
  <li>We continue, until the string ends or we find a match.</li>
  <li>We know we have found a match if j = strlen(pattern).</li>
</ul>

<p><img width="420" alt="image-20211003143402296" src="https://user-images.githubusercontent.com/46957634/135751990-5d488e38-26bd-4f88-9e76-71c2afb6dbda.png" /></p>

<h4 id="program-214-ex017">Program 2.14 [ex017]</h4>

<ul>
  <li>We need to run function “fail” first in order to obtain failure[].</li>
</ul>

<script src="https://gist.github.com/underthelights/d9057aca4d051dc3c6eca65b63b1266e.js"></script>

<ul>
  <li>Time complexity of running pmatch: O(m), m: strlen(string).
    <ul>
      <li>Inside the while loop, i is always incremented and does not go back.</li>
      <li>The function ends when i reaches strlen(string).</li>
    </ul>
  </li>
</ul>

<h4 id="program-215">Program 2.15</h4>

<script src="https://gist.github.com/underthelights/77acd18bddebfb5718cd754b70974aaf.js"></script>

<ul>
  <li>Time complexity of running fail: O(n), n: strlen(pattern).
    <ul>
      <li>The for loop is iterated n-1 times, and j is never incremented inside the loop.</li>
      <li>In each iteration of the while loop, the value of i decreases.</li>
      <li>The variable i is reset at the beginning of each iteration of the for loop.</li>
      <li>i is either reset to -1, or it is reset to a value 1 greater than its terminal value on the previous iteration.</li>
      <li>Since the for loop is iterated only n-1 times, the value of i has a total increment of at most n-1.</li>
      <li>Hence, it cannot be decremented more than n-1 times.</li>
      <li>Consequently, the while loop is iterated at most n-1 times over the whole algorithm.</li>
    </ul>
  </li>
  <li>Time complexity for running the KMP algorithm
    <ul>
      <li>Time for calling fail(): O(n)</li>
      <li>Time for calling pmatch(): O(m)</li>
      <li>Thus, the total time complexity is O(m+n). It is much smaller than O(mn).</li>
    </ul>
  </li>
</ul>

<h3 id="try-it-yourself">Try-It-Yourself</h3>

<ul>
  <li>Try building up the failure function (T) for the following pattern.</li>
</ul>

<pre><code class="language-pseudocode">Pattern: A  B  A  A  B  A  B  A  A  A  B  A
</code></pre>
