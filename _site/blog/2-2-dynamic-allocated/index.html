<h2 id="dynamically-allocated-arrays-chapter-22">Dynamically Allocated Arrays (Chapter 2.2)</h2>

<h3 id="221-one-dimensional-arrays">2.2.1 One-dimensional arrays</h3>

<ul>
  <li>Suppose the size of array is not determined at the time of programming.</li>
  <li>This is how we would typically write the program.</li>
</ul>

<script src="https://gist.github.com/underthelights/5bcf32917f1968c0c5504e2775374217.js"></script>

<ul>
  <li>This program has the following drawbacks
    <ul>
      <li>If the number of integers is smaller than 100, we are wasting memory.</li>
      <li>If the number of integers is larger than 100, then the program will stop abruptly (bad), or behave unexpectedly (worse).</li>
    </ul>
  </li>
  <li>A good solution to this problem is to defer memory allocation to run time, when we have a good estimate of the required array size.</li>
</ul>

<script src="https://gist.github.com/underthelights/078b98f55f9a6685845640e2e3f1fc05.js"></script>

<ul>
  <li>void* malloc(size_t size)
    <ul>
      <li>allocates a block of size bytes of memory, returning a pointer to the beginning of the block.</li>
    </ul>
  </li>
  <li>When you are done using the memory space, you should return the allocated memory using free.</li>
</ul>

<h3 id="one-dimensional-arrays-ex004">One-dimensional arrays [ex004]</h3>
<ul>
  <li>If you need to change the size of array after allocation, you can use the function realloc to do so.</li>
</ul>

<script src="https://gist.github.com/underthelights/bfc30d7b1cb438b9ab828ac2089a29e1.js"></script>

<ul>
  <li>If additional memory can be allocated without changing the address, it is done so.</li>
  <li>If it is not possible, then memory is allocated at some other place, and the data is copied from the original memory space to the new memory space.</li>
</ul>

<h3 id="222-two-dimensional-arrays">2.2.2 Two-dimensional arrays</h3>
<ul>
  <li>
    <p>A 2D array is represented as a 1D array in which each element is a 1D array.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span>
</code></pre></div>    </div>

    <p><img width="241" alt="image-20211002232316248" src="https://user-images.githubusercontent.com/46957634/135751484-c82578df-a7ab-4911-9a38-d2cf121e8d26.png" /></p>
  </li>
  <li>
    <p>A 3D array is represented as a 1D array in which each element is a 2D array.</p>
  </li>
</ul>

<h3 id="program-23-ex005">Program 2.3 [ex005]</h3>

<script src="https://gist.github.com/underthelights/c967991ea52bf33c9d143dd54cda3362.js"></script>

<ul>
  <li>You can use calloc instead of malloc.</li>
  <li>void* calloc(size_t num, size_t size)
    <ul>
      <li>allocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits to zero.</li>
    </ul>
  </li>
  <li>You should also free the allocated memory after use.</li>
</ul>
