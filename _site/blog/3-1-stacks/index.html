<h2 id="stacks-chapter-31">Stacks (Chapter 3.1)</h2>

<h3 id="definition-of-stack">Definition of Stack</h3>

<ul>
  <li>Stack is a specialized type of an ordered list.</li>
  <li>One end is called top.</li>
  <li>The other end is called bottom.</li>
  <li>Additions to and removals from the top end only.</li>
</ul>

<p><img width="225" alt="image-20211003151005422" src="https://user-images.githubusercontent.com/46957634/135750339-7a5715b4-f4a0-4cd5-ac32-da04182a0ffd.png" /></p>

<h3 id="analogy">Analogy</h3>

<ul>
  <li>A stack of cups
    <ul>
      <li>We can only put (add) a cup to the top of the stack</li>
      <li>We can only remove the cup on the top of the stack</li>
      <li>This type of behavior is called Last-In-First-Out (LIFO)
        <ul>
          <li>The last cup inserted to the stack is removed first.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img width="366" alt="image-20211003151138083" src="https://user-images.githubusercontent.com/46957634/135750389-5998d677-5b17-4a22-918f-50bfe8c7aa63.png" /></p>

<h3 id="stack-lifo-behavior">Stack: LIFO behavior</h3>

<ul>
  <li>Inserting to the stack is called “push”.</li>
  <li>Removing from the stack is called “pop”.</li>
</ul>

<p><img width="366" alt="image-20211003151151863" src="https://user-images.githubusercontent.com/46957634/135750409-243d8008-052e-4f35-982f-86bd94f11421.png" /></p>

<h3 id="stack-example-usage">Stack: Example Usage</h3>

<ul>
  <li>Function call stack:
    <ul>
      <li>when a function is called in a program, the function data is inserted into the call stack. When the function returns, the function data is removed from the stack.</li>
    </ul>
  </li>
</ul>

<p><img width="381" alt="image-20211003151218932" src="https://user-images.githubusercontent.com/46957634/135750418-9c1457e7-2d47-484c-a09e-2b073f3b47fd.png" /></p>

<h3 id="stack-abstract-data-type">Stack: Abstract Data Type</h3>

<script src="https://gist.github.com/underthelights/66044e762cd2c16f493d60d5d5785e0d.js"></script>

<h3 id="ordered-lists">Ordered Lists</h3>

<ul>
  <li>
    <p>One of the simplest abstract data types.</p>
  </li>
  <li>
    <p>Object: list of items (of the same type) that have a certain order</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">item3</span><span class="p">,</span> <span class="p">...,</span> <span class="n">itemn</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Functions
    <ul>
      <li>Finding the length, reading an item from the list, retrieving an item from the list, replacing an item in the list, inserting a new item to the list, deleting an item from the list, etc.</li>
    </ul>
  </li>
  <li>
    <p>Chronologically ordered list</p>

    <ul>
      <li>
        <p>In a chronologically ordered list, elements are ordered according to time.</p>
      </li>
      <li>
        <p>Examples: round robin, stack, queue</p>
      </li>
      <li>Stack: elements are in reverse chronological order
        <ul>
          <li>The first element deleted is the last element (top) in the stack</li>
          <li>The last element deleted is the first element (bottom) in the stack</li>
        </ul>
      </li>
      <li>Stack is a special type of an ordered list with restricted operations.
        <ul>
          <li>Can only access the item at the top.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="implementation-of-a-stack">Implementation of a stack</h3>

<ul>
  <li>We can implement a stack using a one-dimensional array.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_STACK_SIZE 100 </span><span class="cm">/* maximum stack size */</span><span class="cp">
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
  <span class="cm">/* other fields if necessary */</span>
<span class="p">}</span> <span class="n">element</span><span class="p">;</span>
<span class="n">element</span> <span class="n">stack</span><span class="p">[</span><span class="n">MAX_STACK_SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* if top is -1, it means the stack is empty */</span>
</code></pre></div></div>

<h3 id="implementing-push-and-pop-ex018">Implementing push and pop [ex018]</h3>

<ul>
  <li>
    <p>push: insert an element to the stack</p>

    <script src="https://gist.github.com/underthelights/6ad024c0e827bfce7ee36342f6a95f37.js"></script>
  </li>
  <li>
    <p>pop: delete and return an element from the stack</p>

    <script src="https://gist.github.com/underthelights/f5300df95bc08afe02807fe537231d18.js"></script>
  </li>
</ul>

<h3 id="example-tower-of-hanoi">Example: Tower of Hanoi</h3>

<ul>
  <li>64 gold disks to be moved from tower A to tower C</li>
  <li>Each tower operates as a stack</li>
  <li>Cannot place a bigger disk on top of a smaller one</li>
</ul>

<p><img width="373" alt="image-20211003151432027" src="https://user-images.githubusercontent.com/46957634/135750440-2292a8a0-5bea-4ec9-98bf-7219ac80a584.png" /></p>

<ul>
  <li>Simple case: let us assume we only have 3 disks to move from A to C.</li>
</ul>

<p><img width="373" alt="image-20211003151543035" src="https://user-images.githubusercontent.com/46957634/135750429-229f9d88-259e-42a5-b72b-74d44f112dda.png" /></p>

<ul>
  <li>Step 1: move disk 3 to C.</li>
</ul>

<p><img width="373" alt="image-20211003151549893" src="https://user-images.githubusercontent.com/46957634/135750445-36e4045c-4cfb-4153-80ac-c7c77350c3a1.png" /></p>

<ul>
  <li>Step 2: move disk 2 to B.</li>
</ul>

<p><img width="373" alt="image-20211003151556363" src="https://user-images.githubusercontent.com/46957634/135750454-b3b23088-de4a-4eda-95a5-885ce232182c.png" /></p>

<ul>
  <li>Step 3: move disk 3 to B.</li>
</ul>

<p><img width="373" alt="image-20211003151604814" src="https://user-images.githubusercontent.com/46957634/135750463-5d0ba02d-2bba-4f10-baf3-d328df52daf6.png" /></p>

<ul>
  <li>Step 4: move disk 1 to C.</li>
</ul>

<p><img width="373" alt="image-20211003151610447" src="https://user-images.githubusercontent.com/46957634/135750468-d8032a21-2f6e-4f99-8c62-954154bc52b1.png" /></p>

<ul>
  <li>Step 5: move disk 3 to A.</li>
</ul>

<p><img width="373" alt="image-20211003151618523" src="https://user-images.githubusercontent.com/46957634/135750471-2dfeffb9-7fc3-4781-808b-86484a6afea1.png" /></p>

<ul>
  <li>Step 6: move disk 2 to C.</li>
</ul>

<p><img width="373" alt="image-20211003151624739" src="https://user-images.githubusercontent.com/46957634/135750478-f54f7c9a-0034-4b0c-bb21-eb675116d439.png" /></p>

<ul>
  <li>Step 7: move disk 3 to C. Done. Total 7 disk moves required.</li>
</ul>

<p><img width="373" alt="image-20211003151635900" src="https://user-images.githubusercontent.com/46957634/135750488-b65f807d-9955-49dc-a047-e47694ce3e24.png" /></p>

<ul>
  <li>General case: moving n disks from A to C (using B).</li>
</ul>

<p><img width="373" alt="image-20211003151643592" src="https://user-images.githubusercontent.com/46957634/135750494-55362405-95f1-44ce-a6a0-531cb51e5593.png" /></p>

<ul>
  <li>First, move the top n-1 disks from A to B (using C).</li>
</ul>

<p><img width="373" alt="image-20211003151650239" src="https://user-images.githubusercontent.com/46957634/135750500-6b8502a6-bd88-47eb-8d10-48dd0d5c6549.png" /></p>

<ul>
  <li>Then, move disk 1 to C.</li>
</ul>

<p><img width="373" alt="image-20211003151705173" src="https://user-images.githubusercontent.com/46957634/135750501-17c3f71b-1648-49f8-8a4a-4203c04dbb54.png" /></p>

<ul>
  <li>Then, move the top n-1 disks to C. Done.</li>
</ul>

<p><img width="373" alt="image-20211003151719289" src="https://user-images.githubusercontent.com/46957634/135750516-3240ded0-9f65-461b-84f1-40662c4bf0cb.png" /></p>

<ul>
  <li>A recursive solution: Moving n disks from A to C
    <ul>
      <li>Move top n-1 disks to B</li>
      <li>Move disk 1(thebiggest disk) to C</li>
      <li>Move top n-1 disks to C</li>
    </ul>
  </li>
  <li>
    <p>Using the recursive solution, we are converting the problem with input size n to a problem with input size n-1.</p>
  </li>
  <li>What is the number of moves required to move n disks to C?
    <ul>
      <li>Let us denote T(n) to be the number of moves required to move n disks.</li>
    </ul>
  </li>
  <li>Steps
    <ul>
      <li>Move top n-1 disks to B → T(n-1)</li>
      <li>Move disk 1 to C→1</li>
      <li>Move top n-1disks to C→T(n-1)</li>
    </ul>
  </li>
  <li>
    <p>$T(n)=2xT(n-1)+1$</p>
  </li>
  <li>
    <p>$T(n)=2n-1$</p>
  </li>
  <li>How many times do we need to move disks to move 64 disks from one tower to another?
    <ul>
      <li>T(64) = 264 - 1 = 1.8 * 1019 (approximately)</li>
    </ul>
  </li>
  <li>
    <p>If a computer performs 109 moves/second, it would take about 570 years to complete this task.</p>
  </li>
  <li>If a monk moves 1 disk per minute, it will take him about 3.4 * 1013 years.</li>
</ul>

<h3 id="example-rat-in-a-maze">Example: Rat in a Maze</h3>

<ul>
  <li>
    <p>A rat enters a maze and needs to find its way to the exit.</p>

    <ul>
      <li>
        <p>The rat cannot step on the blue blocks.</p>
      </li>
      <li>
        <p>The rat can move in four directions: up, down, left, right</p>
      </li>
    </ul>
  </li>
  <li>
    <p>How can we program so that the rat will eventually find the exit if there exists a path from entrance to exit?</p>
  </li>
  <li>
    <p>We can program the rat so that it has a rule for movement.</p>
    <ul>
      <li>The move order is right, down, left, up
        <ul>
          <li>If the rat can move right, it will. If not, it will try moving down, left, and then up.</li>
        </ul>
      </li>
      <li>If the rat has nowhere to move, it will backtrack its path until it can move again.
        <ul>
          <li>The rat should remember the blocks it went in the past to avoid revisiting.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img width="259" alt="image-20211003151917373" src="https://user-images.githubusercontent.com/46957634/135750525-9fc07c52-93d1-4182-8291-96c992ff436c.png" /></p>

<ul>
  <li>
    <p>Example run: the rat will move right as long as it can.</p>

    <p><img width="263" alt="image-20211003152009233" src="https://user-images.githubusercontent.com/46957634/135750527-9b809148-1b94-4fdb-ae77-6a7beec5f3ee.png" /></p>
  </li>
  <li>
    <p>Since the rat can move nowhere from there, it will backtrack until it can move again.</p>
  </li>
</ul>

<p><img width="263" alt="image-20211003152015064" src="https://user-images.githubusercontent.com/46957634/135750530-eb9b0ab2-2f6b-40dc-ba63-da18b725dddc.png" /></p>

<ul>
  <li>The rat moves down.</li>
</ul>

<p><img width="263" alt="image-20211003152022903" src="https://user-images.githubusercontent.com/46957634/135750531-a454f999-2a62-4a4e-833d-0b9a3da04553.png" /></p>

<ul>
  <li>The rat moves left.</li>
</ul>

<p><img width="263" alt="image-20211003152030020" src="https://user-images.githubusercontent.com/46957634/135750534-c04576bf-bfd6-4fe8-b5c6-a4be7ef09cc5.png" /></p>

<ul>
  <li>The rat moves down.</li>
</ul>

<p><img width="263" alt="image-20211003152036576" src="https://user-images.githubusercontent.com/46957634/135750535-922903cb-00d1-475e-b8b6-e1b2b27c47f3.png" /></p>

<ul>
  <li>The rat backtracks until it can move to a new block.</li>
</ul>

<p><img width="263" alt="image-20211003152042749" src="https://user-images.githubusercontent.com/46957634/135750537-a52b15e6-717f-4f98-91bb-1a97ca9d5a43.png" /></p>

<ul>
  <li>The rat backtracks until it can move to a new block.</li>
</ul>

<p><img width="263" alt="image-20211003152050590" src="https://user-images.githubusercontent.com/46957634/135750538-28386a50-9e38-44b7-b5b0-9789f56a4e46.png" /></p>

<ul>
  <li>The rat moves according to the order of movement and backtracks whenever it bumps into a dead end.</li>
</ul>

<p><img width="423" alt="image-20211003152103984" src="https://user-images.githubusercontent.com/46957634/135750579-7c7e054f-70c4-425f-92e8-b5025baebd84.png" /></p>

<ul>
  <li>The rat moves according to the order of movement and backtracks whenever it bumps into a dead end.</li>
</ul>

<p><img width="423" alt="image-20211003152116133" src="https://user-images.githubusercontent.com/46957634/135750582-440e97db-eafd-4fff-aed1-6ae810347c9d.png" /></p>

<ul>
  <li>The rat moves according to the order of movement and backtracks whenever it bumps into a dead end.</li>
</ul>

<p><img width="423" alt="image-20211003152126420" src="https://user-images.githubusercontent.com/46957634/135750584-17017acb-dff5-4a20-a504-681ccec8daf5.png" /></p>

<h4 id="programming---representation-of-a-maze">Programming - Representation of a maze</h4>

<ul>
  <li>Two-dimensional array in which 0’s represent the open paths and 1’s the barriers.</li>
  <li>
    <p>To avoid checking for the border conditions we can surround the maze by a border of 1’s. Then, an m x p maze will require an (m+2) x (p+2) array.</p>
  </li>
  <li>The entrance is at position[1][1] and the exit at [m][p]</li>
</ul>

<p><img width="423" alt="image-20211003152153718" src="https://user-images.githubusercontent.com/46957634/135750606-20cf3c22-359f-4cd1-9c58-e5c2a82f63fd.png" /></p>

<ul>
  <li>
    <p>In the previous example, the rat could move in four directions.</p>
  </li>
  <li>
    <p>This time we will let the rat move in eight directions</p>

    <ul>
      <li>N,NE,E,SE,S,SW,W,NW</li>
    </ul>

    <p><img width="367" alt="image-20211003152214646" src="https://user-images.githubusercontent.com/46957634/135750607-4694e449-6604-48e1-941b-e812a4942838.png" /></p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">vert</span><span class="p">;</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">horiz</span><span class="p">;</span>
<span class="p">}</span> <span class="n">offsets</span><span class="p">;</span>
<span class="n">offsets</span> <span class="n">move</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* array of moves for each direction */</span>
</code></pre></div></div>

<ul>
  <li>Table of moves</li>
</ul>

<p><img width="214" alt="image-20211003152233113" src="https://user-images.githubusercontent.com/46957634/135750609-9b82c8b2-6bbb-49ae-a452-b036697562e5.png" /></p>

<ul>
  <li>If we are at position maze[row][col], we can find the position after next move, maze[nextRow][nextCol], by setting
    <ul>
      <li>nextRow = row + move[dir].vert</li>
      <li>nextCol = col + move[dir].horiz</li>
    </ul>
  </li>
  <li>To record the maze positions already visited, we can maintain a second two- dimensional array.</li>
  <li>A stack is used to store the positions on the path from the entrance to the current position.</li>
</ul>

<h4 id="a-pseudocode-for-the-maze-program">A pseudocode for the maze program</h4>

<pre><code class="language-pseudocode">initialize a stack to the maze's entrance coordinates and direction to north; 

while (stack is not empty) {
	/* move to position at the top of stack */
	&lt;row,col,dir&gt; = delete from top of stack;
  while (there are more moves from current position) {
  	&lt;nextRow, nextCol&gt; = coordinates of next move;
    dir = direction of move;
    if ((nextRow==EXIT_ROW) &amp;&amp;(nextCol==EXIT_COL))
    	success;
    if ((maze[nextRow][nextCol]==0) &amp;&amp;(mark[nextRow][nextCol]==0)) {
    	/* legal move and haven't been there */ mark[nextRow][nextCol] = 1;
      /* save current position and direction */
      add &lt;row,col,dir&gt; to the top of the stack; 
      row = nextRow; 
      col = nextCol; 
      dir = north;
      } 
	}
}
printf("No path found");
</code></pre>

<ul>
  <li>Defining the stack for the program</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_STACK_SIZE 100
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">row</span><span class="p">;</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">col</span><span class="p">;</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>
<span class="p">}</span> <span class="n">element</span><span class="p">;</span>
<span class="n">element</span> <span class="n">stack</span><span class="p">[</span><span class="n">MAX_STACK_SIZE</span><span class="p">];</span>
</code></pre></div></div>

<ul>
  <li>Need to determine a reasonable bound for the stack size.</li>
</ul>

<p>[Figure 3.11] Simple maze with a long path</p>

<p><img width="65" alt="image-20211003152411739" src="https://user-images.githubusercontent.com/46957634/135750610-3574cb02-880c-4e53-a59b-c21faa15e40a.png" /></p>

<h4 id="ex019---maze-search-function">[ex019] - Maze search function</h4>

<ul>
  <li>we assume that arrays maze, mark, move, stack, and constants EXIT_ROW, EXIT_COL, TRUE, FALSE, and variable top are declared as global.</li>
</ul>

<script src="https://gist.github.com/underthelights/07a5ea8726ef3d958cd09c4f4e61a2b6.js"></script>

<h5 id="analysis-of-function-path">Analysis of function path</h5>

<ul>
  <li>Since each position within the maze is visited no more than once, the worse case time complexity of the algorithm is O(mp) where m and p are, respectively, the number of rows and columns of the maze.</li>
  <li>A position may be pushed and popped multiple times due to backtracking, but this number cannot exceed number of directions, which is 8 in this case.</li>
</ul>

