<h2 id="threaded-binary-trees-chapter-55">Threaded Binary Trees (Chapter 5.5)</h2>

<ul>
  <li>
    <p>A binary tree T with n nodes has 2n links</p>

    <ul>
      <li>
        <p>each node has 2 links</p>
      </li>
      <li><img width="169" alt="image-20211002211547254" src="https://user-images.githubusercontent.com/46957634/135757624-c3fe9b77-e8d7-49c1-9f7d-037ffe61afb9.png" /></li>
      <li>
        <p>Among them, (n+1) are NULL links</p>
      </li>
      <li>why?</li>
    </ul>
  </li>
  <li>
    <p>NULL links are wasted memory space</p>

    <p><img width="292" alt="image-20211002224350057" src="https://user-images.githubusercontent.com/46957634/135757639-5c0ae890-09e9-4b65-a1c5-dbd905a6df54.png" /></p>
  </li>
  <li>Utilizing the space that were originally NULL
    <ul>
      <li>Replace the NULL links by pointers, called threads, to other nodes in the tree by using the following rules</li>
    </ul>
  </li>
  <li>
    <p>Keep the leftmost and the rightmost NULL pointers as NULL</p>
  </li>
  <li>
    <p>Change all other NULL pointers as</p>

    <ul>
      <li>
        <p>Left pointer = inorder predecessor</p>
      </li>
      <li>
        <p>Right pointer = inorder successor</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="inorder-traversal">Inorder traversal</h3>

<p><img width="292" alt="image-20211002224427264" src="https://user-images.githubusercontent.com/46957634/135755226-cba2f047-ac6c-4afb-940b-e9ae09efdd10.png" /></p>

<ul>
  <li>
    <p>Keep the leftmost and the rightmost NULL pointers as NULL.</p>

    <p><img width="438" alt="image-20211002224444495" src="https://user-images.githubusercontent.com/46957634/135755220-c5680713-277b-4a4f-83c6-228ce4961179.png" /></p>
  </li>
  <li>Change all other NULL pointers as
    <ul>
      <li>
        <p>Left pointer = inorder predecessor</p>
      </li>
      <li>
        <p>Right pointer = inorder successor</p>
      </li>
      <li>
        <p>H D I B E A F C G J</p>

        <p><img width="438" alt="image-20211002224457436" src="https://user-images.githubusercontent.com/46957634/135755210-99525820-48ce-423c-a3a8-5bd594dba2af.png" /></p>
      </li>
    </ul>
  </li>
  <li>When we use threads, we must be able to distinguish between threads and normal pointers
    <ul>
      <li>Is “right_child” pointing to the actual right child or is it pointing to the next node in inorder traversal?</li>
    </ul>
  </li>
  <li>For this reason, we add two additional fields to the node.
    <ul>
      <li>Flags indicating whether the pointer is a thread or not.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">threaded_tree</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">left_thread</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">threaded_tree</span> <span class="o">*</span><span class="n">left_child</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">threaded_tree</span> <span class="o">*</span><span class="n">right_child</span><span class="p">;</span>
  <span class="kt">short</span> <span class="kt">int</span> <span class="n">right_thread</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Until now, we have replaced all NULL links to point to something.</p>
  </li>
  <li>
    <p>Two links are still NULL links: the leftmost and the rightmost link.</p>
  </li>
  <li>
    <p>In order to utilize these two links, we create a dummy node and use that as the root of the tree.</p>
  </li>
  <li>
    <p>The original root node now is the left child of the dummy root.</p>
  </li>
  <li>
    <p>Then, the leftmost and the rightmost link point to the dummy root node.</p>
  </li>
</ul>

<p><img width="330" alt="image-20211002224547681" src="https://user-images.githubusercontent.com/46957634/135757645-aeb07964-ae54-400d-99d8-8da473d7cc4e.png" /></p>

<h3 id="finding-the-inorder-successor-of-a-node">Finding the inorder successor of a node</h3>

<ul>
  <li>
    <p>Using the threads, we can perform an inorder traversal without making use of a stack.</p>
  </li>
  <li>
    <p>If ptr-&gt;right_thread = TRUE, the inorder successor of ptr is ptr-&gt;right_child.</p>
  </li>
  <li>
    <p>Else, we obtain the next node by following a path of left-child links from ptr-&gt;right_child until we reach a node with left_thread = TRUE.</p>

    <p><img width="330" alt="image-20211002224609230" src="https://user-images.githubusercontent.com/46957634/135757646-e112896f-ccda-427a-b673-47e48ebd2cf3.png" /></p>
  </li>
  <li>Inorder successor of node I?
    <ul>
      <li>Node I’s right_thread is TRUE. So node I’s inorder successor is node B.</li>
    </ul>
  </li>
  <li>Inorder successor of node B?
    <ul>
      <li>
        <p>Node B’s right_thread if FALSE.</p>
      </li>
      <li>The node that follows right_child of node B is node E. Node E’s left_thread is TRUE.</li>
      <li>So, node E is the inorder successor of node B.</li>
    </ul>
  </li>
  <li>Inorder successor of node A?
    <ul>
      <li>
        <p>Node A’s right_thread is FALSE.</p>
      </li>
      <li>The node that follows right_child of node A is node C.
Node C’s left_thread is FALSE.
The left_child of node C is node F.
Node F’s left_thread is TRUE.</li>
      <li>So, node F is the inorder successor of node A.</li>
    </ul>
  </li>
</ul>

<script src="https://gist.github.com/underthelights/c4adec92039d03c8335fd43c0a5ee0fc.js"></script>

<ul>
  <li>To perform an inorder traversal, we make repeated calls to insucc.</li>
</ul>

<script src="https://gist.github.com/underthelights/76c33314b60787dbd0eff13fe2189710.js"></script>

<h3 id="inserting-a-node-into-a-threaded-binary-tree">Inserting a node into a threaded binary tree</h3>

<ul>
  <li>
    <p>Assume that we have a node, parent, that has an empty right subtree.</p>
  </li>
  <li>
    <p>We wish to insert child as the right child of parent.</p>

    <p><img width="250" alt="image-20211002224748668" src="https://user-images.githubusercontent.com/46957634/135757648-bce5dea6-5fc3-4f4c-8b0c-a93e69f47065.png" /></p>
  </li>
  <li>To do this, we must:
    <ul>
      <li>change <code class="language-plaintext highlighter-rouge">parent-&gt;right_thread</code> to FALSE.</li>
      <li>set <code class="language-plaintext highlighter-rouge">child-&gt;left_thread</code> and child-&gt;right_thread to TRUE.</li>
      <li>
        <p>set child-&gt;left_child to point to parent.</p>
      </li>
      <li>
        <p>set child-&gt;right_child to point to parent-&gt;right_child.</p>
      </li>
      <li>change parent-&gt;right_child to point to child.</li>
    </ul>
  </li>
  <li>
    <p>Assume that we have a node, parent, that has an nonempty right subtree.</p>
  </li>
  <li>
    <p>We wish to insert child as the right child of parent.</p>
  </li>
  <li>
    <p>In this case, the child becomes the inorder predecessor of a node that has a left_thread == TRUE, and thus the thread of that node needs to be updated.</p>

    <ul>
      <li>
        <p>This node was previously the inorder successor of parent.</p>

        <p><img width="284" alt="image-20211002224815430" src="https://user-images.githubusercontent.com/46957634/135757649-7685de78-8246-4eee-9da1-56f2a7488216.png" /></p>
      </li>
    </ul>
  </li>
  <li>The code that handles both cases</li>
</ul>

<script src="https://gist.github.com/underthelights/23334d5fa8ba389f097925984c9aed99.js"></script>

