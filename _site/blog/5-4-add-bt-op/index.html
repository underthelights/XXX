<h2 id="additional-binary-tree-operations-chapter-54">Additional Binary Tree Operations (Chapter 5.4)</h2>

<h3 id="541-copying-binary-trees">5.4.1 Copying Binary Trees</h3>

<ul>
  <li>The function for copying a binary tree can be obtained by slightly modifying the function for postorder traversal.</li>
</ul>

<script src="https://gist.github.com/underthelights/35b55756d4307cfa7cecb6fc66ca947f.js"></script>

<h3 id="542-testing-for-equality-of-binary-trees">5.4.2 Testing For Equality of Binary Trees</h3>

<ul>
  <li>A function for testing whether two binary trees are equal can be obtained by modifying the function for preorder traversal.</li>
</ul>

<script src="https://gist.github.com/underthelights/e6f6b6bd5048d29740008da23c45a344.js"></script>

<h3 id="543-the-satisfiability-problem">5.4.3 The Satisfiability Problem</h3>

<ul>
  <li>
    <p>Consider the formulas constructed by taking variables, $x1, x2, …, xn$ and operators $∧$ (and), $∨$ (or), and $￢$ (not).</p>
  </li>
  <li>
    <p>The variables can hold only one of two possible values, true or false.</p>
  </li>
  <li>
    <p>The expressions are defined by the following rules:</p>

    <ul>
      <li>
        <p>A variable is an expression.</p>
      </li>
      <li>
        <p>If x and y are expressions, then $￢x, x∧y, x∨y$ are expressions.</p>
      </li>
      <li>
        <p>Parentheses can be used to alter the normal order of evaluation, which is ￢ before ∧ before ∨.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>The algorithm that solves the satisfiability problem</p>

    <ul>
      <li>
        <p>Try all possible combinations</p>
      </li>
      <li>
        <p>For example, if we have three variables $(x_1, x_2, x_3)$, we should try:</p>
      </li>
    </ul>

    <p>$(T,T,T), (T,T,F), (T,F,T), (T,F,F), (F,T,T), (F,T,F), (F,F,T), (F,F,F)$</p>

    <ul>
      <li>
        <p>Time required to execute the program:</p>

        <ul>
          <li>g: time needed to substitutue values for variables and evaluate the expression.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<pre><code class="language-pseudocode">for (all 2n possible combinations) { 
	generate the next combination;
	replace the variables by their values;
	evaluate the expression;
  
  if (its value is true) {
    printf(&lt;combination&gt;);
    return;
	} 
}
printf("no satisfiable combination\n");
</code></pre>

<ul>
  <li>
    <p>Evaluating an expression</p>

    <ul>
      <li>Represent the expression as a binary tree.</li>
    </ul>

    <p><img width="413" alt="image-20211002211334509" src="https://user-images.githubusercontent.com/46957634/135752853-7d8a6b1f-094a-41a3-9300-85872b39726c.png" /></p>
  </li>
  <li>
    <p>Traverse the tree in postorder, evaluating the subtrees until the entire expression is reduced to a single value.</p>
  </li>
  <li>
    <p>This corresponds to the postfix evaluation of an arithmetic expression.</p>
  </li>
  <li>
    <p>Evaluating an expression</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>left_child</th>
      <th>data</th>
      <th>value</th>
      <th>right_child</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Evaluating an expression</li>
</ul>

<script src="https://gist.github.com/underthelights/46417fa75f4803f372600d38aebc7af5.js"></script>

<h4 id="exercise-ex037">Exercise [ex037]</h4>

<ul>
  <li>
    <p>We would like to write a function which builds a tree from an expression.</p>
  </li>
  <li>You will first need to convert the infix notation to a postfix notation, before generating the tree.
    <ul>
      <li>For converting infix notation to postfix notation, refer to [ex023] in lecture 09.</li>
    </ul>
  </li>
  <li>
    <p>For the ‘NOT’ operator which takes only one operand, we will decide to put the operand as the right child of the operator. (Just like in the figure below.)</p>
  </li>
  <li>
    <p>For convenience when we write the program:</p>

    <ul>
      <li>
        <p>use a, b, c instead of x1, x2, x3.</p>
      </li>
      <li>
        <p>use &amp; instead of ∧</p>
      </li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>use</td>
              <td>instead of ∨</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>use ~ instead of ㄱ</li>
    </ul>

    <table>
      <tbody>
        <tr>
          <td><img width="413" alt="image-20211002211516177" src="https://user-images.githubusercontent.com/46957634/135752854-3869c5bb-9efb-4e0c-9e10-9693b312af03.png" />(a &amp; ~ b)</td>
          <td>(~a &amp; c)</td>
          <td>~c</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

