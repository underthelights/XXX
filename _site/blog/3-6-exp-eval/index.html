<h2 id="evaluation-of-expressions-chapter-36">Evaluation of Expressions (Chapter 3.6)</h2>

<h3 id="361-expressions">3.6.1 Expressions</h3>

<ul>
  <li>The representation and evaluation of expressions is of great interest to computer scientists.</li>
  <li>Example expressions
    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">((rear + 1 == front) || (( rear == MAX_QUEUE_SIZE-1) &amp;&amp; !front))</code></p>
      </li>
      <li>
        <p>$x=a/b–c+d<em>e–a</em>$</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Tokens in expressions</p>

    <ul>
      <li>operators (e.g. $=, /, -, +, *$)</li>
      <li>operands (e.g. $a, b, c, d, e, x$)</li>
      <li>parentheses</li>
    </ul>
  </li>
  <li>
    <p>Suppose we have the following statement.</p>

    <ul>
      <li>$x=a/b–c+d<em>e–a</em>c$</li>
    </ul>
  </li>
  <li>When a=4,b=2,c=2,d=3,and e=3,what is the value of x?
    <ul>
      <li>Which one is correct?
        <ul>
          <li>$((4/2)–2)+(3<em>3)–(4</em>2)=0+9–8=1$</li>
          <li>$(4/(2–2+3))<em>(3–4)</em>2=4/3<em>(-1)</em>2=-2.666…$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Within any programming language, there is a precedence hierarchy that <strong>determines the order</strong> in which we evaluate operators.</p>
  </li>
  <li>
    <p>Parentheses are used to override precedence, and the expresisons are always evaluated from the innermost parenthesized expression first.</p>
  </li>
  <li>
    <p>When two operators of the same precedence appear in an expression, they are evaluated according to the associativity.</p>
  </li>
  <li>
    <p>Precedence hierarchy for C</p>

    <p><img width="360" alt="image-20211003145952402" src="https://user-images.githubusercontent.com/46957634/135751281-32e563a0-f21e-425b-97cd-e6e1a64b72d1.png" /></p>

    <p><img width="360" alt="image-20211003150000791" src="https://user-images.githubusercontent.com/46957634/135751249-f9097fd8-0d72-44e5-b7b6-3a489547c78b.png" /></p>

    <p><img width="366" alt="image-20211003150017439" src="https://user-images.githubusercontent.com/46957634/135751251-e54a45ae-b43f-4321-b53f-f146afe2aa6d.png" />Different ways of writing expressions</p>
  </li>
  <li>
    <p>Infix notation: $a * b$</p>

    <ul>
      <li>(operator is placed between the operands)</li>
    </ul>
  </li>
  <li>
    <p>Prefix notation: $* a b$</p>

    <ul>
      <li>(operator is placed before the operands)</li>
    </ul>
  </li>
  <li>
    <p>Postfix notation: $a b *$</p>

    <ul>
      <li>(operator is placed after the operands)</li>
    </ul>
  </li>
  <li>
    <p>Prefix and Postfix notations are parenthesis-freenotations.</p>
  </li>
  <li>Although infix notation is the most common way of writing expressions, it is not the one used by compilers to evaluate expressions.</li>
  <li>
    <p>Compilers typically use postfix notation, which is a parenthesis-free notation.</p>

    <table>
      <thead>
        <tr>
          <th>Infix</th>
          <th>Postfix</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2+3*4</td>
          <td>234*+</td>
        </tr>
        <tr>
          <td>a*b+5</td>
          <td>ab*5+</td>
        </tr>
        <tr>
          <td>(1+2)*7</td>
          <td>1 2+7*</td>
        </tr>
        <tr>
          <td>a*b/c</td>
          <td>ab*c/</td>
        </tr>
        <tr>
          <td>((a/(b-c+d))<em>(e-a)</em>c</td>
          <td>abc-d+/ea-<em>c</em></td>
        </tr>
        <tr>
          <td>a/b-c+d<em>e-a</em>c</td>
          <td>ab/c-de<em>+ac</em>-</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="362-evaluating-postfix-expressions">3.6.2 Evaluating Postfix Expressions</h3>

<ul>
  <li>
    <p>To evaluate a postfix expression, we make a single left-to-right scan.</p>

    <ul>
      <li>
        <p>Step 1: Place the operands on a stack until we findan operator</p>
      </li>
      <li>
        <p>Step 2: Remove, from the stack, the correct number of operands for the operator</p>
      </li>
      <li>
        <p>Step 3: Perform the operation</p>
      </li>
      <li>
        <p>Step 4: Place the result back on the stack</p>
      </li>
    </ul>
  </li>
</ul>

<p><img width="262" alt="image-20211003150241068" src="https://user-images.githubusercontent.com/46957634/135751253-fd1b99fc-afa4-4395-bad8-f5b199b86ea1.png" /></p>

<p>Infix: $6 / 2 - 3 + 4 * 2 $</p>

<p>Postfix: $6 2 / 3 - 4 2 * +$</p>

<ul>
  <li>
    <p>Assumptions</p>

    <ul>
      <li>
        <p>To simplify our task, let us assume that the expression contains only the binary operators: $+, -, *, /, $and $\%$.</p>
      </li>
      <li>
        <p>Also, the operands in the expressions are all single digit integers. - Declarations</p>
      </li>
    </ul>
  </li>
</ul>

<script src="https://gist.github.com/underthelights/0e0d574baca665ec2100568e14906599.js"></script>

<h4 id="program-313-evaluate-a-postfix-expression-ex022">Program 3.13: Evaluate a postfix expression [ex022]</h4>

<script src="https://gist.github.com/underthelights/bc893d3f330a1e4d6d8b4fb79a359c1e.js"></script>

<h4 id="program-314-get-a-token-from-the-input-string">Program 3.14: Get a token from the input string</h4>

<script src="https://gist.github.com/underthelights/6a833f4ac311b3bbed4928ea3017495b.js"></script>

<h3 id="363-infix-to-postfix">3.6.3 Infix To Postfix</h3>

<ul>
  <li>An algorithm for producing a postfix expression from an infix one
    <ul>
      <li>Step 1: Fully parenthesize the expression</li>
      <li>Step 2: Move all binary operators so that they replace their corresponding right parenthesis</li>
      <li>Step 3: Delete all parenthesis</li>
    </ul>
  </li>
  <li>Example: $a/b–c+d<em>e–a</em>c$
    <ul>
      <li>AfterStep1: $((((a/b)–c)+(d<em>e))–(a</em>c))$</li>
      <li>AfterStep2 and 3: $ab/c–de<em>+ac</em>-$</li>
    </ul>
  </li>
  <li>
    <p>Although this algorithm works well when done by hand, it is inefficient on a computer because it requires two passes.</p>
  </li>
  <li>
    <p>Note that the order of operands is the same in infix and postfix.</p>
  </li>
  <li>
    <p>Thus, we can form the postfix equivalent by scanning the infix expression left-to-right.</p>
  </li>
  <li>
    <p>However, the order in which the operators are output depends on their precedence.</p>
  </li>
  <li>Since we must output the higher precendence operators first, we save operators until we know their correct placement.
    <ul>
      <li>We stack operators as long as the precedence of the operator at the top of the stack is less than the precendence of the incoming operator.</li>
    </ul>
  </li>
  <li>
    <p>Parenthesized expression</p>

    <ul>
      <li>
        <p>Stack “(“ and operators until we reach “)”.</p>
      </li>
      <li>
        <p>At this point we unstack until we reach the corresponding “(“.</p>
      </li>
      <li>
        <p>Delete “)”.</p>
      </li>
    </ul>
  </li>
  <li>Example: Translation of a+b*c to postfix</li>
</ul>

<p><img width="204" alt="image-20211003150755011" src="https://user-images.githubusercontent.com/46957634/135751255-258a08d3-66d1-40b0-b13a-7cf1354789b6.png" /></p>

<ul>
  <li>Example: Translation of a*(b+c)/d to postfix</li>
</ul>

<p><img width="204" alt="image-20211003150806278" src="https://user-images.githubusercontent.com/46957634/135751257-ab10c6eb-ee51-4155-83d9-71c5ebdb9ac4.png" /></p>

<ul>
  <li>The analysis of the two examples suggests a precedence-based scheme for stacking and unstacking operators.</li>
  <li>We need two types of precedence, an in-stack precedence (isp) and an incoming precedence (icp).
    <ul>
      <li>Remove an operator from the stack only if its isp &gt;= icp of the new operator.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">precedence</span> <span class="n">stack</span><span class="p">[</span><span class="n">MAX_STACK_SIZE</span><span class="p">];</span>
<span class="cm">/* isp and icp arrays - index is value of precendence for
   lparen, rparen, plus, minus, times, divide, mod, eos */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">isp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">icp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</code></pre></div></div>

<h4 id="program-315-convert-infix-to-postfix-ex023">Program 3.15: Convert infix to postfix [ex023]</h4>

<script src="https://gist.github.com/underthelights/9f63914cc4a0410c7b157f58875110d2.js"></script>

<h4 id="analysis-of-postfix">Analysis of postfix</h4>

<ul>
  <li>Let n be the number of tokens in the expression</li>
  <li>Θ(n) time is spent extracting tokens and outputting them.</li>
  <li>Θ(n) time is spent in two while loops, as the number of tokens that get stacked and unstacked is linear in n.</li>
  <li>Thus, the time complexity of function postfix is Θ(n).</li>
</ul>
