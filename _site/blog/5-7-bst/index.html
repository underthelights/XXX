<h2 id="binary-search-treeschapter-57">Binary Search Trees(Chapter 5.7)</h2>

<h3 id="571-definition">5.7.1 Definition</h3>

<ul>
  <li>
    <p>A binary search tree is a binary tree that has the following properties.</p>

    <ul>
      <li>
        <p>Each node has exactly one key and the keys in the tree are distinct.</p>
      </li>
      <li>
        <p>The keys(if any) in the left subtree are smaller than the key in the root.</p>
      </li>
      <li>
        <p>The keys(if any) in the right subtree are larger than the key in the root.</p>
      </li>
      <li>
        <p>The leftand the right subtrees are also binary search tree.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>A binary search tree can be empty. (no elements)</p>

    <p><img width="275" alt="image-20211002201259442" src="https://user-images.githubusercontent.com/46957634/135757885-8bddbacc-2d0c-4038-9376-a16ebe74c3b1.png" /></p>
  </li>
</ul>

<h3 id="572-searching-a-binary-search-tree">5.7.2 Searching a Binary Search Tree</h3>

<ul>
  <li>
    <p>As its name suggests, one of the main use of a binary search tree is to efficiently search arbitrary elements in the tree.</p>
  </li>
  <li>Suppose we would like to search for an element with key k.
    <ul>
      <li>First, we compare k with the key in the root.</li>
      <li>
        <p>If the key in the root is k, then we are done.</p>
      </li>
      <li>
        <p>If k is less than root’s key, we search the left subtree of the root.</p>
      </li>
      <li>If k is larger than root’s key, we search the right subtree of the root.</li>
    </ul>
  </li>
  <li>A recursive version of function search.</li>
</ul>

<script src="https://gist.github.com/underthelights/64a0de5c304a9517fba2905dbc9c8e6c.js"></script>

<ul>
  <li>
    <p>Suppose we want to search for an element with key 15.</p>

    <p><img width="275" alt="image-20211002201346983" src="https://user-images.githubusercontent.com/46957634/135757886-be47c3e6-ddde-495a-bd76-3253377ff887.png" /></p>
  </li>
  <li>
    <p>We start by comparing k(= 15) with the root’s key.</p>
  </li>
  <li>
    <p>Because 15 is smaller than 20, we search for k in its left subtree.</p>

    <p><img width="275" alt="image-20211002201358585" src="https://user-images.githubusercontent.com/46957634/135757887-f42a3937-d76f-4d42-9812-6dc99c12d15d.png" /></p>
  </li>
  <li>
    <p>Since 15 is larger than 10. We move to the right subtree.</p>

    <p><img width="275" alt="image-20211002201409500" src="https://user-images.githubusercontent.com/46957634/135757889-4ab3e735-0eac-4d1a-87d8-418c000f6bfa.png" /></p>
  </li>
  <li>
    <p>Now we compare k with the root of the subtree.</p>
  </li>
  <li>
    <p>This time, the key matches with k, and we have found the element.</p>

    <p><img width="275" alt="image-20211002201425655" src="https://user-images.githubusercontent.com/46957634/135757890-396c55e9-77f9-46d4-b237-c2b37d6cee66.png" /></p>
  </li>
  <li>
    <p>An iterative version of function search</p>

    <script src="https://gist.github.com/underthelights/d63fa454209e4262aecded64d89cc176.js"></script>
  </li>
  <li>
    <p>Time complexity of searchand iterSearch: <strong>O(h)</strong></p>
    <ul>
      <li>
        <p>h is the height of the tree.</p>
      </li>
      <li>
        <p>Can we use n(number of nodes) instead of h to indicate the time complexity ?</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="573-inserting-into-a-binary-search-tree">5.7.3 Inserting into a Binary Search Tree</h3>

<ul>
  <li>
    <p>Suppose we want to insert an element with key k to the binary search tree.</p>
  </li>
  <li>
    <p>First, we search for an element with key k in the tree.</p>
  </li>
  <li>
    <p>If the element exists, then we cancel the insertion.</p>

    <ul>
      <li>Duplicate keys are not allowed in a binary search tree.</li>
    </ul>
  </li>
  <li>
    <p>If the element does not exist, then we add the new element at the position where the search was terminated.</p>

    <ul>
      <li>This will maintain the characteristics of a binary search tree.</li>
    </ul>

    <p><img width="408" alt="image-20211002201534993" src="https://user-images.githubusercontent.com/46957634/135757891-cee20b00-2605-47f1-b790-c2398a4ce6a8.png" /></p>
  </li>
  <li>
    <p>Suppose we want to insert an element with k = 12 to the binary subtree.</p>

    <p><img width="235" alt="image-20211002201547844" src="https://user-images.githubusercontent.com/46957634/135757892-56cfe3e5-28d0-4c4d-8426-7308b5416ae6.png" /></p>
  </li>
  <li>First, we search for the element.
    <ul>
      <li>
        <p>We start from the root of the tree.</p>

        <p><img width="235" alt="image-20211002201608190" src="https://user-images.githubusercontent.com/46957634/135757956-97b6607a-c582-4fc8-9500-e24da615afc7.png" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Because 12 is smaller than 20, we move to the left subtree.</p>
  </li>
  <li>
    <p>Then, since 12 is larger than 10, we move to the right subtree.</p>

    <p><img width="458" alt="image-20211002201621329" src="https://user-images.githubusercontent.com/46957634/135757959-aa04aeae-785d-4639-bff2-10676319a6df.png" /></p>
  </li>
  <li>
    <p>Since 12 is less than 15, we move to the left subtree.</p>
  </li>
  <li>
    <p>We find out that the left subtree is an empty tree.</p>
  </li>
  <li>
    <p>Then, at the position, we insert the new element.</p>

    <p><img width="248" alt="image-20211002201642905" src="https://user-images.githubusercontent.com/46957634/135757961-b42833da-ef46-43bf-9c57-11520993044e.png" /></p>
  </li>
  <li>Function insertNode</li>
</ul>

<script src="https://gist.github.com/underthelights/5b0b8a00661f94ed0a86ff5dfc5bb999.js"></script>

<ul>
  <li>Function modifiedSearch searches the binary tree* node for the key k.
    <ul>
      <li>If the tree is empty or if k is present, the function returns NULL.</li>
      <li>Otherwise, the function returns a pointer to the last node of the tree that was encountered during the search.</li>
    </ul>
  </li>
  <li>
    <p>Analysis of function insertNode</p>

    <ul>
      <li>
        <p>Let h be the height of the binary search tree.</p>
      </li>
      <li>
        <p>The search requires O(h) timeand the remainder of the algorithm takes O(1) time.</p>
      </li>
      <li>
        <p>Thus, the overall time needed by insertNode is O(h).</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="574-deletion-from-a-binary-search-tree">5.7.4 Deletion from a Binary Search Tree</h3>

<ul>
  <li>When deleting an arbitrary node from a binary search tree, we must take care to restore the characteristics of the binary search tree after deletion.
    <ul>
      <li>Four cases</li>
    </ul>
  </li>
  <li>
    <p>Case 1: If the node does not exist, we are done.</p>
  </li>
  <li>Case 2 : If the node is a leaf node
    <ul>
      <li>
        <p>This is the easiest case.Just set the corresponding child field of its parent to NULLand free the node.</p>

        <p><img width="407" alt="image-20211002201736133" src="https://user-images.githubusercontent.com/46957634/135757965-ad2fea2c-1d0c-4b5d-8ff2-17dca683acd2.png" /></p>
      </li>
    </ul>
  </li>
  <li>Case 3: If the deleted node is a nonleaf node with a single child
    <ul>
      <li>We place the single child in the place of the deleted node.</li>
    </ul>

    <p><img width="453" alt="image-20211002201751378" src="https://user-images.githubusercontent.com/46957634/135757967-2c7da5a9-a0e9-4338-ac63-aba8f7803d7e.png" /></p>
  </li>
  <li>
    <p>Case 4 : If the deleted node is a nonleaf node with two children</p>

    <ul>
      <li>This is the most difficult case.</li>
      <li>
        <p>We should replace the deleted node with either the largest element in its left subtree or the smallest element in its right subtree.</p>
      </li>
      <li>Then, delete this replacing element from the subtree from which it was taken.</li>
    </ul>
  </li>
  <li>Suppose we want to remove the element with key = 60 from the BST.
    <ul>
      <li><img width="221" alt="image-20211002201811465" src="https://user-images.githubusercontent.com/46957634/135758002-ac540a17-51f9-4cc9-ac01-b59cd7e6d4c7.png" /></li>
    </ul>
  </li>
  <li>
    <p>First we choose the replacing element.We will choose the largest element in the left subtree.</p>

    <p><img width="257" alt="image-20211002201831322" src="https://user-images.githubusercontent.com/46957634/135758007-6510efa8-436f-4349-b549-8861a07c5f90.png" /></p>
  </li>
  <li>
    <p>We replace the node with key = 55 at the position of the deleted node.</p>
  </li>
  <li>Then, we remove the node from the left subtree.
    <ul>
      <li>
        <p>When removing the node from the left subtree, it must be a leaf node, or a nonleaf node with a single child.</p>
      </li>
      <li>
        <p>The the replacing node has a single child, the child will now take place of the replacing node in the left subtree.</p>
      </li>
    </ul>

    <p><img width="257" alt="image-20211002201845750" src="https://user-images.githubusercontent.com/46957634/135758011-1148d829-247b-4be6-bc6b-4036613d75f1.png" /></p>
  </li>
</ul>

<h4 id="ex039">[ex039]</h4>

<ul>
  <li>Implement function deleteNode
    <ul>
      <li>Follow the descriptions in the previous slides.</li>
      <li>The time complexity of deleteNode should be O(h), where h is the height of the tree.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="n">treePointer</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* implement the function */</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="576-height-of-a-binary-search-tree">5.7.6 Height of a Binary Search Tree</h3>

<ul>
  <li>
    <p>Until now, we have indicated time complexity of operations search, insert, and delete as O(h), where h is the height of the binary search tree.</p>
  </li>
  <li>
    <p>What is the height of a binary search tree, with respect to number of elements n ?</p>
  </li>
  <li>
    <p>Suppose starting from an empty tree, let us try to insert the elements with keys in the following order : 1 2 3 4 5 6 7 8 9 10</p>
  </li>
  <li>
    <p>What would be the height of the binary search tree after inserting the 10 elements ?</p>
  </li>
  <li>
    <p>Unless care is taken, the height of a binary tree with n elements can become as large as n.</p>
  </li>
  <li>
    <p>If insertionsand deletions are made at random, the expected height of the binary search tree is O(log2n) on the average.</p>
  </li>
  <li>
    <p>Search trees with a worst - case height of O(log2n) are called balanced search trees.</p>
    <ul>
      <li>e.g.) AVL trees, red / black trees, 2 - 3 trees, 2 - 3 - 4 trees, B trees, B + trees, etc.</li>
    </ul>
  </li>
</ul>

