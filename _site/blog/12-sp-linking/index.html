<h1 id="12-linking">12. Linking</h1>

<h1 id="linking">Linking</h1>

<h2 id="whats-linking">What’s linking?</h2>

<ul>
  <li>A process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed
여러 코드와 데이터를 모아 memory에 load될 수 있고 executable file 하나로 만드는 작업
    <ul>
      <li>큰 규모의 프로그램을 한 개의 소스 파일로 구성하는 대신</li>
      <li>별도로 editable, compilable smaller module로 나눌 수 있음</li>
      <li>edit할 때 단순히 해당 파일을 recompile하고 다른 file을 recompile할 필요 없이 link함.</li>
    </ul>
  </li>
  <li>작은 프로그램을 만든다고 하면 linking이 필요 없지만 큰 프로그램을 만들면 잘게 잘게 기능을 나누어 쪼갤 필요가 있다.</li>
  <li>Linking can be performed at compile time, load time, and run time
    <ul>
      <li>compile time 시 수행 - src code는 기계어로 translate됨</li>
      <li>load time - application program에 의해 수행</li>
      <li>run time</li>
    </ul>
  </li>
  <li>Linking is performed automatically by programs called linkers on modern systems
    <ul>
      <li>초기에는 수동으로 수행된 linking → 현재는 linker가 대신 수행해줌</li>
    </ul>
  </li>
</ul>

<h2 id="why-bother-learning-about-linking">Why bother learning about linking?</h2>

<ul>
  <li>Understanding linkers will help you</li>
</ul>

<h3 id="build-large-programs-큰-프로그램-작성에-도움">build large programs 큰 프로그램 작성에 도움</h3>

<ul>
  <li>Unless you understand how a linker resolve references, what a library is, and how a linker uses a library to resolve references, these kinds of errors will be baffling and frustrating.</li>
  <li>발생되는 linker error들에 대한 식견</li>
  <li>작은 프로그램 compile하고 linking하는 과정
    <ul>
      <li>local + external defined symbol들을 어떻게 reference할 수 있느냐.</li>
      <li>Malloc / printf reference : 어떻게 library를 활용하여 reference하느냐</li>
    </ul>
  </li>
  <li>linux에서 직접 link해보면 link error가 많이 뜨는데 이해하기 쉬워질 것</li>
</ul>

<h3 id="avoid-dangerous-programming-errors-위험한-에러를-피할-수-있음">avoid dangerous programming errors 위험한 에러를 피할 수 있음</h3>

<ul>
  <li>Programs that incorrectly define multiple global variables can pass through the linker without any warnings in the default case. The resulting programs can exhibit baffling run-time behavior and are extremely difficult to debug.</li>
  <li>global var을 여러 분야에서 잘못 선언 : run-time시에 여러 문제가 생길 수 있음</li>
  <li>linker에서 잡아주지 못하는 / linker의 기능과 방식 을 잘 이해하지 못한 상태에서 runtime 때 찾기는 어렵다
    <ul>
      <li>debug하기도 어려운 상황에서→ 어떻게 권장하는지를 보고 어떻게 발생하고 회피하는지 알 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="understand-how-language-scoping-rules-are-implemented">understand how language scoping rules are implemented</h3>

<ul>
  <li>What’s the difference between global and local variables? (전역 vs 지역)</li>
  <li>What does it really mean when you define a variable or function with the <strong>static</strong> attribute?</li>
</ul>

<h3 id="understand-other-important-systems-concepts">understand other important systems concepts</h3>

<ul>
  <li>The executable object files produced by linkers play key roles in important systems functions such as loading and running programs, virtual memory, paging, and memory mapping</li>
  <li>system의 중요한 여러 개념들을 이해하는 데 도움</li>
</ul>

<h3 id="enable-you-to-exploit-shared-libraries">enable you to exploit shared libraries</h3>

<ul>
  <li>With the increased importance of shared libraries and dynamic linking in modern operating systems, linking is a sophisticated process that provides the knowledgeable programmer with significant power.
현대 사회에서 중요해진 shared library, dynamic linking의 중요성 → 주요 능력을 제공하는 process
    <ul>
      <li>쉬우면서도 간과하는 부분이 많은 linking</li>
    </ul>
  </li>
  <li>For example, many software products use shared libraries to upgrade shrink-wrapped binaries at run time.
    <ul>
      <li>shared library : dynamic linking 다양하게 쓰임</li>
      <li>smaller하게 된 binary를 runtime때 upgrade</li>
    </ul>
  </li>
  <li>Many Web servers rely on dynamic linking of shared libraries to serve dynamic content.5
    <ul>
      <li>많은 sw들은 runtime 시에 linking많이 씀 : service할 때 동적으로 mapping</li>
    </ul>
  </li>
</ul>

<h2 id="example-c-program">Example C Program</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>각각에 대해서 linking을 수행하여 하나의 executable file</li>
  <li>sum이라는 procedure는 sum.c로부터 reference하여 구동시켜 Main 함수에서 integer array</li>
</ul>

<h1 id="static-linking">Static Linking</h1>

<ul>
  <li>
    <p>Programs are translated and linked using a compiler driver:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">linux</span><span class="o">&gt;</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">Og</span> <span class="o">-</span><span class="n">o</span> <span class="n">prog</span> <span class="n">main</span><span class="p">.</span><span class="n">c</span> <span class="n">sum</span><span class="p">.</span><span class="n">c</span>
  <span class="n">linux</span><span class="o">&gt;</span> <span class="p">.</span><span class="o">/</span><span class="n">prog</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="compiler-driver">Compiler driver</h2>

<ul>
  <li>Preprocessor, compiler, assembler, linker를 필요에 따라 user 대신하여 호출</li>
</ul>

<p><img src="https://raw.githubusercontent.com/underthelights/underthelights.github.io/main/_posts/SP/12/Untitled.png" alt="Untitled" /></p>

<ul>
  <li>C preprocessor (cpp) : <code class="language-plaintext highlighter-rouge">main.c</code> → <code class="language-plaintext highlighter-rouge">main.i</code>
    <ul>
      <li>translates the C source file main.c into an ASCII intermediate file main.i</li>
    </ul>
  </li>
  <li>C Compiler (cc1) : <code class="language-plaintext highlighter-rouge">main.i</code> → <code class="language-plaintext highlighter-rouge">main.s</code>
    <ul>
      <li>translates main.i into an ASCII assembly-language file main.s</li>
    </ul>
  </li>
  <li>Assembler (as)<code class="language-plaintext highlighter-rouge">main.s</code> → <code class="language-plaintext highlighter-rouge">main.o</code>
    <ul>
      <li>translates main.s into a binary relocatable object file main.o</li>
    </ul>
  </li>
  <li>Linker (ld)
    <ul>
      <li>combine main.o and sum.o along with the necessary object files,to create the binary executable object file</li>
      <li>ld 실행 : prog을 생성하기 위해 main.o / sum.o 연결</li>
    </ul>
  </li>
</ul>

<p>→ <code class="language-plaintext highlighter-rouge">./prog</code> : prog 실행</p>

<ul>
  <li>
    <p>Shell은 loader라는 OS Function을 호출하여, 실행 파일 prog의 code, data를 memory로 복사하고 control을 program 시작 부분으로 전환한다.</p>
  </li>
  <li>Source File
    <ul>
      <li>각 symbol들의 주소, access하는 주소
  memory할 때 어디에 올라가는지
  VM에서 어디 부분에 올라가는지 등은 잘 정해져 있지 않기 때문에 relocate필요</li>
    </ul>
  </li>
  <li>Separately compiled relocatable obj files
    <ul>
      <li>linking해야지 virtual memory 상 어디에 올라가는지 상대적인 offset 부분을 나중에 알 수 있기 때문에, 나중에 relocate되는 obj file이라고 부른다.
  그러고 나서 나중에 linking되게 되면 실행 file 생성</li>
    </ul>
  </li>
  <li>Fully linked</li>
</ul>

<h2 id="why-linkers">Why Linkers?</h2>

<h3 id="reason-1-modularity">Reason 1: Modularity</h3>

<p>Program can be written as a collection of smaller source files, rather than one monolithic mass.
구조적으로 쪼개서 작은 source file로 만든다 → 내가 필요한 부분들만 쓸 수 있게 하는데 도움이 된다</p>

<ul>
  <li>Can build libraries of common functions (more on this later)
    <ul>
      <li>Standard c library, math library : 다른 application에서도 사용 가능</li>
      <li>e.g., Math library, standard C library</li>
    </ul>
  </li>
</ul>

<h3 id="reason-2-efficiency">Reason 2: Efficiency</h3>

<ul>
  <li>Time: Separate compilation
    <ul>
      <li>sum.c code만 수정하고 sum.c만 recompile</li>
      <li>monolithic한 프로그램이 아니라면 코드 전체를 모두 compile하는 것보다 더 빨라짐</li>
      <li>Change one source file, compile, and then relink.</li>
      <li>No need to recompile other source files.</li>
    </ul>
  </li>
  <li>Space: Libraries
    <ul>
      <li>Common functions can be aggregated into a single file…
        <ul>
          <li>하나의 compile로 만들어질 수 있음</li>
          <li>모두다 사용하는게 아니고, 특정한 부분만 사용할 수 있기 때문에 필요한 특정한 부분만 사용하는거기 때문에 필요에 따라 linker를 돌아 사용하는게 효과적</li>
        </ul>
      </li>
      <li>Yet executable files and running memory images contain only code for the functions they actually use.
        <ul>
          <li>memory에 다 올라갈 필요가 없음 → powerful software programming</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="what-do-linkers-do">What Do Linkers Do?</h2>

<ul>
  <li>to make executable file → linker는 두 가지 step task를 수행해야 한다.</li>
</ul>

<h3 id="step-1-symbol-resolution">Step 1: Symbol resolution</h3>

<ul>
  <li>Programs define and reference symbols (global variables and functions):
    <ul>
      <li>program 내부에서 여러 symbol을 가져다가 reference</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">swap</span><span class="p">()</span> <span class="p">{...}</span> <span class="cm">/* define symbol swap */</span>
  <span class="n">swap</span><span class="p">();</span> <span class="cm">/* reference symbol swap */</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">xp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="cm">/* define symbol xp, reference x */</span>
</code></pre></div>    </div>

    <ul>
      <li>Swap function definition - reference</li>
      <li>xp라는 symbol : x라는 variable의 address value</li>
    </ul>
  </li>
  <li>Symbol definitions are stored in object file (by assembler) in symbol table.
    <ul>
      <li>Symbol table is an array of structs → Executable file 생성 이전 object file : section에 symbol table이 들어감.
        <ul>
          <li>Each entry includes name, size, and location of symbol.</li>
          <li>compile시 preprocess다음 c compile하여 obj 파일 만들어질 때 elf라는 file format에서 symbol table 안에 저장되는데 각 symbol마다 크기, 이름, 위치 생성 정보를 가진 table</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition.</strong> symbol이 있으면 각각의 reference가 정확히 하나의 symbol definition과 대응되어야 한다.
    <ul>
      <li>cnt가 두 번 initialized -&gt; linker error</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">a</span><span class="p">.</span><span class="n">c</span> <span class="o">:</span>
  <span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">main</span><span class="p">(){</span><span class="err">…</span><span class="p">}</span>
    
  <span class="n">b</span><span class="p">.</span><span class="n">c</span> <span class="o">:</span> 
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Fun</span><span class="p">(){</span><span class="err">…</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="step-2-relocation">Step 2: Relocation</h3>

<ul>
  <li>Merges separate code and data sections into single sections
    <ul>
      <li>두개의 다른 object file (code/data)를 모아 하나의 section으로 만emsek.</li>
      <li>0번지에서 시작하는 code, data section</li>
    </ul>
  </li>
  <li>Executable file로 linux가 만들게 되는데 memory location에 올라가는 절대 주소로 변환 : 실제 가상메모리 주소는 어떻게 할 것이냐
    <ul>
      <li>Relocates symbols from their relative locations in the .o files to their final absolute memory locations in the executable.</li>
      <li>linker : code/data section을 symbol def과 연결 → relocate하며 모든 reference를 모두 수정하여 절대주소를 가리키도록 함</li>
    </ul>
  </li>
  <li>relocation entry : symbol에 대한 모든 reference 가 새로운 위치를 가리킬 수 있게 해 줌
    <ul>
      <li>Updates all references to these symbols to reflect their new positions.</li>
    </ul>
  </li>
</ul>

<p>Let’s look at these two steps in more detail….</p>

<h1 id="three-kinds-of-object-files-modules">Three Kinds of Object Files (Modules)</h1>

<h3 id="relocatable-object-file-o-file">Relocatable object file (.o file)</h3>

<ul>
  <li>Contains code and data in a form that can be combined with other relocatable object files to form executable object file.</li>
  <li>Each .o file is produced from exactly one source (.c) file</li>
  <li></li>
</ul>

<p>Main.o, .o</p>

<ul>
  <li>code, data를 가지고 있는데 다른 relocatable file과 같이 compile되어 실행 file을 만들기 위한 code, data를 가진 object file</li>
</ul>

<h3 id="executable-object-file-aout-file">Executable object file (a.out file)</h3>

<ul>
  <li>Contains code and data in a form that can be copied directly into memory and then executed.</li>
  <li>명명 of <code class="language-plaintext highlighter-rouge">a.out</code>
    <ul>
      <li>BELL Lab에서 compile하고 executable file 이름을 지정하지 않을 때 a.out으로 명명</li>
      <li>특정한 의미는 없음</li>
    </ul>
  </li>
</ul>

<h3 id="shared-object-file-so-file">Shared object file (.so file)</h3>

<ul>
  <li>Special type of relocatable object file that can be loaded intomemory and linked dynamically, at either load time or run-time.</li>
  <li>Called Dynamic Link Libraries (DLLs) by Windows13</li>
</ul>

<h1 id="executable-and-linkable-format-elf">Executable and Linkable Format (ELF)</h1>

<ul>
  <li>Standard binary format for object files</li>
  <li>One unified format for
    <ul>
      <li>Relocatable object files (.o),</li>
      <li>Executable object files (a.out)</li>
      <li>Shared object files (.so)</li>
    </ul>
  </li>
  <li>Generic name: ELF binaries</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250682-b6613650-3d77-4763-bff1-40350dc3536a.png" alt="Untitled 1" /></p>

<h3 id="elf-header-16-b">Elf header (16 B)</h3>

<ul>
  <li>Describes word size, byte ordering, file type (.o, exec, .so), machine type, file offset of section header table, etc.</li>
</ul>

<h3 id="section-header-table">Section header table</h3>

<ul>
  <li>Offsets and sizes of each section</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250683-f504e0b1-4b05-4b72-9ae9-05fca5097165.png" alt="Untitled 2" /></p>

<h3 id="text-section"><code class="language-plaintext highlighter-rouge">.text</code> section</h3>

<ul>
  <li>Code (the machine code of the compiledprogram)</li>
  <li>compile된 program의 기계어 code가 들어가 있음</li>
  <li>c compile후 assembly에 의해 기계어 코드 (add, multiply, load, store에 대한 assembly에 대한 기계어 코드가 들어가 있음)</li>
</ul>

<h3 id="rodata-section"><code class="language-plaintext highlighter-rouge">.rodata</code> section</h3>

<ul>
  <li>Read only data: jump tables for switch</li>
  <li>Read only data section : read only data, jump table, format string 가지고 있음</li>
</ul>

<h3 id="data-section"><code class="language-plaintext highlighter-rouge">.data</code> section</h3>

<ul>
  <li>Initialized global variables
    <ul>
      <li>Initialized global var : int count = 6;</li>
      <li>Local variable static : static int a =3;</li>
    </ul>
  </li>
</ul>

<h3 id="bss-section"><code class="language-plaintext highlighter-rouge">.bss</code> section</h3>

<ul>
  <li>
    <p>Uninitialized global variables</p>

    <p>아직은 yet initialized : 위치만을 가지고 잇음 (공간 할당 x)</p>
  </li>
  <li>
    <p>이름 : “Block Started by Symbol”, “Better Save Space”</p>
  </li>
</ul>

<p>initialize된 global var을 구분함으로서 공간을 할당하지만 .bss는 공간을 할당하지 않아 공간 효용성을 구분할 수 있음 →Has section header but occupies no space</p>

<ul>
  <li>나중에 memory에 load될 때는 0으로 초기화 : 그 때의 메모리 공간 생성</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250686-1347cb96-2326-42d5-96f4-dd7f5eaf6f40.png" alt="Untitled 3" /></p>

<h3 id="symtab-section"><code class="language-plaintext highlighter-rouge">.symtab</code> section</h3>

<ul>
  <li>Symbol table with info. about functions and global variables (procedures and static variable names) that are defined and referenced in the program-</li>
</ul>

<h3 id="reltextsection"><code class="language-plaintext highlighter-rouge">.rel.text</code>section</h3>

<ul>
  <li>Relocation info for .text section</li>
  <li>Addresses of instructions that will need to be modified in the executable
    <ul>
      <li>Instructions for modifying.-</li>
    </ul>
  </li>
</ul>

<h3 id="reldatasection"><code class="language-plaintext highlighter-rouge">.rel.data</code>section</h3>

<ul>
  <li>Relocation info for .data section</li>
  <li>Addresses of pointer data that will need to be modified in the merged executable-</li>
</ul>

<h3 id="debug-section"><code class="language-plaintext highlighter-rouge">.debug</code> section</h3>

<ul>
  <li>Info for symbolic debugging (gcc -g)ELF header.text section.rodata section.data section.bss section.symtab section.rel.txt section.rel.data section.debug sectionSection header table18</li>
</ul>

<h1 id="symbols-and-symbol-tables">Symbols and Symbol Tables</h1>

<ul>
  <li>Each relocatable object module, m, has a symbol table
    <ul>
      <li>각각의 relocatable object (module) : 어떠한 module에 의해 reference / define되어 있는 symbol에 대한 정보를 가진 symbol table이 가진 정보</li>
    </ul>
  </li>
  <li>The symbol table contains information about the symbols that are defined and referenced by m</li>
  <li>In the context of a linker, there are three different kinds of symbols:
    <ul>
      <li>Global symbols</li>
      <li>External symbols</li>
      <li>Local symbols</li>
    </ul>
  </li>
</ul>

<h2 id="linker-symbols">Linker Symbols</h2>

<h3 id="global-symbols">Global symbols</h3>

<ul>
  <li>Symbols defined by module m that can be referenced by other modules.</li>
  <li>E.g.: non-static C functions and non-static global variables.
    <ul>
      <li>다른 module에 의해 reference될 수 있는 global variable
  a.c/Int count = 5
  b.c/Int count;</li>
    </ul>
  </li>
</ul>

<h3 id="external-symbols">External symbols</h3>

<ul>
  <li>Global symbols that are referenced by module m but defined by some other module.</li>
  <li>module에 의해서 reference되는 symbol이지만 다른 module에 의해서 defined되어 있는 것
    <ul>
      <li>a.c입장에서 b.c.의 count symbol</li>
    </ul>
  </li>
</ul>

<h3 id="local-symbols">Local symbols</h3>

<ul>
  <li>Symbols that are defined and referenced exclusively by module m.</li>
  <li>E.g.: C functions and global variables defined with the static attribute.</li>
  <li><strong>Local linker symbols are not local program variables 20</strong></li>
</ul>

<h2 id="local-linker-symbols-vs-local-program-variables">Local linker symbols vs. Local program variables</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.symtab</code> does not contain any symbols that correspond to local non-static program variables
    <ul>
      <li>var 중 non static variable들은 Symbol table에 들어가지 않음 / linker에 연관 x</li>
      <li>Local var : stack / Local symbol : symbol table에 들어감</li>
    </ul>
  </li>
  <li>Local non-static program variables are managed at run time on the stack and are not of interest to the linker</li>
</ul>

<p>See more details in next slides…</p>

<h1 id="step-1-symbol-resolution-1">Step 1: Symbol Resolution</h1>

<p><img src="https://user-images.githubusercontent.com/46957634/183250687-d356bbb5-0a06-441e-a715-37156b66c00a.png" alt="Untitled 4" /></p>

<ul>
  <li></li>
</ul>

<h2 id="local-symbols-1">Local Symbols</h2>

<p>Local static var : global variable -&gt; .data</p>

<ul>
  <li>단 local var이기 때문에 함수를 다시 호출하게 되면 재접속 가능
Local nonstatic var : static x, 일반 local var -&gt; @stack</li>
</ul>

<p>f, g에서 같은 variable x를 쓰지만 다른 symbol
X.1, x.2 이런식으로 compiler가 놓고 compiler가 unique한 이름을 가지도록 함.</p>

<ul>
  <li>Local non-static C variables vs. local static C variables
    <ul>
      <li>local non-static C variables: stored on the stack</li>
      <li>
        <p>local static C variables: stored in either .bss, or .data</p>

        <p>Local static var : global variable -&gt; .data</p>

        <ul>
          <li>단 local var이기 때문에 함수를 다시 호출하게 되면 재접속 가능
  Local nonstatic var : static x, 일반 local var -&gt; @stack</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250689-46a8e3d6-738c-4157-ba55-5e037051ed86.png" alt="Untitled 5" /></p>

<ul>
  <li>Compiler allocates space in .data for each definition of x</li>
  <li>Creates local symbols in the symbol table with unique names,
    <ul>
      <li>f, g에서 같은 variable x를 쓰지만 다른 symbol
  → x.1, x.2 이런식으로 compiler가 놓고 compiler가 unique한 이름을 가지도록 함.</li>
      <li>e.g., x.1 and x.2</li>
    </ul>
  </li>
</ul>

<h2 id="how-linker-resolves-duplicate-symbol-definitions">How Linker Resolves Duplicate Symbol Definitions</h2>

<ul>
  <li>Program symbols are either strong or weak</li>
  <li><strong>Strong:</strong> procedures and initialized globals
    <ul>
      <li>initialize되어 있는 variable</li>
    </ul>
  </li>
  <li><strong>Weak:</strong> uninitialized globals
    <ul>
      <li>uninitialize되어 있는 variable</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250690-9fb87e46-e2a7-45d4-93e5-48b1c7529ec5.png" alt="Untitled 6" /></p>

<h2 id="linkers-symbol-rules">Linker’s Symbol Rules</h2>

<ul>
  <li><strong>Rule 1: Multiple strong symbols are not allowed</strong>
    <ul>
      <li>Each item can be defined only once</li>
      <li>Otherwise: Linker error</li>
    </ul>

    <p>만일 symbol이 strong하다 - 단 한번만 선언 가능</p>

    <ul>
      <li>compiler가 보고 나서 foo=5(p1.c) / foo=10(p2.c) -&gt; link error</li>
      <li>같은 게 strong이면 안됨</li>
    </ul>
  </li>
  <li><strong>Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol</strong>
    <ul>
      <li>References to the weak symbol resolve to the strong symbol</li>
      <li>Weak가 strong을 쫓아간다.</li>
      <li>P2의 foo : weak-&gt; p1의 foo : strong을 쫓아감
  p2에서 foo 접근 = p1에서의 foo 접근</li>
    </ul>
  </li>
  <li><strong>Rule 3: If there are multiple weak symbols, pick anarbitrary one</strong>
    <ul>
      <li>둘다 weak면 compiler가 임의로 설정</li>
    </ul>
  </li>
</ul>

<p>rule 1.</p>

<p>만일 symbol이 strong하다 - 단 한번만 선언 가능</p>

<ul>
  <li>compiler가 보고 나서 foo=5(p1.c) / foo=10(p2.c) -&gt; link error</li>
  <li>같은 게 strong이면 안됨</li>
</ul>

<p>Rule 2.</p>

<p>Weak가 strong을 쫓아간다.</p>

<ul>
  <li>P2의 foo : weak-&gt; p1의 foo : strong을 쫓아감</li>
</ul>

<p>p2에서 foo 접근 = p1에서의 foo 접근</p>

<p>rule3</p>

<p>둘다 weak면 compiler가 임의로 설정</p>

<h2 id="linker-puzzle">Linker Puzzle</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250691-5ff73093-2555-41c8-9cb5-a04bb1b0dd40.png" alt="Untitled 7" /></p>
<ul>
  <li>link error - 모종의 이유로 version이 달라 뜨는 error</li>
</ul>

<h2><img src="https://user-images.githubusercontent.com/46957634/183250693-0ef021f3-20c7-49f5-a820-86e79d39a50e.png" alt="Untitled 8" /></h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250696-17586618-91c2-4d30-87d3-5ff032e2fd88.png" alt="Untitled 9" /></p>
<ul>
  <li>둘 중에 무엇을 선택할 지 모름 (weak)
    <ul>
      <li>1-&gt;2, : y를 overwrite하지 않음 / 2-&gt;1 : overwrite</li>
    </ul>
  </li>
  <li>→ ‘might’라는 용어 사용 : 해당 xy가 다른 strong symbol reference할 수 있기 때문이다</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250699-1b391410-d480-43ce-99fb-b302d0a32313.png" alt="Untitled 10" /></p>
<ul>
  <li>double로 선언한 x (8byte) - integer 로 원래 선언된 형태 → y에게도 악영향</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250700-f113d77b-3d63-4337-802c-f3294e818c29.png" alt="Untitled 11" /></p>
<ul>
  <li>Nightmare scenario : 2 identical weak structs, compiled by different compilers with different alignment rules (compiler dependent)</li>
</ul>

<p>link error</p>

<ul>
  <li>모종의 이유로 version이 달라 뜨는 error</li>
</ul>

<h2 id="two-weak-definitions-of-x-rule-3">Two weak definitions of x (rule 3)</h2>

<ul>
  <li>Run-time bugs
    <ul>
      <li>Can cause some insidious run-time bugs that are incomprehensible to the unwary programmer</li>
      <li>compiler error가 발생하지는 않는데</li>
      <li>
        <p>둘 다 uninitialized된 형태, f 수행 후 15212로 변화</p>

        <p><img src="https://user-images.githubusercontent.com/46957634/183250702-1ced2849-efda-4cf4-853c-8b035f128403.png" alt="Untitled 12" /></p>
        <h2 id="another-example-rule-2">Another example (rule 2)</h2>
      </li>
    </ul>
  </li>
  <li>Subtle and nasty run-time bugs!
    <ul>
      <li>On an x86-64/Linux machine, doubles are 8 bytes and ints are 4 bytes</li>
      <li>Suppose the address of x is 0x601020 and the address of y is 0x601024</li>
      <li>The assignment x = 0.0 in lin6 6 will overwrite the memory locations for x and y with the double-precision floating-point representation of negative zero!</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/46957634/183250703-d65958c6-18e5-4b99-af5b-0c7f1d16461b.png" alt="Untitled 13" /></p>

    <ul>
      <li>Compile error 전혀 안 뜸</li>
      <li>나도 모르게 y값이 바뀜, 그러나 link error를 runtime때 찾기에는 너무 어렵다
        <ul>
          <li>→ 주의깊게 익혀야 한다.</li>
        </ul>
      </li>
    </ul>

    <p>library에서 우연치 않게 같은 symbol을 써서 이상하게 돌아가는 경우도 발생가능</p>

    <p>Compile error 전혀 안 뜸</p>

    <ul>
      <li>나도 모르게 y값이 바뀜</li>
      <li>link error를 runtime때 찾기에는 너무 어렵다</li>
      <li>
        <blockquote>
          <p>주의깊게 익혀야 한다.</p>
        </blockquote>
      </li>
    </ul>

    <p>library에서 우연치 않게 같은 symbol을 써서 이상하게 돌아가는 경우도 발생가능</p>
  </li>
</ul>

<h2 id="global-variables">Global Variables</h2>

<ul>
  <li>Avoid if you can</li>
  <li>Otherwise
    <ul>
      <li>Use static if you can
        <ul>
          <li>data 에서 선언되지만 해당 함수 내에서만 접근 가능</li>
        </ul>
      </li>
      <li>Initialize if you define a global variable : initialize해서 가급적 문제가 발생하지 않도록 함.</li>
      <li>Use extern if you reference an external global variable
        <ul>
          <li>Initialize된 형태로 써라 (쓰지 않을 수 있다면 쓰지 마라)</li>
          <li>→ 예기치 않은 runtime bug에 빠지지 않도록 해라.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>static 선언</li>
</ol>

<ul>
  <li>data 에서 선언되지만 해당 함수 내에서만 접근 가능</li>
</ul>

<ol>
  <li>
    <p>initialize해서 가급적 문제가 발생하지 않도록 함.</p>
  </li>
  <li>
    <p>extern</p>
  </li>
</ol>

<ul>
  <li>Initialize된 형태로 써라 (쓰지 않을 수 있다면 쓰지 마라)</li>
  <li>
    <blockquote>
      <p>예기치 않은 runtime bug에 빠지지 않도록 해라.</p>
    </blockquote>
  </li>
</ul>

<h1 id="step-2-relocation-1">Step 2: Relocation</h1>

<ul>
  <li>relocation
    <ul>
      <li>내가 penn university에서 졸업하고 job을 구하면 relocate : relocate negotiation (주소 바뀌는 것에 대한 signing bonus 등)</li>
      <li>내가 penn university에 있다가 다른 회사 사무소 주소로 바귐</li>
      <li>이처럼, 내가 현재 접근하는 변수의 주소를 모르기 때문에 relocate하는 과정 : 주소 찾아서 assign해주는 작업</li>
    </ul>
  </li>
</ul>

<p><strong>Step1: Symbol resolution</strong></p>

<ul>
  <li>Once the linker has completed the symbol resolution step, it has associated each symbol reference in the code with exactly one symbol definition
    <ul>
      <li>linker가 symbol resolution step에 따라 resolve하게 되면 모든 symbol reference는 오직 한개의 symbol definition에 associate된다</li>
    </ul>
  </li>
  <li>At this point, the linker knows the exact sizes of the code and data sections in its input object modules.
    <ul>
      <li>obj file 생성하게 되면 code, data에 대한 정확한 정보를 알게 됨</li>
    </ul>
  </li>
  <li>만일 그렇지 않다면 link error</li>
</ul>

<p><strong>Now, next step is the relocation step (Step 2)</strong></p>

<ul>
  <li>
    <p>Merges the input modules and assigns run-time addresses to eachsymbol</p>

    <p>두 개의 object module을 병합하여 실제 각각의 symbol에 run time address를 부여해주는 작업</p>
  </li>
  <li>
    <p>Moe details will come in the next slides…</p>
  </li>
  <li>
    <p>relocation</p>
    <ul>
      <li>내가 penn university에서 졸업하고 job을 구하면 relocate : relocate negotiation (주소 바뀌는 것에 대한 signing bonus 등) - 내가 penn university에 있다가 다른 회사 사무소 주소로 바귐</li>
      <li>내가 현재 접근하는 변수의 주소를 모르기 때문에 relocate하는 과정 : 주소 찾아서 assign해줌</li>
    </ul>
  </li>
</ul>

<ol>
  <li>Symbol resolution 복습</li>
</ol>

<ul>
  <li>linker가 symbol resolution step에 따라 resolve하게 되면 모든 symbol reference는 오직 한개의 symbol definition에 associate된다
    <ul>
      <li>만일 그렇지 않다면 link error</li>
    </ul>
  </li>
  <li>obj file 생성하게 되면 code, data에 대한 정확한 정보를 알게 됨</li>
</ul>

<ol>
  <li>relocation step</li>
</ol>

<ul>
  <li>main.c , .c : 두 개의 object module을 병합하여 실제 각각의 symbol에 run time address를 부여해주는 작업</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250704-b6b65e72-d191-470e-b186-2c84210bf0ca.png" alt="Untitled 14" /></p>

<p>relocation : 이 세 가지를 하나로 병합하는 과정</p>

<p>ELF File Format</p>

<p>.Text / .Data</p>

<ul>
  <li>
    <p>각 symbol에다 address assign하는 것에 대해 알아보자</p>
  </li>
  <li>relocation : 이 세 가지를 하나로 병합하는 과정</li>
  <li>ELF File Format</li>
  <li>.Text / .Data : 각 symbol에다 address assign하는 것에 대해 알아보자</li>
</ul>

<h2 id="relocation-entries">Relocation Entries</h2>

<ul>
  <li>object module : Compiler 내 assembler가 기계어 code를 만들어 내는데 이를 obj module</li>
  <li>When an assembler generates an object module, it does not know where the code and data will ultimately be stored in memory.: 이를 생성해 낼 때, 1. code, data가 나중에 executible file 생성하는 시점에서 memory 어디에 적재될지 모름</li>
  <li>
    <p>Nor does it know the location of any externally defined functions of global variables that are referenced by the module.</p>

    <ol>
      <li>main.c에서 sum이라는 함수는 외부에서 externally defined : sum이라는 함수를 호출할 때 그 위치가 어디인지 모른다.</li>
    </ol>
  </li>
  <li>
    <p>So, whenever the assembler encounters a reference to an object whose ultimate location is unknown, it generates a relocation entry that tells the linker how to modify the reference when it merges the object file into an executable.</p>

    <p>→ 결국에는 location 어디인지 모르는 (global var, external function)은 알려져 있지 않기 때문에 relocation entry라고 해서 하나씩 만든다.</p>

    <ul>
      <li>ELF file format의 .rel.text / .rel.data에 들어간다</li>
      <li>Linker에게 ‘이 주소를 잘 모르니까 나중에 다른 obj와 merge되어 executable file만들 때 이 reference를 수정해야 한다’고 알려줌
        <ul>
          <li>.rel을 보고 symbol들이 address가 확인되지 않음을 보고 linking 과정에서 병합하며 그 address를 채워준다</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">main</span><span class="p">.</span><span class="n">c0000000000000000</span><span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;</span> <span class="o">:</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">484</span> <span class="o">:</span> <span class="n">be9</span> <span class="o">:</span> <span class="n">bfe</span> <span class="o">:</span>
 <span class="n">e813</span> <span class="o">:</span> <span class="mi">48</span> <span class="mi">17</span> <span class="o">:</span> <span class="n">c383ec08</span> <span class="mo">020000</span> <span class="mo">00000000</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">83</span><span class="n">c40800</span> <span class="mo">0000</span><span class="n">sub</span> <span class="err">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">%</span> <span class="n">rspmov</span> <span class="err">$</span><span class="mh">0x2</span><span class="p">,</span> <span class="o">%</span> <span class="n">esimov</span> <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span> <span class="o">%</span> <span class="n">edi</span> <span class="err">#</span> <span class="o">%</span> <span class="n">edi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arraya</span> <span class="o">:</span> <span class="n">R_X86_64_32</span> <span class="n">array</span> <span class="err">#</span><span class="n">Relocation</span> <span class="n">entrycallq</span> <span class="mi">13</span> <span class="o">&lt;</span> <span class="n">main</span> <span class="o">+</span> <span class="mh">0x13</span> <span class="o">&gt;</span> <span class="err">#</span><span class="n">sum</span><span class="p">()</span> <span class="n">f</span> <span class="o">:</span> <span class="n">R_X86_64_PC32</span> <span class="n">sum</span> <span class="o">-</span> <span class="mh">0x4</span> <span class="err">#</span><span class="n">Relocation</span> <span class="n">entryadd</span> <span class="err">$</span><span class="mh">0x8</span><span class="p">,</span> <span class="o">%</span> <span class="n">rspretqmain</span><span class="p">.</span><span class="n">oRelocation</span> <span class="n">EntriesSource</span> <span class="o">:</span> <span class="n">objdump</span> <span class="err">–</span><span class="n">r</span> <span class="err">–</span><span class="n">d</span> <span class="n">main</span><span class="p">.</span><span class="n">o33</span>
</code></pre></div></div>

<ul>
  <li>Relocation entries for code are placed in .rel.text.</li>
  <li>Relocation entries for data are placed in .rel.data. 32</li>
</ul>

<h2 id="relocated-text-section">Relocated .text section</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250705-f1e4b6eb-2f1f-459e-9c3d-5ef33dc938bc.png" alt="Untitled 15" /></p>

<ul>
  <li>Relocation: 앞의 obj module들을 병합한 다음에 각 symbol에 대해 runtime address
    <ul>
      <li>(Vm address O, not physical) E8 05 00 00 00</li>
      <li>instruction 수행할 때 relative</li>
      <li>현재 주소 :  PC는 항상 다음 주소 (명령어 fetch하는 그 순간에) PC가 가리키는 주소에 5 더하면 <sum>의 주소가 나온다 :</sum></li>
      <li>상대적인 주소 : detail은 assembler, linking / 2 path scanning을 하기 때문에</li>
    </ul>
  </li>
</ul>

<h1 id="loading-executable-object-files">Loading Executable Object Files</h1>

<p><img src="https://user-images.githubusercontent.com/46957634/183250706-9c12a80d-f4e7-40f3-87d2-2ab267602bb3.png" alt="Untitled 16" /></p>

<ul>
  <li>ELF 보면 되고 process address space : 0x400000~2^48 -1 (process)</li>
  <li>kernel</li>
  <li>shaerd library : 동적으로 linking 만들어지는 library, API memory map을 위함</li>
  <li>Heap : break point만큼 heap의 크기</li>
  <li>segment : r/w data</li>
  <li>Shared memory 하나 올라오고 Application a, b 뜰 때 필요에 따라 reference함 
(그냥 copy하는게 아님) - c가 shared library라고 할 때 ptr로 그냥 갈 수 있기 때문에 c는 하나만 있으면 되어 duplicate하지 않아도 됨</li>
  <li>memory mapped region에 대한 ptr가 들어가있는 것.</li>
</ul>

<h2 id="packaging-commonly-used-functions">Packaging Commonly Used Functions</h2>

<ul>
  <li>
    <p>How to package functions commonly used by programmers?</p>

    <p>자주 쓰는 함수 모아둠  - library 형태로 모아 둠</p>
  </li>
  <li>Math, I/O, memory management, string manipulation, etc.- Awkward, given the linker framework so far:
    <ul>
      <li>memory management : malloc, calloc 등 모아서 자주 쓰니까 어떻게 하나의 패키지로 쓰는가</li>
    </ul>
  </li>
  <li>Option 1: Put all functions into a single source file
    <ol>
      <li>모든 함수들을 코드들에 집어넣음</li>
    </ol>
    <ul>
      <li>Programmers link big object file into their programs</li>
      <li>Space and time inefficient
        <ul>
          <li>생성되는 executable code 자체가 많이 커짐 → 시간, 공간 많이 차지함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Option 2: Put each function in a separate source file
    <ol>
      <li>modular 접근 방법처럼 기능 별로 file들을 쪼갠다</li>
    </ol>

    <p>각 file들에는 특정 기능 수행하는 fn들을 따로 따로 만들어 줌</p>

    <ul>
      <li>필요한 것만 링킹 - 모든 소스 파일을 다 집어넣을 필요 없음</li>
      <li>Programmers explicitly link appropriate binaries into their programs</li>
      <li>More efficient, but burdensome on the programmer36
        <ul>
          <li>효율적이지만 프로그래머가 이해해주어야 함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="old-fashioned-solution-static-libraries">Old-fashioned Solution: Static Libraries</h2>

<ul>
  <li>Static libraries (.a archive files)</li>
  <li>Concatenate related relocatable object files into a single file with an index (called an archive).</li>
  <li>Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives.</li>
  <li>
    <p>If an archive member file resolves reference, link it into the executable.</p>
  </li>
  <li>static linking - static library</li>
  <li>archive file</li>
</ul>

<p>Object files 들을 concatenate해서 하나의 file로 만듬</p>

<p>index를 통해 archive 안에 sum, average 등의 함수를 찾아서 참조할 수 있도록 함</p>

<ul>
  <li>archive 안에서 symbol 찾아보고 나서 실행 file linking</li>
</ul>

<h2 id="creating-static-libraries">Creating Static Libraries</h2>

<p>함수별로 모듈만들어 하나의 archive로 만들어 static link 만들 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/46957634/183250707-98680edd-9ce0-44ae-872c-85d0fdfb3030.png" alt="Untitled 17" /></p>

<ul>
  <li>Archiver allows incremental updates-</li>
  <li>Recompile function that changes and replace .o file in archive.38</li>
</ul>

<h2 id="commonly-used-libraries">Commonly Used Libraries</h2>

<ul>
  <li>libc.a (the C standard library)
    <ul>
      <li>4.6 MB archive of 1496 object files.</li>
    </ul>
  </li>
  <li>I/O, memory allocation, signal handling, string handling, data and time, random numbers, integer mathlibm.a (the C math library)
    <ul>
      <li>2 MB archive of 444 object files.</li>
    </ul>
  </li>
</ul>

<p><img src="https://o.remove.bg/downloads/13330d44-9549-410f-80b6-80a64b79942b/Untitled_18-removebg-preview.png" alt="Untitled" /></p>

<h1 id="linking-with-static-libraries">Linking with Static Libraries</h1>

<ul>
  <li>libvector.a</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include "vector.h"
</span><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">addvec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"z = [%d %d]</span><span class="se">\n</span><span class="s">”,z[0], z[1]);</span><span class="err">
</span><span class="s">    return 0;</span><span class="err">
</span><span class="s">}</span><span class="err">
</span><span class="s">main2.c40</span><span class="err">
</span><span class="s">void addvec(int *x, int *y, int *z, int n)</span><span class="err">
</span><span class="s">{</span><span class="err">
</span><span class="s">    int i;</span><span class="err">
</span><span class="s">    for (i = 0; i &lt; n; i++)</span><span class="err">
</span><span class="s">}</span><span class="err">
</span><span class="s">z[i] = x[i] + y[i];</span><span class="err">
</span><span class="s">addvec.c</span><span class="err">
</span><span class="s">void multvec(int *x, int *y, int *z, int n)</span><span class="err">
</span><span class="s">{</span><span class="err">
</span><span class="s">    int i;</span><span class="err">
</span><span class="s">    for (i = 0; i &lt; n; i++)</span><span class="err">
</span><span class="s">        z[i] = x[i] * y[i];</span><span class="err">
</span><span class="s">}</span><span class="err">
</span></code></pre></div></div>

<ul>
  <li>41page - addvec.o는 무엇을 의미하는가:
    <ul>
      <li>Main 함수에서 사용하는 addvec</li>
      <li>다 올리는 게 아니라 archive라는 utility를 통해서 object concatenate하는 건데 addvec만 사용하기에 이거만 빼서 link한다는 의미이다.</li>
    </ul>
  </li>
  <li>static link : 사용되는 object file 100개를 모아두고 archive처럼 code generation할 때 다 모아서 symbol reolution하고 link하는 것임.
    <ul>
      <li>static linking에서 duplication생기는 이유</li>
      <li>똑같이 main함수 생성해서 addvec(x,y,z, 3)을 선언해서 넣었다고 하자.
  이 코드들이 생성될 때 addvec.o가 proc2에 포함되어 있다.
  나중에 또 proc3을 생성할 때에도 addvec.o가 들어가 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="using-static-libraries">Using Static Libraries</h2>

<h3 id="linkers-algorithm-for-resolving-external-references">Linker’s algorithm for resolving external references:</h3>

<ul>
  <li>symbol resolving algorithm : linker가 사용하는 algorithm</li>
  <li>Scan .o files and .a files in the command line order.</li>
  <li>During the scan, keep a list of the current unresolved references.</li>
  <li>As each new .o or .a file, obj, is encountered, try to resolve each unresolved reference in the list against the symbols defined in obj.</li>
  <li>If any entries in the unresolved list at end of scan, then error.</li>
</ul>

<h3 id="problem">Problem:</h3>

<p><img src="https://o.remove.bg/downloads/911ad385-1de8-47ff-9f47-9f0636a7d930/Untitled_19-removebg-preview.png" alt="Untitled" /></p>

<ul>
  <li>Command line order matters!</li>
  <li>
    <p>Moral: put libraries at the end of the command line.unix&gt; gcc -L. libtest.o -lmineunix&gt; gcc -L. -lmine libtest.olibtest.o: In function main’: libtest.o(.text+0x4): undefined reference to libfun’42</p>
  </li>
  <li>Compiler를 통해 example - Gcc -L : object file에서 library에 있는 file을 찾는 것
    <ol>
      <li>Test file + library : test file 안에 선언되어 있는 걸 external reference해서 없으면 library를 ㅁ찾아본다</li>
    </ol>
    <ul>
      <li>Test라는 file obj module안에서 없으면 library안에 있으면 해결되기 때문에
        <ol>
          <li>library + test file 넣으면 error가 뜨게 됨. (reference 안되어 있음)</li>
        </ol>
      </li>
      <li>-lmine에는 있지만 libtest.o에는 없어서 그 다음으로 넘어가야 하는데 그 다음 file이 존재하지 않으므로 error 발생</li>
      <li>command line 순서대로 수행 * order가 되게 중요 → library는 맨 뒤</li>
      <li>scanning하면서 현재 resolve 안된 reference 기록
  그리고 각각에 대해 unresolved reference를 뒤에서 찾아본다 : 있으면 resolve, 없으면 error</li>
    </ul>
  </li>
</ul>

<h1 id="modern-solution-shared-libraries">Modern Solution: Shared Libraries</h1>

<h3 id="static-libraries-have-the-following-disadvantages">Static libraries have the following disadvantages:</h3>

<ul>
  <li>dynamic library = shared library</li>
  <li>Compile time때 static linking을 통한 linking
    <ul>
      <li>지금 돌아가는 executable file이라든지 둘 다 library를 가져다 사용하게 되면 static하게 linking했기 때문에 static이던 running중이던 동일한 file을 본인의 executable에 포함 → 중복된 contents</li>
    </ul>
  </li>
  <li>Duplication in the stored executables (every function needs libc)
    <ul>
      <li>Duplication in the running executables</li>
      <li>Minor bug fixes of system libraries require each application to explicitly relink
        <ul>
          <li>bug 수정 :application 수정하고 linking 다시 해야 함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="modern-solution-shared-libraries-1">Modern solution: Shared Libraries</h3>

<ul>
  <li>Object files that contain code and data that are loaded and linked
해당 library 부분만 수정해서 되는게 아니라 application을 relink시켜 또 다시 link해야 함</li>
  <li>into an application dynamically, at either load-time or run-time
    <ul>
      <li>load time, runtime에 동적으로 shared library가 linking됨</li>
    </ul>
  </li>
  <li>
    <p>Also called: dynamic link libraries, DLLs, .so files43</p>
  </li>
  <li>dynamic library = shared library
    <ul>
      <li>Compile time때 static linking을 통한 linking</li>
      <li>지금 돌아가는 executable file이라든지 둘 다 library를 가져다 사용하게 되면 static하게 linking했기 때문에 static이던 running중이던 동일한 file을 본인의 executable에 포함 → 중복된 contents</li>
      <li>bug 수정 :application 수정하고 linking 다시 해야 함</li>
      <li>해당 library 부분만 수정해서 되는게 아니라 application을 relink시켜 또 다시 link해야 함</li>
      <li>shared: load time, runtime에 동적으로 shared library가 linking됨</li>
    </ul>
  </li>
</ul>

<p>Library를 여러개 dynamically 사용할 수 있어서 shared</p>

<p>Loading time, rumtime이 될 수 있음</p>

<h3 id="dynamic-linking-can-occur-when-executable-is-first-loaded-and-run-load-time-linking">Dynamic linking can occur when executable is first loaded and run (load-time linking).</h3>

<ul>
  <li>Common case for Linux, handled automatically by the dynamic linker (<a href="http://ld-linux.so/">ld-linux.so</a>).</li>
  <li>Standard C library (<a href="http://libc.so/">libc.so</a>) usually dynamically linked.</li>
</ul>

<h3 id="dynamic-linking-can-also-occur-after-program-has-begun-run-time-linking">Dynamic linking can also occur after program has begun (run-time linking).</h3>

<ul>
  <li>In Linux, this is done by calls to the dlopen() interface.</li>
  <li>Distributing software.</li>
  <li>High-performance web servers. Runtime library interpositioning.</li>
</ul>

<h3 id="shared-library-routines-can-be-shared-by-multiple-processes">Shared library routines can be shared by multiple processes.</h3>

<ul>
  <li>More on this when we learn about virtual memory 44</li>
</ul>

<h2 id="dynamic-linking-at-load-time">Dynamic Linking at Load-time</h2>

<p><img src="https://o.remove.bg/downloads/b80de3c1-2553-4188-b5cc-3cb9f16f1c66/Untitled_20-removebg-preview.png" alt="Untitled" /></p>

<ul>
  <li>static link : addvec, multvec library 모두 main2.o에 concatenate했어야 했음</li>
  <li>dynamic link : 사용되는 function 중 main2가 reference하겠다는 note정도만 partly 저장</li>
  <li>그리고 나서 실제 program 실행할 때 library 해당하는 external reference 되어 있는 name들을 resolve하면서 나중에 loading할 때 dynamic linker에 의해 memory에 올라갈 때 비로소 shared library가 이어짐.</li>
</ul>

<p>(둘 다 memory에 load되어 있을 때)</p>

<h2 id="dynamic-linking-at-run-time">Dynamic Linking at Run-time</h2>

<ul>
  <li>dlopen을 사용해서 shaerd library 선언하고 dlsym을 통해 addvec을 pointer로 넘거받음
    <ul>
      <li>그리고 그 함수를 가지고 원래 있는 함수처럼 사용</li>
      <li>code 실행할 때 linking하겠다 : runtime</li>
      <li>필요에 따라 memory에 그 때 그때 옮긴다</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dlfcn.h&gt;
</span><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">addvec</span><span class="p">)(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">error</span><span class="p">;</span>
    <span class="cm">/* Dynamically load the shared library that contains addvec() */</span>
    <span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"./libvector.so"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dlerror</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Get a pointer to the addvec() function we just loaded */</span>
    <span class="n">addvec</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">"addvec"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* Now we can call addvec() just like any other function */</span>
    <span class="n">addvec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"z = [%d %d]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="cm">/* Unload the shared library */</span> 
    
    <span class="k">if</span> <span class="p">(</span><span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dlerror</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="linking-summary">Linking Summary</h2>

<ul>
  <li>Linking is a technique that allows programs to be constructed from multiple object files.-
    <ul>
      <li>여러 개의 object로 하나의 file을 만들 때 사용됨</li>
    </ul>
  </li>
  <li>Linking can happen at different times in a program’s lifetime:
언제 하느냐에 따라 /방법에 따라 여러 많은 error들을 확인하여 resolve할 수 있음
    <ul>
      <li>실제 memory 사용량, 실행 시간 등의 장단점을 구분할 수 있음</li>
      <li>Compile time (when a program is compiled)</li>
      <li>Load time (when a program is loaded into memory)</li>
      <li>Run time (while a program is executing)-</li>
    </ul>
  </li>
  <li>Understanding linking can help you avoid nasty errors and make you a better programmer.</li>
</ul>

<h1 id="7-13-case-study-library-interpositioning">7. 13. Case study: Library interpositioning</h1>

<ul>
  <li><strong>Library interpositioning : powerful linking technique that allows programmers to intercept calls to arbitrary functions</strong></li>
  <li><strong>Interpositioning can occur at:</strong>
    <ul>
      <li>Compile time: When the source code is compiled</li>
      <li>Link time: When the relocatable object files are statically linked to form an executable object file</li>
      <li>Load/run time: When an executable object file is loaded into memory, dynamically linked, and then executed.</li>
    </ul>
  </li>
</ul>

<h2 id="some-interpositioning-applications"><strong>Some Interpositioning Applications</strong></h2>

<ul>
  <li>Security
    <ul>
      <li>Confinement (sandboxing)</li>
      <li>Behind the scenes encryption</li>
    </ul>
  </li>
  <li>Debugging
    <ul>
      <li>In 2014, two Facebook engineers debugged a treacherous 1-year old bug in their iPhone app using interpositioning</li>
      <li>Code in the SPDY networking stack was writing to the wrong location</li>
      <li>Solved by intercepting calls to Posix write functions (write, writev, pwrite)</li>
    </ul>

    <p>Source:  Facebook engineering blog post at https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/</p>
  </li>
  <li>Monitoring and Profiling
    <ul>
      <li>Count number of calls to functions</li>
      <li>Characterize call sites and arguments to functions</li>
      <li>Malloc tracing
        <ul>
          <li>Detecting memory leaks</li>
          <li>Generating address traces52</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Developer가 기존의 function들을 본인의 function으로 intercept하여 실행하고 다시 돌아올 수 있도록 하는 기법</p>

<ol>
  <li>
    <p>Compile time : src code compile 될 때 interpositioning. Malloc함수 자체를 내가 짠 코드로 interpositioning</p>
  </li>
  <li>
    <p>Link time : executable file 만들 때</p>
  </li>
  <li>
    <p>Load, run time : obj file이 load될 때 동적 link</p>
  </li>
</ol>

<h2 id="example-program">Example program</h2>

<p>32byte 할당하여 tracking</p>

<ul>
  <li>compile time에 mymalloc, myfree로 대치</li>
</ul>

<p>지금 배우고 있는 interposition technique</p>

<ul>
  <li>compile, link, loadtime 때 할 수 있다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Goal: trace the addresses and sizes of the allocated and freed blocks, without breaking the program, and without modifying the source code.</li>
  <li>Three solutions: interpose on the lib malloc and free functions at compile time, link time, and load/run time.</li>
</ul>

<h1 id="compile-time-interpositioning">Compile-time Interpositioning</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef COMPILETIME
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
</span>
<span class="cm">/* malloc wrapper function */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mymalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"malloc(%d)=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* free wrapper function */</span>
<span class="kt">void</span> <span class="nf">myfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"free(%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif 
#define malloc(size) mymalloc(size)
#define free(ptr) myfree(ptr)
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mymalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">myfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">linux</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">intc</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">DCOMPILETIME</span> <span class="o">-</span><span class="n">c</span> <span class="n">mymalloc</span><span class="p">.</span><span class="n">c</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">I</span><span class="p">.</span> <span class="o">-</span><span class="n">o</span> <span class="n">intc</span> <span class="kt">int</span><span class="p">.</span><span class="n">c</span> <span class="n">mymalloc</span><span class="p">.</span><span class="n">o</span>
<span class="n">linux</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">runc</span>
<span class="p">.</span><span class="o">/</span><span class="n">intc</span>
<span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="o">=</span><span class="mh">0x1edc010</span>
<span class="n">free</span><span class="p">(</span><span class="mh">0x1edc010</span><span class="p">)</span>
<span class="n">linux</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>mymalloc code</p>

<ul>
  <li>C library에서 제공해 주는 malloc을 사용한 후 그 다음에 무엇을 할 것이냐 : 기존 c library에서 제공하는 malloc을 사용하는 게 아니라 내가 작성한 mymalloc, myfree로 replace (@compile time) -&gt; 즉, 현재 mymalloc은 기존의 malloc의 wrapper함수처럼 쓰여지는데 앞에 있던 코드에서 malloc을 compile time때 mymalloc/myfree으로 대치되어 실행하도록 할 수 있다.</li>
  <li>mymalloc/myfree trace하기 위해서 printf code</li>
</ul>

<p>기존에는 malloc에다 ptr을 가져다가 안에서 mymalloc으로 대치함으로써 실제 malloc을 내부적으로 call하지만 tracing위한 printf 삽입하여 - 어떤 block이 alloc/free되었는지 확인</p>

<p>preprocessing</p>

<ul>
  <li>compilie할 때 내부의 malloc이 mymalloc / free가 myfree로 바뀌어 구동되게 된다.</li>
</ul>

<p>(linux print 결과)</p>

<ul>
  <li>int.c, mymalloc.c 같이 compile</li>
  <li>원래는 아무것도 print하지 않는데 mymalloc, myfree를 통해서 원하는 정보를 tracing할 수 있게 됨. -&gt; 이 주소에다가 우리가 allocate했음을 알고 vm주소를 deallocate했음을 확인할 수 있음</li>
</ul>

<h1 id="link-time-interpositioning">Link-time Interpositioning</h1>

<p>linktime 때 하는 경우 → object를 만들고 Wl option을 주고 —wrap, malloc/free</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef LINKTIME
#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__real_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">__real_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

<span class="cm">/* malloc wrapper function */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__wrap_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">__real_malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="cm">/* Call libc malloc */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"malloc(%d) = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* free wrapper function */</span>
<span class="kt">void</span> <span class="nf">__wrap_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__real_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/* Call libc free */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"free(%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">linux</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">intl</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">DLINKTIME</span> <span class="o">-</span><span class="n">c</span> <span class="n">mymalloc</span><span class="p">.</span><span class="n">c</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="kt">int</span><span class="p">.</span><span class="n">c</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">Wl</span><span class="p">,</span><span class="o">--</span><span class="n">wrap</span><span class="p">,</span><span class="n">malloc</span> <span class="o">-</span><span class="n">Wl</span><span class="p">,</span><span class="o">--</span><span class="n">wrap</span><span class="p">,</span><span class="n">free</span> <span class="o">-</span><span class="n">o</span> <span class="n">intl</span> <span class="kt">int</span><span class="p">.</span><span class="n">o</span> <span class="n">mymalloc</span><span class="p">.</span><span class="n">o</span>
<span class="n">linux</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">runl</span>
<span class="p">.</span><span class="o">/</span><span class="n">intl</span>
<span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x1aa0010</span>
<span class="n">free</span><span class="p">(</span><span class="mh">0x1aa0010</span><span class="p">)</span>
<span class="n">linux</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li><strong>The <code class="language-plaintext highlighter-rouge">-Wl</code> flag passes argument to linker, replacing each comma with a space.</strong>
    <ul>
      <li>-wl flag 자체가 argument를 linker에게 넘겨주어 각각의 comma로 되어 있는 것을 space로 바꾸어 대치하라는 command</li>
    </ul>
  </li>
  <li><strong>The  <code class="language-plaintext highlighter-rouge">--wrap_malloc</code> arg instructs linker to resolve references in a special way:</strong>
    <ul>
      <li>나중에 —wrap,malloc/free를 gcc compiler에게 넘겨줌으로서 linker에 이야기 : reference되어 있는데 Linker에게 gcc compilier가 이런 식으로 resolve하라고 만든다.
        <ul>
          <li>malloc → <code class="language-plaintext highlighter-rouge">wrap malloc</code></li>
          <li><code class="language-plaintext highlighter-rouge">Real malloc</code> → malloc</li>
        </ul>
      </li>
      <li>Refs to malloc should be resolved as __wrap_malloc</li>
      <li>Refs to   __real_malloc should be resolved as malloc</li>
    </ul>
  </li>
</ul>

<p>→ link time에 그 값을 가져다 reserve한 다음 원하는 대로 interposition</p>

<h1 id="loadrun-time-interpositioning"><strong>Load/Run-time Interpositioning</strong></h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef RUNTIME
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dlfcn.h&gt;
</span>
<span class="cm">/* malloc wrapper function */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mallocp</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>

    <span class="n">mallocp</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">"malloc"</span><span class="p">);</span> <span class="cm">/* Get addr of libc malloc */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">mallocp</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="cm">/* Call libc malloc */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"malloc(%d) = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* free wrapper function */</span>
<span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">freep</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">freep</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">"free"</span><span class="p">);</span> <span class="cm">/* Get address of libc free */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">freep</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/* Call libc free */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"free(%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>&lt;Load/runtime interpositioning&gt;</p>

<ul>
  <li>dlsym : Library malloc의 address를 받아오기 위함</li>
  <li>mallocp(size) : malloc이라는 wrapper 함수와 free라는 wrapper 함수가 있는데 나중에 동적으로 malloc이라는 wrapper함수에서 동적으로 malloc이 호출되는 그 순간에 malloc의 ptr address를 return하고 이를 가지고 print하게 하는 방법</li>
  <li>동적으로 interpositioning을 malloc./ free
    <ul>
      <li>동일하게 free함수 호출했을 때 address를 받아오고 free를 한다음 printf를 통해 ptr값에 해당하는 heap에 있는 address 공간을 free</li>
    </ul>
  </li>
  <li>The <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> environment variable tells the dynamic linker to resolve unresolved refs (e.g., to malloc) by looking in mymalloc.so first.
    <ul>
      <li>‘LD Preload 환경 변수’를 통해 내가 찾고자 하는 함수를 code 안에서 찾을 수 있음.</li>
      <li>순차적으로 찾고 동적으로 실행되는 그 때, 앞에 print하고자 하는 value들과 size를 print하고 free하며 끝남</li>
      <li>환경 변수가 dynamic link에게 mymalloc.so file (shared library)를 찾아보고 malloc으로 대체할 수 있도록 하는 역할을 수행함</li>
    </ul>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">linux</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">intr</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">DRUNTIME</span> <span class="o">-</span><span class="n">shared</span> <span class="o">-</span><span class="n">fpic</span> <span class="o">-</span><span class="n">o</span> <span class="n">mymalloc</span><span class="p">.</span><span class="n">so</span> <span class="n">mymalloc</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">ldl</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">o</span> <span class="n">intr</span> <span class="kt">int</span><span class="p">.</span><span class="n">c</span>
<span class="n">linux</span><span class="o">&gt;</span> <span class="n">make</span> <span class="n">runr</span>
<span class="p">(</span><span class="n">LD_PRELOAD</span><span class="o">=</span><span class="s">"./mymalloc.so"</span> <span class="p">.</span><span class="o">/</span><span class="n">intr</span><span class="p">)</span>
<span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xe60010</span>
<span class="n">free</span><span class="p">(</span><span class="mh">0xe60010</span><span class="p">)</span>
<span class="n">linux</span><span class="o">&gt;</span>
</code></pre></div></div>

<h1 id="interpositioning-recap"><strong>Interpositioning Recap</strong></h1>

<ul>
  <li><strong>Compile Time</strong>
    <ul>
      <li>compile time : macro 확장처럼 mymalloc</li>
      <li>Apparent calls to malloc/free get macro-expanded into calls to mymalloc/myfree</li>
    </ul>
  </li>
  <li><strong>Link Time</strong>
    <ul>
      <li>link time : linker에게 trick을 불러 이름 resolution을 바꾸어 준다</li>
      <li>Use linker trick to have special name resolutions</li>
      <li>malloc → <code class="language-plaintext highlighter-rouge">__wrap_malloc</code></li>
      <li><code class="language-plaintext highlighter-rouge">__real_malloc</code> → malloc</li>
    </ul>
  </li>
  <li><strong>Load/Run Time</strong>
    <ul>
      <li>load/run time : dynamic linking을 통해서 실제 malloc, free를 다른 이름으로 load할 때 대치하게 함으로서 원하는 interpositioning을 수행할 수 있음</li>
      <li>Implement custom version of malloc/free that use dynamic linking to load library malloc/free under different names</li>
    </ul>
  </li>
</ul>

<p>→ 세 가지 방법 중 load/runtime, compile time때 많이 수행. 물론 compile의 경우 preprocess 단계에서 내 것으로 가로채기 할 수 있으나 다 같이 compile해야 하는 문제점</p>

<ul>
  <li>load/runtime의 경우에는 이에 반해 따로 compile할 필요 없고, so file을 찾도록 하여 내가 작성한 함수로 interpositioning 기술을 적용할 수 있다</li>
</ul>
