<h2 id="queues-chapter-33">Queues (Chapter 3.3)</h2>

<h3 id="definition-of-queue">Definition of Queue</h3>

<ul>
  <li>Similar to stack, queue is a specialized type of an ordered list.</li>
  <li>One end is called front.</li>
  <li>The other end is called rear (or back).</li>
  <li>Additions are done at the rear only.</li>
  <li>Removals are made from the front only.</li>
</ul>

<h3 id="queue-analogy">Queue: analogy</h3>

<ul>
  <li>Bus stop
    <ul>
      <li>Elements are removed from the front of the queue.</li>
      <li>Removing an element from a queue is called “dequeueing”.</li>
      <li>Elements are removed from the front of the queue.</li>
      <li>Removing an element from a queue is called “dequeueing”.</li>
      <li>New elements are inserted from the rear (back) of the queue.</li>
      <li>Inserting a new element into the queue is called “enqueueing”.</li>
    </ul>
  </li>
  <li>Job scheduling in operating systems
    <ul>
      <li>non-priority scheduling: jobs are processed in the order they enter the system (FIFO behavior)</li>
      <li>The operating system maintains a job queue in order to schedule jobs.</li>
    </ul>
  </li>
</ul>

<h3 id="queue-fifo-behavior">Queue: FIFO behavior</h3>

<ul>
  <li>For a queue, the first element inserted to the queue is removed first.</li>
  <li>This type of behavior is called FIFO (First-In-First-Out).</li>
</ul>

<p><img width="426" alt="image-20211003161735276" src="https://user-images.githubusercontent.com/46957634/135751121-c49b2f14-7b45-4ea0-b9a4-5cbde6c17a55.png" /></p>

<h3 id="queue-abstract-data-type">Queue: Abstract Data Type</h3>

<script src="https://gist.github.com/underthelights/4f557a13f93840d19090b0575f65628a.js"></script>

<h3 id="queue-implementation">Queue: implementation</h3>

<ul>
  <li>We can use a one-dimensional array to represent a queue.</li>
  <li>We use two variables, front and rear, to indicate their positions in the array.
    <ul>
      <li>front points to the previous index of the first element.</li>
      <li>If the first element is queue[0], then front is -1. Front is initialized to -1.</li>
      <li>rear points to the index of the last element.</li>
      <li>Initially, when the queue is empty, rear is initialized to -1.</li>
    </ul>
  </li>
</ul>

<script src="https://gist.github.com/underthelights/56e502184ee377ad214f6133df87b6f0.js"></script>

<h4 id="queue-implementation-using-an-arrayex020">Queue: implementation using an array[ex020]</h4>

<ul>
  <li>Adding an element to the queue
    <ul>
      <li>rear is incremented.</li>
      <li>Then, the new element is stored at <code class="language-plaintext highlighter-rouge">queue[rear]</code>.</li>
    </ul>
  </li>
</ul>

<script src="https://gist.github.com/underthelights/f8935bd4d64599681424aeddcc2917ec.js"></script>

<ul>
  <li>Deleting an element from the queue
    <ul>
      <li>front is incremented.</li>
      <li>Then, <code class="language-plaintext highlighter-rouge">queue[front]</code> is returned.</li>
    </ul>
  </li>
</ul>

<script src="https://gist.github.com/underthelights/5ae1359242920c51d720de81aabf29fe.js"></script>

<ul>
  <li>Behavior of the queue implemented from an array
    <ul>
      <li>Whenever a new element is inserted, rear moves to the right.</li>
      <li>Whenever an element is deleted, front moves to the right.</li>
    </ul>
  </li>
</ul>

<p><img width="308" alt="image-20211003162024038" src="https://user-images.githubusercontent.com/46957634/135751153-25d7a3ca-1b20-4e9b-a359-edfce2955ad5.png" /></p>

<ul>
  <li>
    <p>The array has a limited capacity, so rear will eventually move to the last index.</p>

    <ul>
      <li>
        <p>rear becomes equal to <code class="language-plaintext highlighter-rouge">MAX_QUEUE_SIZE - 1</code>.</p>
      </li>
      <li>
        <p>In this case, we need to reorganize the array in order to obtain spaces for newer</p>

        <p>elementse.</p>
      </li>
      <li>
        <p>This is done by calling <code class="language-plaintext highlighter-rouge">queueFull()</code>;</p>

        <ul>
          <li>If the queue is truly full, then an error will occur because we cannot insert more elements to the queue.</li>
          <li>If the queue has available spaces at the left of front, we should move the elements in the queue to the left to get more space for new elements.</li>
          <li>The worst-case time complexity of queueFull is O(MAX_QUEUE_SIZE). In order to avoid this, a circular array is used.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="queue-implementation-using-a-circular-array">Queue: implementation using a circular array</h4>

<ul>
  <li>Still using a one-dimension array, we can configure the array as a circular array.</li>
</ul>

<p><img width="308" alt="image-20211003162109716" src="https://user-images.githubusercontent.com/46957634/135751154-6c8a2913-95f9-4c92-b6ac-7dfe4b985c74.png" /></p>

<ul>
  <li>If the array holds three elements, following are the possible states of the array.</li>
</ul>

<p><img width="381" alt="image-20211003162905958" src="https://user-images.githubusercontent.com/46957634/135751165-b5a924c6-0fb6-41b2-9cfd-8568e921c3ef.png" /></p>

<ul>
  <li>Use integer variables front and rear.
    <ul>
      <li>front is one position counterclockwise from the first element</li>
      <li>rear is the position of the last element</li>
    </ul>
  </li>
</ul>

<p><img width="477" alt="image-20211003162946542" src="https://user-images.githubusercontent.com/46957634/135751166-7de4509b-749c-4f68-a070-261620aa0404.png" /></p>

<ul>
  <li>Adding an element
    <ul>
      <li>Move rear one position clockwise.</li>
      <li>Then put the new element into queue[rear].</li>
    </ul>
  </li>
</ul>

<p><img width="477" alt="image-20211003163014525" src="https://user-images.githubusercontent.com/46957634/135751167-d1b08927-f3e8-49a4-87a0-f1b4aed4e148.png" /></p>

<ul>
  <li>Removing an element
    <ul>
      <li>Move front one position clockwise.</li>
      <li>Then extract the element from queue[front].</li>
    </ul>
  </li>
</ul>

<p><img width="477" alt="image-20211003163031951" src="https://user-images.githubusercontent.com/46957634/135751169-d2ffea2c-1a6c-43eb-96a5-da914fbe2581.png" /></p>

<ul>
  <li>Moving rear one position clockwise
    <ul>
      <li>capacity is the number of element spaces in the circular array.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rear</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">rear</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">)</span> <span class="n">rear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p><img width="357" alt="image-20211003163055181" src="https://user-images.githubusercontent.com/46957634/135751171-fc6fc56f-ea85-48ba-8372-ef3a5d01d625.png" /></p>

<ul>
  <li>Let us empty the queue.
    <ul>
      <li>initial state</li>
    </ul>
  </li>
</ul>

<p><img width="357" alt="image-20211003163110142" src="https://user-images.githubusercontent.com/46957634/135751173-b346f059-7b3b-4d5f-8b72-628002cf432f.png" /></p>

<ul>
  <li>Let us empty the queue.
    <ul>
      <li>A is removed from the queue.</li>
    </ul>
  </li>
</ul>

<p><img width="357" alt="image-20211003163134909" src="https://user-images.githubusercontent.com/46957634/135751174-c0938a78-0a76-4dda-b23f-5fa1f161cf24.png" /></p>

<ul>
  <li>Let us empty the queue.
    <ul>
      <li>B is removed from the queue.</li>
    </ul>
  </li>
</ul>

<p><img width="357" alt="image-20211003163142069" src="https://user-images.githubusercontent.com/46957634/135751175-3e40794c-88db-4baf-8542-cdea2b0058c7.png" /></p>

<ul>
  <li>Let us empty the queue.
    <ul>
      <li>C is removed from the queue. Now the queue is empty.</li>
    </ul>
  </li>
  <li>When the queue is empty, front == rear.</li>
  <li>When we initialize the circular array, we set front = rear = 0.</li>
</ul>

<p><img width="357" alt="image-20211003163201959" src="https://user-images.githubusercontent.com/46957634/135751176-f886ae06-10a1-4525-aec4-4d112b2cbdd2.png" /></p>

<ul>
  <li>This time, let us make the queue full.
    <ul>
      <li>initial state</li>
    </ul>
  </li>
</ul>

<p><img width="357" alt="image-20211003163219600" src="https://user-images.githubusercontent.com/46957634/135751177-cbd34121-c1d4-4d15-97b0-23c18f1b7c3c.png" /></p>

<ul>
  <li>This time, let us make the queue full.
    <ul>
      <li>D is inserted to the queue.</li>
    </ul>
  </li>
</ul>

<p><img width="357" alt="image-20211003163230177" src="https://user-images.githubusercontent.com/46957634/135751178-a2fcde0e-a837-4568-ae24-f82d3c9bbc82.png" /></p>

<ul>
  <li>This time, let us make the queue full.
    <ul>
      <li>E is inserted into the queue.</li>
    </ul>
  </li>
</ul>

<p><img width="357" alt="image-20211003163245171" src="https://user-images.githubusercontent.com/46957634/135751179-e56d86b2-ba41-41bb-a0f3-307b3a8e0c35.png" /></p>

<ul>
  <li>This time, let us make the queue full.
    <ul>
      <li>F is inserted into the queue.</li>
    </ul>
  </li>
  <li>When the queue is full, front == rear.</li>
  <li>We cannot distinguish between a full queue and an empty queue!</li>
</ul>

<p><img width="357" alt="image-20211003163308541" src="https://user-images.githubusercontent.com/46957634/135751181-1c7acedc-7f42-4ab1-93db-b68bc236d51d.png" /></p>

<ul>
  <li>Problem when using a circular array
    <ul>
      <li>If(front==rear), we do not know whether the queue is full or empty.</li>
    </ul>
  </li>
  <li>
    <p>Solutions</p>

    <ul>
      <li>Do not let the queue get full.
        <ul>
          <li>When the addition of an element will make the queue full, increase the size.</li>
        </ul>
      </li>
      <li>Define a Boolean variable last Operation Is AddQ.
        <ul>
          <li>Following each AddQ set this variable to true.</li>
          <li>Following each DeleteQ set this variable to false.</li>
          <li>Queue is empty iff (front == rear) &amp;&amp; !lastOperationIsAddQ</li>
          <li>Queue is full iff (front == rear) &amp;&amp; lastOperationIsAddQ</li>
        </ul>
      </li>
      <li>Define an integer variable size.
        <ul>
          <li>Following each <code class="language-plaintext highlighter-rouge">AddQ</code> do size++.</li>
          <li>Following each <code class="language-plaintext highlighter-rouge">DeleteQ</code> do size–.</li>
          <li>Queue is empty iff (size == 0).</li>
          <li>Queue is full iff (size == arrayLength).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Adding an element to a queue using a circular array &amp; Deleting an element from a queue using a circular array [ex021]</li>
</ul>

<script src="https://gist.github.com/underthelights/64a9f7dac97a99325c267f4eca0aa6e4.js"></script>

<ul>
  <li>What are the time complexity of addq() and deleteq() when a circular array is used?</li>
</ul>
