<h1 id="11-dynamic-memory-allocation-advanced-concepts">11. Dynamic Memory Allocation: Advanced Concepts</h1>

<p>Dynamic Memory Allocation: Advanced Concepts
CSE4100: System Programming
Youngjae Kim (PhD)</p>

<h1 id="explicit-free-list">Explicit Free List</h1>

<h2 id="keeping-track-of-free-blocks">Keeping Track of Free Blocks</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250565-ac3869e2-da0c-4be1-b3af-adc475406ac0.png" alt="Untitled" /></p>

<ol>
  <li>forward traverse : 모든 것을 scan하여 뒤져야 free block을 찾을 수 있음
    <ul>
      <li>adv ) spatial : 4/5만큼을 사용 가능</li>
      <li>free block을 찾기 위해 모두 뒤져 정책에 찾아 free block</li>
    </ul>
  </li>
  <li>explicit free list : Size가 아니라 word를 가져다 다음의 free block을 가리키는 방법
    <ul>
      <li>adv) linear search할 때 method2 : allocated block skip 가능해서 빠름</li>
      <li>disadv ) successor에 해당하는 3/5만큼을 사용 가능</li>
    </ul>
  </li>
  <li>Class 마다 linked list로 연결 - 굉장히 빠르게 가장 fit할수 있는 block을 빠르게 찾을 수 있는 기법.</li>
  <li>크기에 따라 븐류한 block</li>
</ol>

<h2 id="explicit-free-lists">Explicit Free Lists</h2>

<ul>
  <li>Header, footer : coleascing - 앞과 뒤</li>
  <li>successor- precedesor : Explicit한 방법으로 free list 관리 가능.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250541-cc1a1234-4ff3-4a01-84dc-3d2d54266bb4.png" alt="Untitled 1" /></p>

<ul>
  <li>Maintain list(s) of free blocks, not all blocks</li>
  <li>The “next” free block could be anywhere
    <ul>
      <li>So we need to store forward/back pointers, not just sizes</li>
    </ul>
  </li>
  <li>Still need boundary tags for coalescing</li>
  <li>Luckily we track only free blocks, so we can use payload area
    <ul>
      <li>lucky하게도 free list만 관리 가능 → payload 영역 사용의 단점</li>
    </ul>
  </li>
  <li>
    <p>Logically:</p>

    <p><img src="https://user-images.githubusercontent.com/46957634/183250543-3c37791d-6df9-4761-9fc1-a71b8e9077bb.png" alt="Untitled 2" /></p>
  </li>
  <li>
    <p>Physically: blocks can be in any order AB</p>

    <p><img src="https://user-images.githubusercontent.com/46957634/183250544-bcff06cf-4911-4310-8aac-a54af677344f.png" alt="Untitled 3" /></p>
  </li>
</ul>

<h2 id="allocating-from-explicit-free-lists">Allocating From Explicit Free Lists</h2>

<p>Doubly linked list로 연결되어있다고 하자 :</p>

<p>회색 해당한 만큼을 allocate → free list에 있을 필요 없으므로 split하고 남은 block과 연결해줌</p>

<ul>
  <li>ptr update를 통해 앞에서부터/뒤에서부터 연결, splitting</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250545-2022205c-8314-46d1-965e-0e57b96c7253.png" alt="Untitled 4" />
<img src="https://user-images.githubusercontent.com/46957634/183250546-830d5698-ee74-4192-821b-afb910431cac.png" alt="Untitled 5" /></p>

<h2 id="freeing-with-explicit-free-lists">Freeing With Explicit Free Lists</h2>

<ul>
  <li>Insertion policy: Where in the free list do you put a newly freed block?</li>
  <li>복잡 : free list를 관리해야 하는데 가져다 return하게 되면 insertion해야 하는데 그 policy
    <ul>
      <li>→ search time overhead가 큼</li>
    </ul>
  </li>
  <li>LIFO (last-in-first-out) policy
    <ul>
      <li>Insert freed block at the beginning of the free list
  맨 앞에다 free block을 가져다 연결시켜줌</li>
      <li>Pro: simple and constant time</li>
      <li>Con: studies suggest fragmentation is worse than address ordered</li>
    </ul>
  </li>
  <li>Address-ordered policy
    <ul>
      <li>Insert freed blocks so that free list blocks are always in address order:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">addr(prev) &lt; addr(curr) &lt; addr(next)</code></li>
        </ul>
      </li>
      <li>Con: requires search</li>
      <li>Pro: studies suggest fragmentation is lower than LIFO</li>
    </ul>

    <ol>
      <li>Address ordered policy</li>
    </ol>

    <ul>
      <li>insert되는 block들이 작은 주소부터 높은 주소 순으로 sorting</li>
    </ul>

    <p>→ addr ordered 방법보다 fragmentation 경감</p>

    <ul>
      <li>실제 allocation할 때 어떤 block을 allocation하느냐를 Allocation해야 하기 때문에, address에 따라 순서대로 search하며 선택해야 하는 문제가 있음</li>
    </ul>
  </li>
</ul>

<h2 id="freeing-with-a-lifo-policy-case-1">Freeing With a LIFO Policy (Case 1)</h2>

<ul>
  <li>다른 free한 block을 가리킨다고 하자.</li>
  <li>block이 memory상 어딘가 존재할 것 : 앞 뒤에 있는 것을 header-footer 방법을 통해 조사함
    <ul>
      <li>→ 앞뒤 allocated면 생각보다 간단하게</li>
    </ul>
  </li>
  <li>header 다음 next에 해당하는 ptr를 다음을 가르키게 함</li>
  <li>즉) 앞 뒤가 allocate되면 상대적으로 simple</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250547-86a49701-2cb3-4f13-adbd-f228c10031dd.png" alt="Untitled 6" /></p>
<ul>
  <li>Insert the freed block at the root of the list</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250548-84b4789c-51db-48df-9bb0-0455744db2cf.png" alt="Untitled 7" /></p>

<h2 id="freeing-with-a-lifo-policy-case-2">Freeing With a LIFO Policy (Case 2)</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250549-5a5a37be-3428-4447-9fad-3dd33d44c8b0.png" alt="Untitled 8" /></p>
<ul>
  <li>Splice out successor block, coalesce both memory blocks and insert the new block at the root of the list</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250550-7d5a0d16-235f-4ac5-b9c9-58506696bc24.png" alt="Untitled 9" /></p>

<h2 id="freeing-with-a-lifo-policy-case-3">Freeing With a LIFO Policy (Case 3)</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250551-e7e6cc94-674b-4b8a-8d8b-f0b3e2bc5a93.png" alt="Untitled 10" /></p>

<ul>
  <li>Splice out predecessor block, coalesce both memory blocks, and insert the new block at the root of the list</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250552-d0c372e8-b278-4dfe-bd92-041b8c72da05.png" alt="Untitled 11" /></p>

<h2 id="freeing-with-a-lifo-policy-case-4">Freeing With a LIFO Policy (Case 4)</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250553-339ab294-d05a-4c72-a009-f8cd920791c8.png" alt="Untitled 12" /></p>
<ul>
  <li>Splice out predecessor and successor blocks, coalesce all 3 memory blocks and insert the new block at the root of the list</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250555-5eed307d-3aea-4fd6-b294-c1801c450510.png" alt="Untitled 13" /></p>

<h2 id="explicit-list-summary">Explicit List Summary</h2>

<p>모든 block을 뒤지지 않아 좀 더 빠른 속도를 가지지만 좀 복잡함 : free state 관리 구현</p>

<ul>
  <li>
    <p>block의 크기가 최소 5word 이상이어야 함</p>
  </li>
  <li>Comparison to implicit list:
    <ul>
      <li>Allocate is linear time in number of free blocks instead of all blocks
        <ul>
          <li>Much faster when most of the memory is full</li>
        </ul>
      </li>
      <li>Slightly more complicated allocate and free since needs to splice blocks in and out of the list</li>
      <li>Some extra space for the links (2 extra words needed for each block)
        <ul>
          <li>Does this increase internal fragmentation?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Most common use of linked lists is in conjunction with segregated free lists
Free block들을 ptr로 연결하여 ll로 관리함
    <ul>
      <li>Keep multiple linked lists of different size classes, or possibly for different types of objects</li>
      <li>LIFO queue</li>
      <li>
        <p>단점 : free block을 link했지만 각 block 크기 가변적</p>

        <p>→ fragmentation이 작은 block을 찾으려면 best fit policy에 따라 처음부터 끝까지 뒤져봐야 함.</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="segregated-free-list">Segregated Free List</h1>

<ul>
  <li>
    <p>어떻게 segregate : n개의 size class를 만들어 n개의 free block을 안에다 집합</p>

    <p>→ 다른 크기의 size class에 따라서 각각 다른 free list 관리하는 기법</p>
  </li>
</ul>

<h2 id="segregated-list-seglist-allocators">Segregated List (Seglist) Allocators</h2>

<p><img src="https://user-images.githubusercontent.com/46957634/183250556-ac77cc52-d485-4694-8d35-9ec524df9eab.png" alt="Untitled 14" /></p>

<ul>
  <li>Each size class of blocks has its own free list</li>
  <li>Often have separate classes for each small size</li>
  <li>For larger sizes: One class for each two-power size</li>
  <li>
    <p>이전 explicit free list : 하나의 단일 lifo queue</p>

    <p>→ 지금 : 각각의 size을 가지는 list</p>
  </li>
  <li>장점 : best fit - fragmentation 최소화할 수 있는 block을 찾았다면 여기서는 class 별 로 나누었기에 내게 맞는 class를 찾을 수 있는 기법</li>
</ul>

<h2 id="seglist-allocator">Seglist Allocator</h2>

<p>malloc(n)</p>

<p>새롭게 요청된 메모리로부터 n개의 byte block 할당.</p>

<p><img src="https://user-images.githubusercontent.com/46957634/183250557-735f8779-2d07-426c-8743-257fb607ec07.png" alt="Untitled 15" /></p>

<ul>
  <li>Given an array of free lists, each one for some size class</li>
  <li>To allocate a block of size n:
    <ul>
      <li>Search appropriate free list for block of size m &gt; n
  처음부터 찾는다 : m&gt;n인 m의 크기를 가진 free list를 찾는다
        <ul>
          <li>
            <p>ex. malloc(4)라고 하면 4를 수용하는 block을 가진 class를 찾음</p>

            <p>→ block이 있는 경우는 block할당, 나머지 frag는 집어넣음</p>

            <ul>
              <li>
                <p>malloc(6)을 요청했다면 5-8 class에서 할당받는다.</p>

                <p>→ 8 size block 중 나머지 2개는 1-2class로 이동한다.</p>
              </li>
            </ul>

            <p>(구현 별 문제 : 나머지 fragment를 어떻게 처리할 것인가. 앞에다 붙이는게 빠를수도 있다 (LIFO니까))</p>
          </li>
          <li>
            <p>m payload, n 실제 class의 size
  Payload를 고려하는 것에 따라 m&gt;=n</p>
          </li>
        </ul>
      </li>
      <li>If an appropriate block is found:
        <ul>
          <li>Split block and place fragment on appropriate list (optional)</li>
        </ul>
      </li>
      <li>If no block is found, try next larger class
  만일 block size가 없다면 더 큰 class로 이동</li>
      <li>Repeat until block is found</li>
    </ul>
  </li>
  <li>If no block is found:
    <ul>
      <li>Request additional heap memory from OS (using sbrk())</li>
      <li>Allocate block of n bytes from this new memory</li>
      <li>Place remainder as a single free block in largest size class.</li>
    </ul>
  </li>
  <li>To free a block:
    <ul>
      <li>Coalesce and place on appropriate list
        <ul>
          <li>block의 free : 앞, 뒤를 보고 coalesce</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Advantages of seglist allocators
    <ul>
      <li><strong>Higher throughput) malloc을 할 때 성능이 좋다</strong>
        <ul>
          <li>log time for power-of-two size classes</li>
          <li>size class로 나뉘어져 있기에 fragmentation을 최소화하면서 적합한 class를 빨리 찾을 수 있다.</li>
        </ul>
      </li>
      <li><strong>Better memory utilization</strong>
        <ul>
          <li>First-fit search of segregated free list approximates a best-fit search of entire heap.
            <ul>
              <li>앞에서부터 찾더라도 나보다도 큰 공간이지만 나중에 보니 fragmentation을 최소화할 수 있는 block이 있을 수도 있다.</li>
            </ul>
          </li>
          <li>Extreme case: Giving each block its own size class is equivalent to best-fit.
            <ul>
              <li>모든 각각의 block마다 size class를 두고 나서 best fit 해당할수도 있으나 class를 너무 많이 뽑아야 함.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li></li>
</ul>

<h2 id="more-info-on-allocators">More Info on Allocators</h2>

<ul>
  <li>D. Knuth, “The Art of Computer Programming”, 2nd edition, Addison Wesley, 1973
    <ul>
      <li>The classic reference on dynamic storage allocation</li>
    </ul>
  </li>
  <li>Wilson et al, “Dynamic Storage Allocation: A Survey and Critical Review”, Proc. 1995 Int’l Workshop on Memory Management, Kinross, Scotland, Sept, 1995.
    <ul>
      <li>Comprehensive survey</li>
    </ul>
  </li>
</ul>

<h1 id="garbage-collection">Garbage collection</h1>

<h2 id="implicit-memory-management-garbage-collection">Implicit Memory Management: Garbage Collection</h2>

<p>integer pointer</p>

<ul>
  <li>int type 128 byte (32 * 4byte) (heap에 할당)</li>
  <li>stack에 할당 (local variable)</li>
  <li>address space를 보면</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250558-cde4e620-f813-4bdd-b01d-4839b66dc4a6.png" alt="Untitled 16" /></p>

<p>실제 사용하지 않는 공간임에도 불구하고 자리를 차지함</p>

<ul>
  <li>garbage collection : 자동으로 heap에 할당된 storage들에 대한 reclamation</li>
  <li>
    <p>Garbage collection: automatic reclamation of heap-allocated storage—application never has to free</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  		<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">128</span><span class="p">);</span>
  		<span class="k">return</span><span class="p">;</span> <span class="cm">/** p block is now garbage */</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Common in many dynamic languages:
    <ul>
      <li>Python, Ruby, Java, Perl, ML, Lisp, Mathematica</li>
    </ul>
  </li>
  <li>Variants (“conservative” garbage collectors) exist for C and C++
    <ul>
      <li>However, cannot necessarily collect all garbage</li>
    </ul>
  </li>
</ul>

<h2 id="garbage-collection-1">Garbage Collection</h2>

<p>c에서의 garbage collection 구현의 어려움</p>

<ul>
  <li>How does the memory manager know when memory can be freed?
내가 할당한 memory allocation이 runtime시에 언제 free될 것이냐
    <ul>
      <li>In general we cannot know what is going to be used in the future since it depends on conditionals</li>
      <li>But we can tell that certain blocks cannot be used if there are no pointers to them</li>
      <li>= program이 어떻게 실행될지 execution order를 정확히 모르면 모른다.
  그러나 적어도, heap에 할당된 memory object를 point하는 ptr가 없다면 해당 allocated block은 사용되지 않는다.</li>
    </ul>

    <p>(point하는 ptr가 없으니까 나중에 garbage collect해도 되는구나)</p>
  </li>
  <li>
    <p>Must make certain assumptions about pointers</p>

    <ol>
      <li>memory int type에 있는 변수 안의 값이 ptr 일수도 아닐수도 있다.</li>
    </ol>

    <ul>
      <li>Memory manager can distinguish pointers from non-pointers</li>
      <li>ptr 는 다른 memory obj를 가리키는 address일수도, int일수도 있으나 이를 구분할 방법은 c에서는 없음.</li>
      <li>memory manager가 할 수 있다고 가정</li>
    </ul>

    <ol>
      <li>어떤 block이든간에 시작을 point함</li>
    </ol>

    <ul>
      <li>All pointers point to the start of a block</li>
    </ul>

    <ol>
      <li>type casting같이 ptr 숨김을 못한다.</li>
    </ol>

    <ul>
      <li>Cannot hide pointers</li>
      <li>(e.g., by coercing them to an int, and then back again)</li>
    </ul>
  </li>
</ul>

<h2 id="classical-gc-algorithms">Classical GC Algorithms</h2>

<ul>
  <li>Mark-and-sweep collection (McCarthy, 1960)
    <ul>
      <li>Does not move blocks (unless you also “compact”)</li>
    </ul>
  </li>
  <li>Reference counting (Collins, 1960)
    <ul>
      <li>Does not move blocks (not discussed)</li>
    </ul>
  </li>
  <li>Copying collection (Minsky, 1963)
    <ul>
      <li>Moves blocks (not discussed)</li>
    </ul>
  </li>
  <li>Generational Collectors (Lieberman and Hewitt, 1983)
    <ul>
      <li>Collection based on lifetimes
        <ul>
          <li>Most allocations become garbage very soon</li>
          <li>So focus reclamation work on zones of memory recently allocated</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>For more information:
    <ul>
      <li>Jones and Lin, “Garbage Collection: Algorithms for Automatic Dynamic Memory”, John Wiley &amp; Sons, 1996. Bryant and O’Hallaron, Computer Systems: A Programmer’s Perspective, Third Edition</li>
    </ul>
  </li>
</ul>

<h2 id="memory-as-a-graph">Memory as a Graph</h2>

<p>grapy로 표현 : heap memory object로 만든 direct graph</p>

<ul>
  <li>어떤 ds를 만들었는데 heap 안에 있는 object를 stack밖에서 point하는 경우
    <ul>
      <li>root node는 heap 안에 있는 것을 가리키는 형상</li>
    </ul>
  </li>
  <li>direct graph :
    <ul>
      <li>모종의 자료구조로 인해 binary tree를 heap 안에서 만들었다고 하면 Root로부터 시작하여 heap 안의 object를 point하는 direct graph</li>
    </ul>
  </li>
  <li>어느 순간에 가게 되면 외부에서 가리키는 ptr이 없어지는 경우도 존재.</li>
  <li>
    <p>ex. heap에는 이미 할당되어 있지만 함수가 return되며 point하는 local var이 사라짐</p>

    <p>→ not-reachable garbage 생성</p>

    <p>heap node는 이런식으로 tree로 표현되지만 실제로는 1dim array : 어떤 부분은 free하고 어떤 부분은 allocated, 어떤 부분은 reachable-not reachable</p>
  </li>
  <li>
    <p>식별할 수 있다면 reachable하지 않는 놈들을 free하면 됨 : mark and sweep algorithm</p>
  </li>
  <li>We view memory as a directed graph
    <ul>
      <li>Each block is a node in the graph /  Each pointer is an edge in the graph</li>
      <li>Locations not in the heap that contain pointers into the heap are called root nodes (e.g. registers, locations on the stack, global variables)</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250560-33aae708-6659-4ad2-870a-adaea0832354.png" alt="Untitled 17" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- A node (block) is reachable if there is a path from any root to that node.
- Non-reachable nodes are garbage (cannot be needed by the application)
</code></pre></div></div>

<h2 id="mark-and-sweep-collecting">Mark and Sweep Collecting</h2>

<ul>
  <li>Can build on top of malloc/free package
    <ul>
      <li>Allocate using malloc until you “run out of space”</li>
      <li>malloc을 지속한다 : 공간이 없을 때까지
        <ul>
          <li>공간이 없다 = sbrk를 써서 계속 확장하더라도 malloc이 잘 안되는 경우 memory 공간이 없음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>When out of space:</p>

    <ul>
      <li>Use extra mark bit in the head of each block
        <ul>
          <li>Header에다가 extra bit를 가져가 mark한다</li>
          <li>mark : 앞서 root에 해당하는 녀석을 인자로 돌려 reachable한 녀석들을 dfs하여 mark bit set</li>
        </ul>
      </li>
      <li>Mark: Start at roots and set mark bit on each reachable block
        <ul>
          <li>
            <p>Recursively Mark를 수행하며 각 block에 reachable한 경우에 한하여 mark해줌</p>

            <p>→ not reachable은 allocated되어 있지만 mark bit이 set되어있지 않음</p>
          </li>
        </ul>
      </li>
      <li>Sweep: Scan all blocks and free blocks that are not marked root
        <ul>
          <li>1dim 평면의 array의 처음부터 끝 brk까지 scan하며 mark되지 않은 block에 대하여 free</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250561-e9c12e80-a4dd-4cfe-9abb-f34eec6039d5.png" alt="Untitled 18" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Before mark - free list를 pt하는게 아닌 application 관점에서 앞서의 tree를 구현
- after mark - rechable한 경우 mark bit을 setting해줌
- after sweep - not rechable 들은 free를 해줌 (allocated but not marked)
</code></pre></div></div>

<h2 id="assumptions-for-a-simple-implementation">Assumptions For a Simple Implementation</h2>

<ul>
  <li>Application
    <ul>
      <li><code class="language-plaintext highlighter-rouge">new(n)</code>: returns pointer to new block with all locations cleared
        <ul>
          <li>New(n) : heap memory obj를 할당하고 ptr를 return</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">read(b,i)</code>: read location i of block b into register
        <ul>
          <li>Read(), block b에서 i번째에 해당하는 값을 읽어 register에 집어넣음</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">write(b,i,v)</code>: write v into location i of block b
        <ul>
          <li>write(b,i,v) : block b의 i번째에 v를 쓴다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Each block will have a header word
앞에는 header word가 있다고 가정하고 collector를 구현하자.
    <ul>
      <li>addressed as b[-1], for a block b</li>
      <li>Used for different purposes in different collectors</li>
    </ul>
  </li>
  <li>functions/Instructions used by the Garbage Collector
    <ul>
      <li><code class="language-plaintext highlighter-rouge">is_ptr(p)</code>: determines whether p is a pointer
  p가 ptr인지 int인지 구분할 수 없지만 구분된다고 가정하자.</li>
      <li><code class="language-plaintext highlighter-rouge">length(b)</code>: returns the length of block b, not including the header 
  block b에서의 header를 제외한 word개수</li>
      <li><code class="language-plaintext highlighter-rouge">get_roots()</code>: returns all the roots</li>
    </ul>
  </li>
</ul>

<h2 id="mark-and-sweep-cont">Mark and Sweep (cont.)</h2>

<ul>
  <li>Mark using depth-first traversal of the memory graph
    <ul>
      <li>depth-first traversal : Heap node들은 mark bit가 setting되어있지 않기에 ptr인지 아닌지 체크
        <ul>
          <li>→ ptr 아니었다면 return, ptr라면 밑으로</li>
          <li>markbit set</li>
        </ul>
      </li>
      <li>P의 크기만큼을 보면서 p[i]를 recursive하게 돌아감 → 초록tordls reachable obj에 대해 mark해줌</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptr</span> <span class="nf">mark</span><span class="p">(</span><span class="n">ptr</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// do nothing if not pointer</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">markBitSet</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>                     <span class="c1">// check if already marked</span>
    <span class="n">setMarkBit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>                  <span class="c1">// set the mark bit</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// call mark on all words</span>
<span class="p">}</span>
<span class="n">mark</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// in the block return;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Sweep using lengths to find next block</p>

    <p>P (시작) end (breakpoint(</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptr</span> <span class="nf">sweep</span><span class="p">(</span><span class="n">ptr</span> <span class="n">p</span><span class="p">,</span> <span class="n">ptr</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">markBitSet</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">clearMarkBit</span><span class="p">();</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">allocateBitSet</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="conservative-mark--sweep-in-c">Conservative Mark &amp; Sweep in C</h2>

<p>c 언어 상 p가 가리키는 것이 memory block 중 ptr block, int block일 수 있음</p>

<ul>
  <li>memory value type를 저장하지 않기에 우리는 구분 불가능했던 것</li>
  <li>구현 방법 : block에서 left/right해서 있는 값은 무조건 ptr라고 하고
    <ul>
      <li>balenced bt를 만들어 point하여 allocate block을 따라가 mark and sweep한다.</li>
      <li>→ conservative하게 정확하게 구분할 수는 없지만 어느정도 determine 한다라고 가정</li>
    </ul>
  </li>
</ul>

<p>실제 가리키는게 not allocated이지만 allocated라고 가정해놓고 point</p>

<ul>
  <li>A “conservative garbage collector” for C programs
    <ul>
      <li><code class="language-plaintext highlighter-rouge">is_ptr()</code> determines if a word is a pointer by checking if it points to an allocated block of memory</li>
      <li>But, in C pointers can point to the middle of a block</li>
    </ul>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250562-260b8044-c534-4ebf-ab04-6e74c1a5960a.png" alt="Untitled 19" /></p>

<ul>
  <li>So how to find the beginning of the block?
    <ul>
      <li>Can use a balanced binary tree to keep track of all allocated blocks (key is start-of-block)</li>
      <li>Balanced-tree pointers can be stored in header (use two additional words)</li>
    </ul>
  </li>
  <li>
    <p>Left: smaller addresses  / Right: larger addresses</p>

    <p>(Left / right)를 통해 balanced bt를 구축하게 됏을 때 left가 alloc 안되어 있지만 되어 있다는 block이라고 하면 garbage collection할 때 memory leak이 발생하기는 하나 구현할 수는 있다.</p>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/46957634/183250563-549eb897-75ea-41b6-8edd-4b4c67c36591.png" alt="Untitled 20" /></p>

<h1 id="memory-related-perils-and-pitfalls">Memory-related perils and pitfalls</h1>

<h2 id="memory-related-perils-and-pitfalls-1">Memory-Related Perils and Pitfalls</h2>

<ul>
  <li>Dereferencing bad pointers</li>
  <li>Reading uninitialized memory</li>
  <li>Overwriting memory</li>
  <li>Referencing nonexistent variables</li>
  <li>Freeing blocks multiple times</li>
  <li>Referencing freed blocks</li>
  <li>Failing to free blocks</li>
</ul>

<h2 id="dereferencing-bad-pointers">Dereferencing Bad Pointers</h2>

<ul>
  <li>The classic scanf bug</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">scanf</span><span class="p">(</span><span class="err">“</span><span class="o">%</span><span class="n">d</span><span class="err">”</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="reading-uninitialized-memory">Reading Uninitialized Memory</h2>

<ul>
  <li>Assuming that heap data is initialized to zero</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* return y = Ax */</span>
<span class="kt">int</span> <span class="o">*</span><span class="nf">matvec</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Nsizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="overwriting-memory">Overwriting Memory</h2>

<ul>
  <li>Allocating the (possibly) wrong sized object</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Nsizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Msizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Off-by-one error</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Msizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Not checking the max string size</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">gets</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="cm">/* reads “123456789” from stdin */</span>
</code></pre></div></div>

<ul>
  <li>Basis for classic buffer overflow attacks</li>
  <li>Misunderstanding pointer arithmetic</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="nf">search</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Referencing a pointer instead of the object it points to</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="nf">BinheapDelete</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="n">binheap</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="n">binheap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">binheap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">binheap</span><span class="p">[</span><span class="o">*</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="o">*</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="n">Heapify</span><span class="p">(</span><span class="n">binheap</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">packet</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="referencing-nonexistent-variables">Referencing Nonexistent Variables</h2>

<ul>
  <li>Forgetting that local variables disappear when a function returns</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="nf">foo</span> <span class="p">()</span> 
<span class="p">{</span>
		<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="freeing-blocks-multiple-times">Freeing Blocks Multiple Times</h2>

<ul>
  <li>Nasty!</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">// &lt;manipulate x&gt;</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">// &lt;manipulate y&gt;</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="referencing-freed-blocks">Referencing Freed Blocks</h2>

<ul>
  <li>Evil!</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Nsizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">// &lt;manipulate x&gt; </span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">...</span> 

<span class="n">y</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Msizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="failing-to-free-blocks-memory-leaks">Failing to Free Blocks (Memory Leaks)</h2>

<ul>
  <li>Slow, long-term killer!</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">Nsizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">...</span> <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Freeing only part of a data structure</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">list</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list</span><span class="p">));</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="c1">// &lt;create and manipulate the rest of the list&gt;</span>
<span class="p">...</span> <span class="n">free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="dealing-with-memory-bugs">Dealing With Memory Bugs</h2>

<ul>
  <li>Debugger:gdb
    <ul>
      <li>Good for finding bad pointer dereferences  Hard to detect the other memory bugs</li>
    </ul>
  </li>
  <li>Data structure consistency checker
    <ul>
      <li>Runs silently, prints message only on error  Use as a probe to zero in on error</li>
    </ul>
  </li>
  <li>Binary translator: valgrind
    <ul>
      <li>Powerful debugging and analysis technique</li>
      <li>Rewrites text section of executable object file</li>
      <li>Checks each individual reference at runtime</li>
      <li>Bad pointers, overwrites, refs outside of allocated block</li>
    </ul>
  </li>
  <li>glibc malloc contains checking code
    <ul>
      <li><code class="language-plaintext highlighter-rouge">setenv MALLOC_CHECK_ 3</code></li>
    </ul>
  </li>
</ul>
