<!DOCTYPE html>
<html lang="en"><head>
  
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
         TeX: {
         equationNumbers: {
             autoNumber: "AMS"
         }
         },
         tex2jax: {
         inlineMath: [ ['$', '$'] ],
         displayMath: [ ['$$', '$$'] ],
         processEscapes: true,
     }
     });
     MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
         alert("Math Processing Error: "+message[1]);
         });
     MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
         alert("Math Processing Error: "+message[1]);
         });
     </script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>[ALG] 1. Introduction ✱ Kyuhwan Shim</title>

  <link rel="stylesheet" href="/assets/css/style.css">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800&family=Noto+Sans+TC&display=swap" rel="stylesheet">

  <link href="/assets/fontawesome/all.min.css" rel="stylesheet">

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>

  <!-- GA -->
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VG8LB4J4EL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VG8LB4J4EL');
</script>


  <!-- favicon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/main/favicon/favicon.ico">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/main/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/main/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/main/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/main/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/main/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/main/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/main/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/main/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/main/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/main/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/main/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/images/main/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/main/favicon/favicon-16x16.png">
  <link rel="manifest" href="">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/images/main/favicon/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <!-- Opengraph -->
  <meta property="og:type" content="website">
  <meta property="og:image" content="/assets/images/main/favicon/og.png%5BALG%5D-1.-Introduction.jpg">
  <meta property="og:title" content="[ALG] 1. Introduction | Kyuhwan Shim">
  <meta property="og:description" content="Paper overview of  et al., ">

  <!-- Google scholar -->
  
  <meta name="citation_title" content="[ALG] 1. Introduction">
  
  <meta name="citation_publication_date" content="">
  
  <meta name="citation_conference_title" content="">
  
  <meta name="citation_pdf_url" content="https://underthelights.github.io/assets/pdf/[ALG]-1.-Introduction.pdf">
  
</head>
<body><header class="page-content">
  <nav class="navbar navbar-expand-md navbar-light py-4">
    <div class="container-fluid">
      <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse" data-bs-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
        <ul class="navbar-nav ms-auto mt-4 mt-lg-0 navbar-nav-scroll">
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/news">News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/project">Project</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/oconnect">oconnect</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/cv">CV</a>
          </li>
          <li class="nav-item dropdown">
              <a href="#" class="nav-link dropdown-toggle " data-bs-toggle="dropdown">fun</a>
              <div class="dropdown-menu">
                  <a href="/music" class="dropdown-item">music</a>
                  <a href="/artwork" class="dropdown-item">artwork</a>
              </div>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" target="_blank" rel="noopener noreferrer" href="https://underthelights.github.io/blog/">Blog<i class="fa-regular fa-arrow-up-right-from-square" style="padding-left: 5px;"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
</header>

<style>
  .dropdown-toggle {
    background-color: transparent;
    border-color: #fff;
    border-style: solid;
    border-top: none;
    border-right: none;
    border-left: none;
    transition: color .15s ease-in-out, background-color .15s ease-in-out,border-color .15s ease-in-out;
  }
  .dropdown-toggle:hover {
    font-weight: 500
  }
  .dropdown:hover .dropdown-menu {
    display: block;
    margin-top: 0;
 }
 .dropdown-menu {
    --bs-dropdown-border-radius: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important
 }
 .dropdown-item {
  font-size: .95rem !important;
  padding: .3rem .75rem !important;
 }
 .dropdown-item:active {
  background-color: #999 !important
 }
</style><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <style>
  /* General styling for all headings */
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: 'Arial', sans-serif;
    /* Use a modern font */
    margin-top: 20px;
    margin-bottom: 10px;
  }
  .post-title {
    font-size: 2em; /* 폰트 크기 증가 */
    font-weight: bold; /* 볼드체 */
    color: #333; /* 색상 변경 */
    /* background-color: #f8f8f8; 배경색 추가 */
    padding: 10px; /* 배경색과 함께 패딩 추가 */
    box-shadow: inset 0 -20px 0 #bbb7e8;
    max-width: max-content;
  }

  /* Updated styling for h1 */
  h1 {
    font-size: 1.5em;
    /* Increase font size for main titles */
    color: #333333;
    border-bottom: none;
    /* Remove bottom border */
    padding-bottom: 0;
    /* Adjust padding if needed */
  }

  h2 {
    font-size: 1.2em;
    color: #4a4a4a;
  }

  h3 {
    font-size: 1.1em;
    color: #6a6a6a;
  }

  h4 {
    font-size: 0.75em;
    color: #888888;
  }

  h5 {
    font-size: 0.5em;
    color: #a6a6a6;
  }

  h6 {
    font-size: 1em;
    color: #bcbcbc;
  }

  /* Add some additional styling if needed */
  .post-content {
    line-height: 1.6;
    /* Improve readability */
    color: #333333;
    /* Dark grey color for text */
  }

  /* Styling for the ToC to make it scroll with the page */
  .toc {
    font-size: 1em;
    position: fixed;
    /* Fixed position */
    right: 0;
    /* Align to the right side of the screen */
    top: 50;
    /* Adjust this value as needed based on your header size */
    max-height: 100vh;
    /* Set maximum height to viewport height */
    overflow-y: auto;
    /* Allows scrolling within the ToC if it's too long */
    padding: 20px;
    /* Add some padding */
    background-color: white;
    /* Optional: background color for visibility */
    z-index: 1000;
    /* To ensure it stays on top of other elements */
    width: 250px;
    /* Adjust the width as needed */
  }
</style>



<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="toc">
    <a href="#">&lt;On the Top&gt;</a>
    <ul><li><a href="#10-computational-thinking"><strong>1.0. Computational Thinking</strong></a><ul><li><a href="#definition-of-computational-thinking"><strong>Definition of computational thinking</strong></a></li><li><a href="#characteristics-of-computational-thinking"><strong>Characteristics of computational thinking</strong></a></li><li><a href="#problem-solving-in-computer-science-and-engineering"><strong>Problem Solving in Computer Science and Engineering</strong></a></li><li><a href="#problem-solving-pipeline"><strong>Problem Solving Pipeline</strong></a></li></ul></li><li><a href="#도강-문제"><strong>도강 문제</strong></a><ul><li><a href="#문제-분석"><strong>문제 분석</strong></a></li><li><a href="#해법-고안"><strong>해법 고안</strong></a></li></ul></li><li><a href="#구현---programming-is-an-art"><strong>구현 : ✓ Programming is an art!</strong></a></li><li><a href="#data-structure--algorithm--theory-of-computation"><strong>Data Structure → Algorithm → Theory of Computation</strong></a></li><li><a href="#11---12-solve-with-alg"><strong>1.1 - 1.2 Solve with Alg</strong></a></li><li><a href="#1-how-to-think-and-solve-problems-with-computer"><strong>1. How to think and solve problems with computer</strong></a><ul><li><a href="#data-structurealgorithmtheory-of-computation"><strong>Data Structure→Algorithm→Theory of Computation</strong></a></li></ul></li><li><a href="#2-def-of-algorithm"><strong>2. Def. of Algorithm</strong></a><ul><li><a href="#definition-of-algorithm"><strong>Definition of Algorithm</strong></a></li><li><a href="#thoughts-on-4-finiteness-computability"><strong>Thoughts on 4) Finiteness: [Computability]</strong></a></li><li><a href="#thoughts-on-efficiency-complexity"><strong>Thoughts on Efficiency: [Complexity]</strong></a></li><li><a href="#efficient-algorithm-design"><strong>Efficient Algorithm Design</strong></a></li></ul></li><li><a href="#alg-13-order-of-algorithms-1">[ALG] 1.3. Order of Algorithms (1)</a></li><li><a href="#obigonotation"><em>O</em> (Big $O$ Notation)</a><ul><li><a href="#notes-for-big-o">Notes for big O</a></li><li><a href="#comparing-orders-of-growth">Comparing Orders of Growth</a></li></ul></li><li><a href="#ωbig-omega-notation">$Ω$ (Big Omega Notation)</a></li><li><a href="#θbig-theta-notation">$Θ$ (Big Theta Notation)</a></li><li><a href="#big-o-omega-and-order">Big O, Omega, and Order</a><ul><li><a href="#execution-times-for-algorithms-with-the-given-time-complexities">Execution Times for Algorithms with the Given Time Complexities</a></li></ul></li><li><a href="#worst-case-vs-average-case-time-complexity">Worst-Case vs. Average-Case Time Complexity</a></li><li><a href="#reviews">Reviews</a><ul><li><a href="#summation">Summation</a></li><li><a href="#run-time-analysis">Run Time Analysis</a></li></ul></li><li><a href="#alg-14-mss-1">[ALG] 1.4. MSS (1)</a></li><li><a href="#maximum-subsequence-sum-mss-problem">Maximum Subsequence Sum (MSS) Problem</a></li><li><a href="#alg-of-maximum-subsequence-sum">Alg of Maximum Subsequence Sum</a></li><li><a href="#mss-1---simple-counting">MSS 1 - simple counting</a></li><li><a href="#mss-2">MSS 2</a></li><li><a href="#mss--3--divide-n-conquer">MSS  3 : Divide n Conquer</a></li><li><a href="#mss--4-kadanes-algorithm">MSS  4; Kadane’s algorithm</a><ul><li><a href="#so-why-do-we-bother-with-the-time-complexity">So, why do we bother with the time complexity?</a></li></ul></li></ul></li><li><a href="#alg-15-maximum-sum-subrectangle-in-2d-array-1">[ALG] 1.5. Maximum Sum Subrectangle in 2D Array (1)</a></li><li><a href="#maximum-sum-subrectangle-in-2d-array">Maximum Sum Subrectangle in 2D Array</a><ul><li><a href="#a-naïve-approach">A Naïve Approach</a></li><li><a href="#mss--summed-area-table">MSS : Summed Area Table</a><ul><li><a href="#maximum-sum-subrectangle-kadane-algo-based">Maximum Sum Subrectangle: Kadane Algo.-Based</a></li></ul></li><li><a href="#mathematical-induction--proof-of-correctness">Mathematical Induction &amp; Proof of Correctness</a></li></ul></li></ul>

  </div>

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[ALG] 1. Introduction</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-09-02T00:00:00+09:00" itemprop="datePublished">
        Sep 2, 2022
      </time></p>
    <!-- 태그와 카테고리 표시 -->
    <div class="post-categories">
      
      <strong><span>📚 Categories:</span></strong>
      
      <a href="blog-categories-notes">Notes</a>
      
      
    </div>

    <div class="post-tags">
      
      <strong><span>🏷️ Tags:</span></strong>
      
      <a href="blog-tags-algorithm">Algorithm</a>
      
      
    </div>


  </header>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Algorithm : Big O and MSS</p>

<h1 id="10-computational-thinking"><strong>1.0. Computational Thinking</strong></h1>

<h2 id="definition-of-computational-thinking"><strong>Definition of computational thinking</strong></h2>

<p>The thought processes involved in (i) formulating a problem and (ii) expressing its solutions in such a way that a computer –human or machine- can effectively carry out.</p>

<ol>
  <li>Problem formulation (abstraction)</li>
  <li>Solution expression (automation)</li>
  <li>Solution execution &amp; evaluation (analyses)</li>
</ol>

<h2 id="characteristics-of-computational-thinking"><strong>Characteristics of computational thinking</strong></h2>

<ul>
  <li>Formulating problems in a way that enables us to use a computer and other tools to help solve them</li>
  <li>Logically organizing and analyzing data → Data structure</li>
  <li>Representing data though abstractions such as models and simulations → Data Structure</li>
  <li>Automating solutions through algorithmic thinking (a series of ordered steps) → Algorithm</li>
  <li>Identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and effective combination of steps and resources → time and space complexity</li>
  <li>Generalizing and transferring the problem solving process to a wide variety of problems</li>
</ul>

<h2 id="problem-solving-in-computer-science-and-engineering"><strong>Problem Solving in Computer Science and Engineering</strong></h2>

<p>문 제 (Problem) → 해 (Solution)</p>

<ul>
  <li>Problem : 가상 현실, 문서작성, 홈뱅킹, 인터넷 신문, 문서 번역, 회로 설계, 유전자 분석, 무인 자동차, 온라인 게임, 비디오 편집, 자료 검색, 영화 제작, 음성 인식, 가상 수술, 건축 설계, 기상 예측, 주가 예측, 인공 지능, 대용량 과학 계산, …</li>
</ul>

<h2 id="problem-solving-pipeline"><strong>Problem Solving Pipeline</strong></h2>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/0.png" alt="0" /></p>

<h1 id="도강-문제"><strong>도강 문제</strong></h1>

<p>한 어부(M)가 늑대(W), 염소(G), 양배추(C)를 강 한 쪽에서 다른 쪽으로 옮기려 한다. 어부가 배를 타고 강을 건널 때 어부 자신 외에 늑대, 염 소, 양배추 중 하나만 배에 가지고 갈 수가 있는데, 문제는 어부가 늑대 를 싣고 가는 동안, 염소가 양배추를 같은 쪽에 남겨두면 염소가 양배 추를 먹어버리게 되고, 양배추를 싣고 갈 때 늑대와 염소를 같은 쪽에 남겨둘 경우 늑대가 염소를 잡아 먹게 된다. 과연 어떻게 하면 어부가 가장 적은 회수로 강을 건너면서 세 가지를 모두 안전하게 옮길 수 있을까?</p>

<h2 id="문제-분석"><strong>문제 분석</strong></h2>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/1.png" alt="1" /></p>

<ul>
  <li></li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/2.png" alt="2" /></p>

<h2 id="해법-고안"><strong>해법 고안</strong></h2>

<ul>
  <li>Graph, search, and so on → Which data structures and algorithms?</li>
  <li>Cost, time, space, and so on → What complexities?</li>
</ul>

<p>[연습] 이 문제에 대한 알고리즘과 시간/공간 복잡도를 컴퓨터학의 용 어를 써서 기술한다면, ???</p>

<ul>
  <li>무슨 말인지 전혀 모르겠으면 [43-080 자료구조]를 재수강한 후 이 과목을 들을 것!</li>
</ul>

<h1 id="구현---programming-is-an-art"><strong>구현 : ✓ Programming is an art!</strong></h1>

<ul>
  <li>어떻게 하면 주어진 알고리즘을 가장 효과적으로 구현을 할 수 있을까?</li>
  <li>어떻게 하면 C/C++를 사용하여 주어진 알고리즘을 가장 최적으로 구현할 수 있을까?
    <ul>
      <li>원시 코드 레벨의 측면</li>
      <li>어셈블러 레벨의 측면</li>
      <li>시스템 레벨의 측면</li>
      <li>기타</li>
    </ul>
  </li>
  <li>✓ 과연 내가 <a href="http://acm.uva.es/problemset/%EC%97%90">http://acm.uva.es/problemset/에</a> 있는 문제들을 스스로 “문제 분석 → 해법 고안 → 구현” 과정을 통하여 효과적으로 해결할 수 있을까???
    <ul>
      <li>Programming Challenges by S. Skiena and M. Revilla, Springer, 2003.</li>
    </ul>
  </li>
  <li>어떻게 하면 좋은 구현 결과를 얻을 수 있는가?
    <ul>
      <li>동일한 프로세서 상에서 더 빠르게</li>
      <li>적은 메모리만 사용하게</li>
      <li>안정적이게</li>
    </ul>
  </li>
  <li>
    <p>구현 예</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/3.png" alt="3" /></p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/4.png" alt="4" /></p>
  </li>
</ul>

<p>19 0.265968초 4.862961초 3.4GHz Intel Core i7 CPU</p>

<h1 id="data-structure--algorithm--theory-of-computation"><strong>Data Structure → Algorithm → Theory of Computation</strong></h1>

<ul>
  <li>어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?
    <ol>
      <li>[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?</li>
      <li>[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까?</li>
      <li>[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?</li>
      <li>[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결할 수 있을까?</li>
    </ol>
  </li>
  <li>✓ 이 과목에서는 [CSE3080 자료구조] 과목에 이어, 1번과 2번을 집중적으로 살펴보 고, 3번 문제에 대하여 어느 정도 살펴볼 예정임.</li>
  <li>4번 문제는 [CSE3085 자동장치이론] 과목에서 다룸.</li>
</ul>

<h1 id="11---12-solve-with-alg"><strong>1.1 - 1.2 Solve with Alg</strong></h1>

<h1 id="1-how-to-think-and-solve-problems-with-computer"><strong>1. How to think and solve problems with computer</strong></h1>

<h2 id="data-structurealgorithmtheory-of-computation"><strong>Data Structure→Algorithm→Theory of Computation</strong></h2>

<ul>
  <li>어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?
    <ol>
      <li>[Data Structure] 주어진 추상적인 문제를 <strong>어떠한 자료 구조</strong>를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?</li>
      <li>[Algorithm] 주어진 추상적인 문제를 어떠한 <strong>알고리즘을</strong> 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까</li>
      <li>[Complexity] 과연 컴퓨터가 주어진 문제를 <strong>효율적으로</strong> 해결할 수 있을까 ?</li>
      <li>[Computability] 과연 컴퓨터가 세상의 <strong>모든 문제를 해결</strong>할 수 있을까?</li>
    </ol>
  </li>
  <li>Data Structure &amp; Algorithm → 1, 2, 3</li>
  <li>Automata Theory → 4</li>
</ul>

<h1 id="2-def-of-algorithm"><strong>2. Def. of Algorithm</strong></h1>

<h2 id="definition-of-algorithm"><strong>Definition of Algorithm</strong></h2>

<p>from [Horowitz 1.2]</p>

<ul>
  <li>An <strong>algorithm</strong> is a <strong>finite set of instructions that</strong>, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:
    <ol>
      <li><strong>Input</strong>.
        <ul>
          <li>Zero or more quantities from the outside.</li>
          <li>외부로부터 0개 이상의 수량이 입력으로서 들어온다.</li>
        </ul>
      </li>
      <li><strong>Output</strong>.
        <ul>
          <li>At least one quantity is produced.</li>
          <li>하나 이상의 결과값이 수행된다.</li>
        </ul>
      </li>
      <li><strong>Definiteness</strong>.
        <ul>
          <li>Each instruction is clear and unambiguous.</li>
          <li>각 지침은 모두 명확하며, 애매하게 쓰여 있지 않다.</li>
        </ul>
      </li>
      <li><strong>Finiteness</strong>.
        <ul>
          <li>If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.</li>
          <li>제한된 수의 단계 후 종료된다.</li>
        </ul>
      </li>
      <li><strong>Effectiveness</strong>.
        <ul>
          <li>Every instruction must be basic enough to be carried out, in principle, by a person using only pencil and paper.</li>
          <li>손으로 풀 수 있을 만큼 효과적이어야 한다.</li>
          <li>It is not enough that each operation be definite as in (3);</li>
          <li>it also must be feasible. 또한 실현 가능하여야 한다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="thoughts-on-4-finiteness-computability"><strong>Thoughts on 4) Finiteness: [Computability]</strong></h2>

<ul>
  <li>Problem (<a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Post’s correspondence problem</a> 포스트 대응 문제)
    <ul>
      <li>결정 불가능한 결정 문제의 예시, 1946년 emil post 에 의해 고안</li>
      <li>Consider a finite set <em>P</em> of ordered pairs of nonempty strings such as <em>P</em>={(<em>a</em>,<em>ab</em>),(<em>b</em>,<em>c__a</em>),(<em>c__a</em>,<em>a</em>),(<em>ab__c</em>,<em>c</em>)}</li>
      <li>A match of <em>P</em> is any string w such that, for some <em>m</em>&gt;0 and some pairs (<em>u_1,_v_1),(_u_2,_v_2),…,(_u__m</em>,<em>v__m</em>)∈<em>P</em>, <em>w</em>=<em>u_1_u_2…_u__m</em>=<em>v_1_v_2…_v__m</em>.</li>
      <li>Design an algorithm that determine, given P, whether P has a match.</li>
    </ul>
  </li>
  <li>
    <p>Cheolsu’s algorithm</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">For</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">...</span> <span class="k">do</span>
    <span class="n">For</span> <span class="n">each</span> <span class="n">permutation</span> <span class="n">of</span> <span class="n">P</span> <span class="n">of</span> <span class="n">length</span> <span class="n">i</span><span class="p">,</span> <span class="k">do</span>
      <span class="n">If</span> <span class="n">it</span> <span class="n">is</span> <span class="n">a</span> <span class="n">match</span><span class="p">,</span> <span class="n">print</span> <span class="err">‘</span><span class="n">yes</span><span class="err">’</span> <span class="n">and</span> <span class="n">exit</span><span class="p">.</span>
      <span class="n">If</span> <span class="n">not</span><span class="p">,</span> <span class="k">continue</span><span class="p">.</span>
	
</code></pre></div>    </div>

    <ul>
      <li>Can this be regarded as an algorithm?</li>
    </ul>
  </li>
</ul>

<h2 id="thoughts-on-efficiency-complexity"><strong>Thoughts on Efficiency: [Complexity]</strong></h2>

<ul>
  <li><strong>An algorithm is regarded as efficient or good</strong> if there exist a polynomial <em>P</em>(<em>n</em>) such that the time required for solving any instance of size <em>n</em> is bounded above by <em>P</em>(<em>n</em>).</li>
  <li>NP-Complete problems:
    <ul>
      <li>Nobody has found so far any good algorithm for any problem in this class.</li>
      <li>It has been proved that if a good algorithm exists for some algorithm in this class, then a good algorithm exists for all NP-Complete Problem.</li>
    </ul>
  </li>
  <li>Examples
    <ul>
      <li>Suppose a CD-ROM can store up to 720MBytes of data. You have a sequence of n files of sizes <em>s_1,_s_2,…,_s__n</em> Mbytes, to dump into backup CDs. What is the minimum number of necessary CDs to store all the files?</li>
      <li>Consider n tasks to be executed on CPU. All the tasks must be finished within the time requirement L (seconds). If the <em>i_th task takes _s__i</em> seconds, and you can harness multiple processors, what would be the minimum number of processors needed to accomplish this?</li>
      <li>Ex. <em>L</em>=10, <em>n</em>=6, and $(s_1, s_2, s_3, s_4, s_5, s_6) = (5, 6, 3, 7, 5, 4) $</li>
      <li>then (5,5),(6,4),(7,3)</li>
    </ul>
  </li>
</ul>

<p>어떻게 하면 좀 더 “효율적으로” 문제를 해결할까?</p>

<h2 id="efficient-algorithm-design"><strong>Efficient Algorithm Design</strong></h2>

<p><strong>Example 1</strong></p>

<ul>
  <li>Sequential search vs binary search
    <ul>
      <li>Problem: Determine whether <em>x</em> is in the sorted array <em>S</em> of <em>n</em> keys.</li>
      <li>Inputs: positive integer <em>n</em>, sorted (nondecreasing order) arrays of keys S indexed from 0 to <em>n</em>−1, a key <em>x</em>.</li>
      <li>Outputs: the location of <em>x</em>∈<em>S</em> (−1 if <em>x</em>∈/<em>S</em>).</li>
    </ul>
  </li>
  <li>Sequential search: <em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
  <li>Binary search: <em>T</em>(<em>n</em>)=<em>O</em>(<em>l__o__g__n</em>)</li>
  <li>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/5.png" alt="5" /></p>

    <ul>
      <li>[From Neapolitan] The number of comparisons done by Sequential &amp; Binary Search when <em>x</em> is larger than all the array items
        <ul>
          <li>40억 개의 element가 array에 있을 때, Sequential Search는 40억 개 항목과 비교하는 반면에 Binary Search는 단 33개의 항목만을 비교한다.</li>
          <li>컴퓨터가 1ns에 whlie loop를 통과할 수 있다고 가정한들 Binary search는 즉각적으로 결정을 내리는 반면 Sequential Search는 4s가 걸린다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why is the binary search more efficient? 왜 이진검색이 더 효율적인가?</li>
</ul>

<p><strong>Example 2:The Fibonacci Sequence</strong></p>

<ul>
  <li>Problem: Determine the _n_th term in the Fibonacci sequence.</li>
  <li>Inputs: a nonnegative integer <em>n</em></li>
  <li>
    <p>Outputs: the nth term of the Fibonacci sequence.</p>

    <p><em>f_0=0_f_1=1_f__n</em>=<em>f__n</em>−1+<em>f__n</em>−2 for <em>n</em>≥2</p>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//&lt;recursive: divide-and-conquer&gt;</span>
<span class="kt">int</span> <span class="nf">fib</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//&lt;iterative: dynamic programming&gt;</span>
  <span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">index</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="n">n</span><span class="p">];</span>
  <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  	<span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
  <span class="p">}</span><span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></div></div>

<ul>
  <li>Recursive: $T(n) = O(2^n) $</li>
  <li>Iterative: <em>T</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
  <li>Why is the iterative version more efficient?
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/6.png" alt="6" /></p>
      </li>
      <li><em>T</em>(<em>n</em>)&gt;22<em>n</em> for <em>n</em>≥2</li>
      <li>Mathematical induction을 써서 증명해볼 것!</li>
    </ul>
  </li>
  <li>Linear versus exponential
    <ul>
      <li>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/7.png" alt="7" /></p>
      </li>
      <li>[From Neapolitan] This table compares these expressions for various values of n. The execution times are based on the simplifying assumption that one term can be computed in 10−9 second.</li>
      <li>The table shows the time it would take ‘Iterative Algorithm’ to compute the nth term on a hypothetical computer that could compute each term in a nanosecond, and it shows a lower bound on the time it would take to execute ‘Iterative Algorithm’.</li>
      <li>By the time n is 80, ‘Recursive Algorithm’ takes at least 18 minutes. When n is 120, it takes more than 36 years, an amount of time intolerable compared with a human life span. Even if we could build a computer one billion times as fast, ‘Recursive Algorithm’ would take over 40,000 years to compute the 200th term. This result can be obtained by dividing the time for the 200th term by one billion.</li>
      <li>We see that regardless of how fast computers become, ‘Recursive Algorithm’ will still take an intolerable amount of time unless n is small. On the other hand, ‘Iterative Algorithm’ computes the nth Fibonacci term almost instantaneously.</li>
    </ul>

    <p>This comparison shows why the efficiency of an algorithm remains an important consideration regardless of how fast computers become</p>
  </li>
</ul>

<h1 id="alg-13-order-of-algorithms-1">[ALG] 1.3. Order of Algorithms (1)</h1>

<ul>
  <li>제일 먼저 생각
    <ul>
      <li>Input Size
        <ul>
          <li>Problem을 풀고자 하는데 이를 sol하고자 하는 algorithm에서, 알고리즘에 들어오는 data의 크기는 어떻게 되는가.
            <ul>
              <li>문제 상황에 따라 가로 n, 세로 m의 데이터가 들어오면 (n,m) n일수도 nm일수도 있다.</li>
            </ul>
          </li>
          <li>data size가 커짐에 따라 얼마나 시간이 걸리는가 분석 : 얼마난 크기의 데이터가 들어왔을 때, 얼마나 시간이 걸리는가.</li>
          <li>시간 분석의 기본 요소 : data의 수</li>
        </ul>
      </li>
      <li>Cost : $g(n)$
        <ul>
          <li>문제가 있을 때 n에 대하여 어느 정도의 비용이 걸리는가.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="obigonotation"><em>O</em> (Big $O$ Notation)</h1>

<blockquote>
  <p>💡 for given two functions $f(n)$ and $g(n)$,</p>

  <p>$g(n) = O(f(n))\iff \exists c \in \mathbb{R}, N \in \mathbb{N}\quad g(n)\leq c\cdot f(n), \forall n \geq N$</p>
</blockquote>

<ul>
  <li>complexity를 따질 때, data size가 작을 때 보다는 커질 때 문제가 발생함을 확인하고 싶음.
    <ul>
      <li>→ 모든 n일 필요는 없고, 그 N보다 큰 모든 input size에 대해서 이러한 조건을 만족하면.</li>
    </ul>
  </li>
  <li>then we say that :$g(n)$ is big O of $f(n)$</li>
  <li>예)
    <ul>
      <li>코드의 비용을 분석해 봤더니
        <ul>
          <li>for loop 1, for loop n 자승만큼 돌게 된다.</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>비용 : $g(n) = c_0 + c_1 n + c_2 n^2$</li>
  <li>예 : $g(n) = 5 + 6 + 7n^2 \leq 8n^2 \quad \forall n \geq 8$
    <ul>
      <li>$8 \cdot n^2 = c \cdot f(n), N = 8$
        <ul>
          <li>n이 커지면 g(n)이 압도적으로 다른 친구들을 누르게 된다.</li>
          <li>다시한번 이야기하지만, n이 커질 때, 내가 분석한 비용은 f(n)이라는 함수에 눌리게 되는 upper bound 개념</li>
        </ul>
      </li>
      <li>$g(n) = O(n^2)$</li>
    </ul>
  </li>
  <li>$g(n) = O(n^{1000})$?
    <ul>
      <li>정의에 의하면 맞음 : 그래프상 확인해보아도 맞음.</li>
      <li>$f(n)\geq g(n) \cdot c$</li>
    </ul>
  </li>
</ul>

<h2 id="notes-for-big-o">Notes for big O</h2>

<ul>
  <li>[Note 1] The big O puts an <u>**asymptotic**</u> <u>upper bound</u> on a function.
    <ul>
      <li>복잡도를 따질 때 ‘몇 초’가 걸린다기 보다는 얼마나 효율적인가를 따지는 척도
        <ul>
          <li>PL, HW 상황에 대해서 implementation 관점에서 개인 차 발생</li>
        </ul>
      </li>
      <li>Asymptotic analysis (from Wikipedia)
        <ul>
          <li>asymptotic : 점근적인</li>
          <li>
            <p>data size가 커질 때, 이 알고리즘이 시간이나 필요로 하는 메모리 사이즈가 얼마나 나빠지는가? → 알고리즘이 요구하는 시간, 메모리 양 등이 얼마나 나쁜 형태로 변화하는지 ‘형태’</p>

            <blockquote>
              <p>If $f(n) = n^2 + 3n$, then as n becomes very large, the term $3n$ becomes insignificant compared to $n^2$. The function f(n)f(n) is said to be “asymptotically equivalent to n^2n2, as $n→∞$”. This is often written symbolically as $f(n) -&gt; n^2$, which is read as “$f(n)$ is asymptotic to $n^2$”.</p>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>계산 비용이 $0.01n^2$ 과 $100n$ 알고리즘 중 어떤 것이 더 효율적인가?
        <ul>
          <li>이론적인 관점에서 $100n = O(n), 0.01n^2 = O(n^2)$</li>
          <li>input size $n=3$: $0.09 \quad 300$</li>
          <li>input size $n=10^6$: $0.01 \cdot (10^6)^2 = 10^{10}$, $100 \cdot 10^6 = 10^8$</li>
        </ul>

        <p>→ 결국 $O(n^2)$</p>
      </li>
      <li>(Tight) upper bound
        <ul>
          <li>$37log n + 0.1n = O(n)$
            <ul>
              <li>n이 커지면 $\log n$은 상당히 작아짐</li>
            </ul>
          </li>
          <li>$n^2 + 10n = O(n^2)$</li>
          <li>$4(\log n)^2 + n \log n + 100n = O(n \log n)$
            <ul>
              <li>$\log n$ vs $n$ → 당연하게 $\log n$</li>
              <li>$n \log n &gt; {\log n} ^2$</li>
            </ul>
          </li>
          <li>$n^2 + 10n = O(n^{200})$???
            <ul>
              <li>upper bound 맞아 틀린 말은 아니지만, 일반적으로 O Notation을 활용할 때에는 tight upper bound를 선택하여 표현한다.</li>
            </ul>
          </li>
        </ul>

        <blockquote>
          <p>💡 Dominating Term</p>
          <ul>
            <li>지배하는 term을 찾아 Upper Bound를 찾는다.</li>
          </ul>
        </blockquote>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - 지배하는 term을 찾아 Upper Bound를 찾는다.   - $\log _en $등 base는 왜 고려하지 않느냐 → 상수에 해당하므로 상관 없기 때문에.
  - $\log _2 n = \frac {\log_e n }{\log_e2}$
</code></pre></div>        </div>
      </li>
    </ul>

    <p>### Growth Rates of Some Common Complexity Functions</p>

    <ul>
      <li>이론적으로는 $n^3$은 efficient하지만 현실적으로는 문제가 발생할 수 있을만한 복잡도</li>
      <li>감당할 수 없을 정도로 커지네 등 asymptotic 특성을 분석하기 위함</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/8.png" alt="8" /></p>

<ul>
  <li>[Note 2] Given a cost function g(n), how do you find the proper complexity function f(n) such that $g(n) = O(f(n))$?
    <ul>
      <li>Suppress lower-order terms and constant factors!</li>
      <li>Example:
        <ul>
          <li>$10^3 + 10^3n + 10^-3 n^2 = O(n^2)$
            <ul>
              <li>then $lim_{n \to \infty} \frac{n^2}{n} = \infty$</li>
            </ul>
          </li>
          <li>$5n \log_3 n + 3(\log_2 n)^2 + n + 6n^2 = O(n^2)$
            <ul>
              <li>then $lim_{n \to \infty} \frac{n}{log_en} = lim _{n \to \infty} = \infty$</li>
            </ul>
          </li>
          <li>$3(log_2 n)^2+ 0.1n = O(?)$
            <ul>
              <li>Dominate Term이 무엇일까?</li>
              <li>$\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}}$ =$\infty, c, 0$
                <ul>
                  <li>$\infty$ : $(\log n)^2$ , $0$ : $n$ , $c$ :</li>
                  <li>L’Hospital Theorem : $\lim _{n \rightarrow \infty}{\frac {f(n)}{g(n)}} = \lim _{n \rightarrow \infty}{\frac {f’(n)}{g’(n)}} $
                    <ul>
                      <li>$\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}} = \lim = \lim _{n \rightarrow \infty} {\frac {2}{n}{}}0$</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>→ Linear Time</li>
            </ul>
          </li>
          <li>$2^{n+5} = O(2^n)$ ??</li>
          <li>$2^{5n} = O(2^n)$??</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="comparing-orders-of-growth">Comparing Orders of Growth</h2>

<ul>
  <li>How do you compare orders of growth of two functions?
    <ul>
      <li>One possible way is to compute the limit of the ratio of two functions in question.</li>
      <li>$x = lim_{n \to \infty } \frac{f_1(n)}{f_2(n)}$
        <ul>
          <li>if <em>x</em>=0, _f_1 has a smaller order of growth than _f_2</li>
          <li>if $x=c$, $f_1$ has a same order of growth than $f_2$</li>
          <li>if $x=\infty$, $f_1$ has a larger order of growth than $f_2$</li>
        </ul>
      </li>
      <li>Ex.1: $\log_2 n $ vs. $\sqrt{n}$
        <ul>
          <li>$lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} = lim_{n \to \infty} \frac{(log_2 n)’}{(\sqrt(n))’} = lim_{n \to \infty} \frac{(log_2 e)\frac{1}{n}}{\sqrt\frac{1}{2\sqrt(n)}} $</li>
        </ul>
      </li>
      <li>Ex.1.2.: $\log_2 n $ vs. $n^{0.0001}$
        <ul>
          <li>$lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} $</li>
        </ul>
      </li>
      <li>Ex.2: $n!$ vs $2^n$ - factorial vs. exponential
        <ul>
          <li>$lim_{n \to \infty} \frac{ n!}{2^n} = lim_{n \to \infty} \frac{\sqrt{2 \pi n} (\frac {n}{e})^n}{2^n}=lim_{n \to \infty }\sqrt{2 \pi n} \frac{({n})^n}{2^n e^n}$</li>
          <li>stirling’s formula : $n! \approx \sqrt{2 \pi n} (\frac {n}{e})^n$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="ωbig-omega-notation">$Ω$ (Big Omega Notation)</h1>

<p>→ Lower Bound</p>

<ul>
  <li>for two given functions $f(n), g(n)$</li>
</ul>

<blockquote>
  <p>💡 $g(n) = \Omega(f(n))g(n)=Ω(f(n)) ⟺ \exists c \in \mathbb{R}, ∃c∈R,$ and $N \in \mathbb{Z^+ \cup {0}}$, s.t. $g(n) \geq cf(n) \forall n \geq N$</p>
</blockquote>

<ul>
  <li>We say that g(n)<em>g</em>(<em>n</em>) is <em>ω</em> of $f(n)$.</li>
  <li>The Ω puts an asymptotic lower bound on a function.</li>
  <li>Ex:
    <ul>
      <li>$37\log n+0.1n=\Omega(n)$</li>
      <li>$n^2 + 10n = \Omega(n^2)$</li>
      <li>$4(logn)^2 +nlogn+100n=\Omega(nlogn)$</li>
      <li>$n^{200} +10n=\Omega(n^2)$</li>
      <li>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/9.png" alt="9" /></p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="θbig-theta-notation">$Θ$ (Big Theta Notation)</h1>

<ul>
  <li>for two given functions f(n)<em>f</em>(<em>n</em>) , g(n)<em>g</em>(<em>n</em>)
    <ul>
      <li>위에서 누르고</li>
      <li>아래에서 누르고</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 $g(n) = \Theta(f(n))g(n)=Θ(f(n)) \iff⟺ g(n) = O(f(n))g(n)=O(f(n)) and g(n) = \Omega (f(n))$</p>
</blockquote>

<ul>
  <li>
    <p>that is,</p>

    <blockquote>
      <p>💡 $g(n) = \Theta (f(n))g(n)=Θ(f(n)) \iff⟺ \exists c,d \in \mathbb{R}∃c,d∈R and N \in \mathbb{Z^+ \cup {0}}N∈Z+∪0 s.t. g(n) \geq cf(n)g(n)≥cf(n) \forall n \geq N∀n≥N$</p>
    </blockquote>
  </li>
  <li>We say that g(n)<em>g</em>(<em>n</em>) is order of f(n)<em>f</em>(<em>n</em>).</li>
  <li>The \ThetaΘ puts an asymptotic bound on a function.</li>
  <li>$0.1n + 10n^2 = O(n^{1000}) / O(n^2)$
    <ul>
      <li>Big O 로 N 자승이다 하며는 tight upper bound를 이야기한다.</li>
    </ul>
  </li>
  <li>Ex:
    <ul>
      <li>$37\log n+0.1n=\Theta(n)$
        <ul>
          <li>$O(n), \Omega(n)$</li>
        </ul>
      </li>
      <li>$n^2 + 10n = \Theta(n^2)$</li>
      <li>$4(logn)^2 +nlogn+100n=\Theta(nlogn)$</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 $\Theta(1)&lt;\Theta(log n)&lt;\Theta(n)&lt;\Theta(n log n)&lt;\Theta(n^2)&lt;\Theta(n^3)&lt;\Theta(n^j)&lt;\Theta(n^k)&lt;\Theta(a^n)&lt;\Theta(b^n)&lt;\Theta(n!)$</p>
</blockquote>

<ul>
  <li>for $k&gt;j&gt;3 , b&gt;a&gt;1$</li>
  <li>O(1) or <em>O</em>(<em>c</em>) : constant
    <ul>
      <li>$g(n) = 0.000001 \cdot n$</li>
      <li>g(n) = 1000000<em>g</em>(<em>n</em>)=1000000</li>
    </ul>
  </li>
  <li>Ref. Neapolitan Ex. (pp.42) 19, 24, 26, 28]</li>
</ul>

<h1 id="big-o-omega-and-order">Big O, Omega, and Order</h1>

<ul>
  <li>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/10.png" alt="10" /></p>
  </li>
  <li>Ref.<em>Ref</em>. [ Neapolitan Chapter 1.]</li>
</ul>

<h2 id="execution-times-for-algorithms-with-the-given-time-complexities">Execution Times for Algorithms with the Given Time Complexities</h2>

<ul>
  <li>n의 k승, 이를 polynomial time (다항 시간)이라고 칭한다.</li>
  <li>n log n, log는 다항식이 아닌데 왜 polynomial이라고 하는가?
    <ul>
      <li>upperbound : n 자승보다 빠르니까 polynomial time에 들어가게 됨.</li>
    </ul>
  </li>
  <li>실제적으로 회사 가서 이 문제를 풀어주는 SW를 해서, 제출한다고 했을 때, n이 커짐에 따라 이러한 효율적인 알고리즘들은 그 피해가 덜한데, 뒤는 피해가 현실적으로 받아들일 수 없을 정도로 커진다. 우리가 이론적으로 구별은 무엇이냐 하면은 polynomial - nonpolynomial alg.를 구분
    <ul>
      <li>$n^6$은 이론적으로는 polynomial - 안 좋긴 하지만</li>
    </ul>
  </li>
  <li>exponential, factorial algorithm은 inefficient, polynomial algorithm은 algorithm
    <ul>
      <li>현실적으로는 cubic도 빡셈</li>
    </ul>
  </li>
  <li>알고리즘 :
    <ul>
      <li>이론적인 측면에서 polynomial time 에 쓰이는가</li>
      <li>프로그램을 구현해서 돌릴 때, 당연히 cuvic보다는 효유적으로 돌아갈 것이다</li>
    </ul>
  </li>
  <li>현실적으루 n이 작을 때에는 그렇게 큰 지장이 없지만, n이 점차 커질 때 log, linear는 잘 버티는 데에 반해 exp, factorial
    <ul>
      <li>processor가 좋아진다 한들 풀고자 하는 문제가 더 커지기 때문에 시대적 needs라기 보다는 항상 우리 곁의 needs</li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/11.png" alt="11" /></p>

    <ul>
      <li>logarithmic, linear, n log n, quadratic, cubic « exp « factorial</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/12.png" alt="12" /></p>

<h1 id="worst-case-vs-average-case-time-complexity">Worst-Case vs. Average-Case Time Complexity</h1>

<ul>
  <li>complexity : time, space complexity
    <ul>
      <li>편의상 time complexity를 따짐</li>
    </ul>
  </li>
  <li><strong>Expected value</strong> (from Wikipedia)
    <ul>
      <li>let X_X_ be a random variable with a finite number of finite outcomes $x_1, x_2, …, x_k$ occuring with probabilities $p_1, p_2, … p_k$ respectively.</li>
      <li>the Expectation of X is defined as :
        <ul>
          <li>$E(X) = \sum_{i=1}^{k }{x_i p_i} = x_1p_1+ x_2 p_2 + … + x_k p_k$</li>
        </ul>
      </li>
      <li>since the sum of all probabilities $p_i$ is 1 (\sum_{i=1}^{k} {p_i}=1∑<em>i</em>=1<em>k__pi</em>=1) , the expected value is the weighted sum of the x_i_xi_ values, with the p_i_pi_ values being the weights</li>
      <li>$a_1, a_2, a_3 \rightarrow b_1 , b_2, b_3$
        <ul>
          <li>input size n에 대해서 모든 가능한 input들의 집합을 S_n</li>
          <li>임의의 input $I$</li>
          <li>$c(I) $ :</li>
          <li>$p(I):$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Worst-case complexity :
    <ul>
      <li>모든 가능한 인풋중에 최악으로 가장 많은 시간이 걸리는 경우. 가장 시간이 많이 걸리는 경우</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>$T_W (n) = max { c(I)</td>
              <td>I \in S_n }$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>Average-case complexity
    <ul>
      <li>모든 input에 대해서 일어날 확률 등에 대해 평균을 낸 것.</li>
      <li>$T_A (n) = \sum_{I \in S_n} p(I) c(I)$</li>
    </ul>
  </li>
  <li>Problem
    <ul>
      <li>Find the index of a given value <em>a</em> in a givven array $(a_0, a_1, …,a <em>{n-1})$. if _a</em> doesn’t exist in the array return −1</li>
    </ul>
  </li>
  <li>Cost for a linear search algorithm
    <ul>
      <li>let P_i_Pi_ be the probability such that a= a_i_a_=<em>ai</em></li>
      <li>
        <p>then the average cost is :</p>

        <p>$g(n) = 1 \cdot P_0 + 2 \cdot P_1 + 3 \cdot P_2 + …+ n \cdot P_{n-1} + n (1 - \sum_{k=0}^{n-1} P_k)$</p>

        <p>$= \sum_{k=0}^{n-1} (k+1)P_k + n (1 - \sum_{k=0}^{n-1} P_k)=∑k=0n−1(k+1)Pk+n(1−∑k=0n−1Pk)$</p>

        <ul>
          <li>Ex.1. $n = 10^9$, $P_0 + P_1 + …+ P_{10^3} = 1$ so $g(n)=O(1)$</li>
          <li>Ex.2. $n = 10^9$, $P_0 + P_1 + …+ P_{\frac n {100} }= 1$, so g(n) = O(n)<em>g</em>(<em>n</em>)=<em>O</em>(<em>n</em>)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>💡 배우게 될 내용, 중요</p>
</blockquote>

<ul>
  <li>[중요] <strong>참고: Quick sort 알고리즘 →</strong>
    <ul>
      <li>Worst-case : $O(n^2)$</li>
      <li>Average-Case : $O(n \log n)$</li>
    </ul>
  </li>
</ul>

<h1 id="reviews">Reviews</h1>

<h2 id="summation">Summation</h2>

<ul>
  <li>Sums of powers
    <ul>
      <li>$\sum_{i=1}^{n} i = \frac {n(n+1)} {2}$</li>
      <li>$\sum_{i=1}^{n} i^2 = \frac {n(n+1)(2n+1)} {6}$</li>
      <li>$\sum_{i=1}^{n} i^3 = (\frac {n(n+1)} {2})^2$</li>
      <li>$\sum_{i=1}^{n} i^4 = \frac {n(n+1)(2n+1)(3n^2+3n-1)} {30}$</li>
      <li>$\sum_{i=1}^{n} i^s = \frac {(n+1)^{s+1}} {s+1} + \sum_{k=1}^{s} \frac {B_k} {s-k+1} {s \choose k} (n+1)^{s-k+1}$
        <ul>
          <li>$B_k$ is the $k^{th}$ Bernoulli Number.</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} i^{-s} = \prod_{p prime} \frac {1} {1 - p^{-s}} = \zeta(s)$
        <ul>
          <li>$\zeta_k$ is the Riemann zeta function</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Growth rates
    <ul>
      <li>$\sum_{i=1}^{n} i^c \in \Theta(n^{c+1})$
        <ul>
          <li>for real c greater than 1−1</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} \frac 1 i \in \Theta(log n)$</li>
      <li>$\sum_{i=1}^{n} c^i \in \Theta( n \cdot log(n)^{c+1})$
        <ul>
          <li>for real c_c_ greater than 11</li>
        </ul>
      </li>
      <li>$\sum_{i=1}^{n} log(i)^c \in \Theta(n \cdot log(n)^{c})$ for nonnegative real $c$</li>
      <li>$</li>
    </ul>

    <p>\sum_{i=1}^{n} log(i)^c \cdot i^d \in \Theta(n^{d+1} \cdot log(n)^{c})$ for nonnegative real $c, d$</p>
    <ul>
      <li>$\sum_{i=1}^{n} log(i)^c \cdot i^d \cdot b^i \in \Theta(n^{d} \cdot log(n)^{c} \cdot b^n) $for nonnegative real $b&gt;1, c, db&gt;1,c,d$</li>
    </ul>
  </li>
  <li><strong>Read</strong> <a href="http://en.wikipedia.org/wiki/Summation"><em>Summation</em></a>, <a href="http://en.wikipedia.org/wiki/List_of_mathematical_series."><em>Mathematical Series</em></a></li>
</ul>

<h2 id="run-time-analysis">Run Time Analysis</h2>

<p>What is the worst-case time complexity of each loop?</p>

<ul>
  <li>어디가 dominate한가 : SW를 개발 할 때 최적화를 해 주어야 함. program이 도는 것을 보면 어디가 bottleneck이 되어 비효율적인가</li>
  <li>
    <p>(1) Matrix Addition : $O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>(2)$O(n^2)$
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x+= i+j</code>가 i번 수행되고, $\Sigma_{i=1}^N i = \frac{N(N+1)}{2} = \frac {N^2} 2 + \frac N 2$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">x</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(3) $O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="k">else</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="c1">// N^2</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
      <span class="c1">// N^2</span>
</code></pre></div>    </div>
  </li>
  <li>(4) $O(n^3)$
    <ul>
      <li>$\frac N 2 \cdot N$ . $\frac N 2 N^2$ → $n^3$이 dominate</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span>
          <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="p">{</span>
                  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                      <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>(5)
    <ul>
      <li>$\Sigma_{i=1}^N \Sigma_{j=1}^i j= O(N^3)$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="c1">//What if this is i*i?</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="n">x</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>(6)$ \rightarrow O(N^4)$
    <ul>
      <li>$\Sigma_{i=1}^N \Sigma_{j=1}^{i^2} \Sigma_{k=1}^j k= O(N^4)$</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//j가 i의 배수이면</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
          <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>n 이 작냐, 크냐에 따라서 10만이냐 100만이냐 할 때 어떤 속도로 나빠질 것인가? 얼마나 잘 유지될 것인가?</li>
      <li>항상 j가 1부터 i^2까지 도는데, j%i ==0 일 때 까지만 돈다 : j가 i의 배수인 경우</li>
      <li>j가 i의 배수일 때 :
        <ul>
          <li>$i = 1,2, … n$</li>
          <li>$j = 1, i, 2i, …, i^2$</li>
          <li>$\Sigma_{i=1}^{N}{(1 + i + … + i^2)}$</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>What is the worst-case time complexity of each loop?</p>

<ul>
  <li>
    <p>(1)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n = 2^k for some positive</span>
      <span class="c1">// integer k</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="c1">// some O(1) computation</span>
              <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(2)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n = 2^k for some positive</span>
      <span class="c1">// integer k</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="c1">// some O(1) computation</span>
              <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(3) Could this be faster?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//</span>
      <span class="kt">float</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="err">–</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(4) Magic square : Could this be faster?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// n: odd integer</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
              <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">key</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span> <span class="n">key</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">])</span>
              <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
          <span class="k">else</span>
          <span class="p">{</span>
              <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
              <span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>(5)$ O(\log n)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// compute x^n (n &gt;= 0)</span>
      <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
      <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span>
          <span class="p">{</span>
              <span class="n">m</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
              <span class="n">z</span> <span class="o">*=</span> <span class="n">z</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">m</span><span class="o">--</span><span class="p">;</span>
          <span class="n">power</span> <span class="o">*=</span> <span class="n">z</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>time complexity. : $c_0 + c_1 n + c_2 n^2 = O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
              <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>time complexity. : $c( ⌊{log_2 n}⌋+1) \cdot n^2 = O(n^2)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// n &gt; 0</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>for k=1;k≤n;k=k*2</li>
      <li>floor : 3.7 → 3, ceil : 3.7 → 4</li>
      <li>$n=15 \rightarrow \lfloor log_2 15 \rfloor = \lfloor 3.*** \rfloor = 3$</li>
      <li>1 2 4 8 15</li>
    </ul>
  </li>
  <li>
    <p>time complexity. : $??= O( \sqrt n)$</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// n &gt; 0</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">i</span><span class="o">++</span><span class="p">;</span>
          <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
          <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="alg-14-mss-1">[ALG] 1.4. MSS (1)</h1>

<blockquote>
  <p>최대 부분 수열의 합 Maximum Subsequence Sum</p>
</blockquote>

<ul>
  <li>어떠한 알고리즘을 설계하느냐에 따라서 어떻게 결과가 달라지는지.</li>
</ul>

<h1 id="maximum-subsequence-sum-mss-problem">Maximum Subsequence Sum (MSS) Problem</h1>

<ul>
  <li><em>Ref</em>. <strong>[M. Weiss,</strong> <strong>Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]</strong>
    <ul>
      <li>Given $N$ (possiblly negative) $A_0, A_1, …, A_{N-1} \in \mathbb{Z}$</li>
      <li>find the maximum value of $\sum_{k=i}^{j} {A_k }$ for $0 \leq i \leq j \leq N-1$</li>
      <li>for convenience, the max subseuqence sum is 0 if all the integers ‘re &lt;0</li>
    </ul>
  </li>
  <li>Example
    <ul>
      <li>$(-2, 11, -4, 13, -5, -2). → MSS = 20$</li>
      <li>$(a_1, …, a_6)$ : 수열의 모든 가능한 부분수열 중 $\Sigma_{k=i}^j {A_k}$ 임의의 i에서 시작해서 j에서 끝나는 것들을 더했는데 그런 것들 중 제일 큰 것을 찾아라.
        <ul>
          <li>sequence element들은 정수일 때 subsequence를 찾는다.: subsequence의 합이 최대가 되게하는 수열.</li>
          <li>주어진 수열의 정수가 모두 음수이면 mss=0 간주</li>
        </ul>
      </li>
      <li>length = 0, 1, 2로 시작하거나,,
        <ul>
          <li>아무리 빨라도 $n^2$보다 빠르게는 못 만들겠다는 생각이 들 수 있다.
            <ul>
              <li>n개 data 중 가장 작은 것 뽑기 : 한 번씩 sequential search를 해야 하므로 n</li>
              <li>n^2개의 경우는 n^2가 될 것 같은데,</li>
              <li>divide n conquer : $O(N \log N), $ DP : $O(n)$</li>
            </ul>
          </li>
          <li>→ $n + (n-1) + (n-2) + … + 2 + 1 = \frac {n(n+1)}{2} = O(n^2)$</li>
        </ul>
      </li>
      <li>
        <p>이 안에 모든 존재하는 subsequence 중에 합을 가장 크게 하는 subsequence를 찾아라.</p>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/13.png" alt="13" /></p>
      </li>
    </ul>
  </li>
  <li>Maximum Subarray Problem</li>
  <li>Maximum Positive Sum Subarray Problem</li>
  <li>Max. Sum Subsequence versus Max. Subsequence Sum</li>
</ul>

<h1 id="alg-of-maximum-subsequence-sum">Alg of Maximum Subsequence Sum</h1>

<ul>
  <li>길이 n인 정수의 수열 $a_0, a_1, …, a_{n-1}$이 입력으로 주어져 있다.</li>
  <li>여기서 부분 수열 $[i, j]$ 라는 것은 $ a_i, a_{i+1}, a_{i+2}…, , a_{j}$를 말한다.</li>
  <li>a의 최대값을 구하는 문제이다.
    <ul>
      <li>(이때 주어진 수열의 정수가 모두 음수이면 최대 부분 수열의 합은 0 이라고 간주한다)</li>
      <li>예를 들어 다음과 같은 수열이 주어졌을 때, $+ 31, −41, +59, +26, −53, +58, +97, −93, −23, +84$  최대 부분 수열은 [2,6]이며 수열의 합은 187 이 된다.</li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/14.png" alt="14" /></p>
  </li>
  <li>이 문제는 최대 부분 수열의 합을 구하는 것이지만, 앞으로 소개할 알고리즘을 조금만 수정하면 최대 부분 수열도 쉽게 구할 수 있다.
    <ul>
      <li>empty string : letter char=0, NULL String</li>
      <li>substring</li>
      <li>string</li>
      <li>length</li>
    </ul>

    <blockquote>
      <p>Algorithm1 : 모든 경우의 수 찾기 - $O(N^3) $</p>
    </blockquote>

    <blockquote>
      <p>Algorithm2 : Sum구할 때 중복 조금 피하기 - $O(N^2)$ </p>
    </blockquote>

    <ul>
      <li>simple counting
        <ul>
          <li>$O(n^2)$ : SS 여러 개가 있는데 한 번씩 모두 보자.</li>
          <li>$i$에서 시작하는 것들 1, 2, … 개를 모두 보자 : $n^2$개를 모두 본 것.</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/15.png" alt="15" /></p>

    <blockquote>
      <p>Algorithm3 : Divide n Conquer - $O(N \log N)$ </p>
    </blockquote>

    <ul>
      <li>Divide n Conquer
        <ul>
          <li>경우를 나눈다 : MSS subsequence가 존재하는데 이를 반으로 잘라서 분명히 어딘가 존재한다 → 왼쪽 혹은 오른쪽, 아니면 양다리 걸치던지.</li>
          <li>왼쪽 중 제일 큰 것 찾고, 오른쪽 존재 중 제일 큰 것 ㅈ찾고, 양다리 중 제일 큰 것 찾고.</li>
          <li>그중에 제일 큰 것을 찾았는데 O(Nlog N)걸리더라</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/16.png" alt="16" /></p>

    <blockquote>
      <p>Algorithm4 : Dynamic Programming - $O(N)$</p>
    </blockquote>

    <ul>
      <li>DP
        <ul>
          <li>각각의 i에 대해서 i번째 끝나는 애들</li>
          <li>분명히 maximum sum을 해주는 것은 하나 존재하는데 첫 번째 원서로 끝나던지, … 몇 번째쯤에 끝날 것이다. n번째에서 끝나는 것들 각각을 보자는 의미이다.</li>
        </ul>
      </li>
    </ul>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/17.png" alt="17" /></p>

    <ul>
      <li>algorithm을 만들 때, 효율을 신경쓰지 말고 하나하나 따져본다. 고등학교 때 순열과 조합으로 경우의 수를 따지는데, 전공에서 매우 중요한 요소이다.
        <ul>
          <li>문제를 어떻게 접근해 해결함에 따라 n^2개가 있음에도 불구하고 훨씬 더 효율적으로 문제를 해결할 수 있다.</li>
        </ul>
      </li>
      <li>이런 수열이 주어졌을 때 분명 답은 존재한다:</li>
      <li>alg 1, 2
        <ul>
          <li>모두 -라면 정답은 0이고 :
            <ul>
              <li>-임을 확인하는 비용은 linear time</li>
            </ul>
          </li>
          <li>양수가 하나라도 있으면 찾아보아야 한다</li>
        </ul>
      </li>
    </ul>

    <p>0에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고, —- 1, 2 번째에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고. n-1 까지 중 제일 작은 거</p>
  </li>
</ul>

<h1 id="mss-1---simple-counting">MSS 1 - simple counting</h1>

<ul>
  <li>Strategy
    <ul>
      <li>Enumerate all possibilities one at a time.</li>
      <li>
        <p>No efficiency is considered, resulting in a lot of unnecessary computation!</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Maxsum</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">Thissum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">j</span><span class="p">])</span>
              <span class="n">Maxsum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Thissum</span><span class="p">,</span> <span class="n">Maxsum</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>모든 경우의 수를 하나하나 모두 따져보는 방법.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
      <span class="c1">// i = 리스트 왼쪽 끝 인덱스, j = 리스트 오른쪽 끝 인덱스,</span>
      <span class="c1">//  ThisSum = 고려 대상 부분 리스트 합, MaxSum = 문제 최종결론</span>
      <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                  <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
                  <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>Is this for-loop OK for you?</li>
      <li>Time Complexity : $O(N^3)$
        <ul>
          <li>𝑖와 관련된 반복문은 𝑛n번, 𝑗와 관련된 반복문은 최대 𝑛번, Thissum을 구할 때 최대 𝑛개의 요소를 계산해야 하기에</li>
          <li>
            <p>$\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>$\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// for (i = 0; i &lt; N; i++)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
     <span class="c1">// {</span>
       <span class="c1">//   ThisSum = 0;</span>
         <span class="c1">// for (k = i; k &lt;= j; k++)</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>$\sum_{k=i}^{j} 1 = j-i+1$</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//for (i = 0; i &lt; N; i++)</span>
  <span class="c1">//    for (j = i; j &lt; N; j++)</span>
  <span class="c1">//    {</span>
  <span class="c1">//        ThisSum = 0;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>0번째에서 시작해서 Max 구한 것,…, n번째에서 시작하여 Max 구한 것.</li>
      <li>크게 바깥쪽에서 for loop이 돌면서 i번째부터 시작해서 i 하나, 두개, 세개, … 모든 것을 다 봐서 i번째에서 시작하는 것 중 가장 큰 것을 찾으려 한다.</li>
      <li>for loop은 i, i+1, i - i+2, i - n-1… 까지 더해 봄.</li>
    </ul>

    <blockquote>
      <p>💡 [개선점] 이전에 더한것에다가 하나만 더 더하면 되지 않을까</p>
    </blockquote>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/18.png" alt="18" /></p>

<h1 id="mss-2">MSS 2</h1>

<ul>
  <li>
    <p>Strategy</p>

    <blockquote>
      <p>💡 이전 스택에서 하나만 더 더하면 되는 것 아닌가?</p>
    </blockquote>

    <ul>
      <li>Get rid of the inefficiency in the innermost for-loop. Algorithm 1보다 중복을 줄이는 방법</li>
      <li>
        <p>for loop가 하나 사라지게 됨.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Maxsum</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">Thissum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">A</span> <span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">j</span><span class="p">])</span>
              <span class="n">Maxsum</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">Thissum</span><span class="p">,</span> <span class="n">Maxsum</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>Notice that $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
      <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
                  <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
      <li>time complexity : $O(N^3) \rightarrow O(N^2)$</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/19.png" alt="19" /></p>

<h1 id="mss--3--divide-n-conquer">MSS  3 : Divide n Conquer</h1>

<p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/20.png" alt="20" /></p>

<ul>
  <li>Divide and Conquer
    <ul>
      <li>경우의 수를 따짐 : 전부 다 음수가 아니라면 분명히 하나 존재한다.</li>
      <li>0번 원소부터 n-1 원소까지 있는데 이를 반으로 1/2로 뚝 자르고,
        <ul>
          <li>홀수 개수면 정확히 나눠지지 않음, 짝수 개수이면 정확히 둘로 나누어짐</li>
        </ul>
      </li>
      <li>left segment에 있던지 right segment에 있던지 양다리 걸치던지. 의 세가지 케이스 중 제일 큰 값을 찾는다.</li>
      <li>→ 이 전체에서 mss를 찾고자 하는데, 일단 왼쪽하고 오른쪽 각각에서 MSS 찾고</li>
    </ul>
  </li>
  <li>원래 플고자 하는 문제와 problem size만 다르다
    <ul>
      <li>전체 subsequence를 반으로 잘라 left- right segment 각각 영역에서의 MSS를  찾고자 함.</li>
      <li>결국 같은 문제 : problem size 만 1/2, 1/2된 케이스</li>
      <li>전체 문제 사이즈 2인것을 1, 1로 divide하여 각각의 segment에서 conquer하여 찾는다</li>
      <li>with - ‘Recursion’
        <ul>
          <li>자기 자신을 부른다 :</li>
          <li>항상 recursive call을 할 때는 problem size를 작게 하여 부른다.</li>
          <li>양다리 걸치는 것 중 제일 큰 것을 찾아 비교</li>
          <li>각 동네에서 MSS를 찾아 그 중 제일 큰 것을 돌린다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Why is Log N
    <ul>
      <li>[사진]</li>
      <li>Binary Tree에서 각 depth별로 $1 , 2, 4, 8, …$</li>
      <li>$O (N \log N)$</li>
    </ul>
  </li>
  <li>Strategy
    <ul>
      <li>Use the <strong>Divide-and-Conquer</strong> strategy.
        <ul>
          <li>원 문제를 작은 문제로 나눠 풀고, 그 결과를 합쳐 문제를 해결하는 알고리즘</li>
        </ul>
      </li>
      <li>The maximum subsequence sum can be in one of three places.</li>
      <li>교재에 탑재되어 있지만 그렇게 좋은 코드가 아닌듯 하다 !</li>
      <li>leaf node 1개까지 내려왔을 경우 양수이면 그대로 return하고 음수이면 0</li>
      <li>Divide and Conquer
        <ul>
          <li>center를 찾아 중앙 지점 : 똑같은 문제 [index left-right] 를 풀지만 [left-center], [center-right]로 원래 풀고자 하는 문제를 divide해서 푼다.</li>
          <li>recursion의 묘미 : 막아주는 부분 (else return 0)이 있어야 top-down으로 내려갈 수 있는 divide and conquer</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">Left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Right</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">MaxLeftBorderSum</span><span class="p">,</span> <span class="n">MaxRightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">LeftBorderSum</span><span class="p">,</span> <span class="n">RightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">Center</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">//종료조건if (Left == Right){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">];</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// divide n conquer</span>
  <span class="n">Center</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="o">+</span> <span class="n">Right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//왼쪽, 오른쪽, 중간</span>
  <span class="n">MaxLeftSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Center</span><span class="p">);</span>
  <span class="n">MaxRightSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Right</span><span class="p">);</span>
		
  <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">LeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 1. left ending 끝으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">LeftBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LeftBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxLeftBorderSum</span><span class="p">)</span>
          <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">LeftBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
  <span class="c1">// 2. right ending 시작으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">RightBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RightBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxRightBorderSum</span><span class="p">)</span>
          <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="n">RightBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">Max3</span><span class="p">(</span><span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">,</span> <span class="n">MaxLeftBorderSum</span> <span class="o">+</span> <span class="n">MaxRightBorderSum</span><span class="p">);</span>
  <span class="c1">// MaxLeftSum - left segment의 sum</span>
  <span class="c1">// MaxRighttSum - right segment의 sum</span>
  <span class="c1">// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대</span>
  <span class="err">}</span>
  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것
            <ul>
              <li></li>
            </ul>
          </li>
        </ul>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/21.png" alt="21" /></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">Left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Right</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">MaxLeftBorderSum</span><span class="p">,</span> <span class="n">MaxRightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">LeftBorderSum</span><span class="p">,</span> <span class="n">RightBorderSum</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">Center</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">//종료조건if (Left == Right){</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">Left</span><span class="p">];</span>
      <span class="k">else</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// divide n conquer</span>
  <span class="n">Center</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="o">+</span> <span class="n">Right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">//왼쪽, 오른쪽, 중간</span>
  <span class="n">MaxLeftSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Left</span><span class="p">,</span> <span class="n">Center</span><span class="p">);</span>
  <span class="n">MaxRightSum</span> <span class="o">=</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Center</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Right</span><span class="p">);</span>
		
  <span class="c1">// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것</span>
		
  <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">LeftBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// 1. left ending 끝으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Left</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">LeftBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LeftBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxLeftBorderSum</span><span class="p">)</span>
          <span class="n">MaxLeftBorderSum</span> <span class="o">=</span> <span class="n">LeftBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
		
  <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RightBorderSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
  <span class="c1">// 2. right ending 시작으로 하는 mss</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">Center</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">RightBorderSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">RightBorderSum</span> <span class="o">&gt;</span> <span class="n">MaxRightBorderSum</span><span class="p">)</span>
          <span class="n">MaxRightBorderSum</span> <span class="o">=</span> <span class="n">RightBorderSum</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">Max3</span><span class="p">(</span><span class="n">MaxLeftSum</span><span class="p">,</span> <span class="n">MaxRightSum</span><span class="p">,</span> <span class="n">MaxLeftBorderSum</span> <span class="o">+</span> <span class="n">MaxRightBorderSum</span><span class="p">);</span>
  <span class="c1">// MaxLeftSum - left segment의 sum</span>
  <span class="c1">// MaxRighttSum - right segment의 sum</span>
  <span class="c1">// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대</span>
  <span class="err">}</span>
  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="n">MaxSubSum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>cost : $T(n) = 2T(\frac n 2) + cn$, $T(1) = d$</li>
  <li>why O(N log N)<em>O</em>(<em>NlogN</em>) ?
    <ul>
      <li>$T(n) = 2T(\frac n 2) + cn$</li>
      <li>
        <p>$T(1) = d$</p>

        <p>$= 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$</p>

        <p>$= 2^2 T [ \frac n {2^2}] + 2cn$</p>

        <p>$= 2^3 T [ \frac n {2^3}] + 3cn =…$</p>

        <p>$= 2^i T [ \frac n {2^i}] + icn$</p>

        <p>$= 2^{\log_2 n} T(1) + \log_2 n \cdot cn$</p>

        <p>$=nT(1) + \log_2 n \cdot cn$</p>

        <p>$= O(n) + O(n \log_2 n) = O(n \log_2 n)$</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="mss--4-kadanes-algorithm">MSS  4; Kadane’s algorithm</h1>

<ul>
  <li>
    <p>i번째 원소로 끝나는 가장 합이 큰 subsequence가 얘라면, 다른 나머지를 분리했을 때 i-1로 끝나는 subsequence이다.</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/22.png" alt="22" /></p>

    <ul>
      <li>아니다 → 모순 증명 : 고등학교 proof by contradiction 귀류법으로</li>
      <li>i원소로 끝나는 합이 제일 큰 subsequence는 얘인데, 합이 제일 큰 subsequence가 되어야 한다.</li>
      <li>합이 제일 큰 부분을 찾는데, 나보다 하나 앞애 있는 i-1까지의 sequence로 바뀐다.
        <ul>
          <li>recursion이랑 비슷 : 같은 문제룰 푸는데 문제 크기가 달라짐. 이를 어떤 형식으로 해결하느냐에 따라서 달라지게 됨.</li>
        </ul>
      </li>
      <li>i번째 끝나는 subsequence중에 여러가지 있을 수 있는데, 그 중 가장 합이 큰 것을 Bi라고 할 때
        <ul>
          <li>$B[i]$ : the sum of the maximum subsequence that ends at index $i$</li>
          <li>$B[i] = \max { B[i-1] + A[i], 0}$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Strategy</p>
    <ul>
      <li>Use the Dynamic Programming strategy.</li>
      <li>subsequence sum&lt;0인 경우, 논리적으로 최대값이 될 수 없음에 착안한 전략</li>
      <li>
        <p>만약에 sum이 음수라도 무방하고 1개 이상의 원소로 구성된 Subsequence (subarray)를 구하는 문제라면?</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		
      <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// j번째 원소르 끝나는 것 중 합이 제일 큰 것</span>
          <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 지금까지의 원소르 끝나는 것 중 합이 제일 큰 것</span>
      <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
          <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
              <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
          <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="c1">// if (ThisSum&lt;0) ThisSum=0; </span>
              <span class="c1">// else if (ThisSum&gt;MaxSum) MaxSum = ThisSum;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>thissum : j 번째 돌 때 j-1번째 원소로 끝나는 것 중 제일 합이 큰 것.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">ThisSum += A[j]</code></li>
        </ul>
      </li>
      <li>ThisSum → 0, j번째 원소로 끝나는 것 중 가장 큰 거보다 크면 바꿔치기하고..</li>
      <li>최소한 모든 원소를 한 번씩은 봐야 하기 때문에 linear보다 더 빠른 alg는 없다.</li>
      <li>Time Complexity : $O(n)$
        <ul>
          <li>for i, iteration n times, and $ O(1$) for 1 calculation</li>
        </ul>
      </li>
      <li>C Implementation
        <ul>
          <li>
            <p>Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="nf">kadane</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">finish</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">;</span>
			
      <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">local_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
              <span class="n">local_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">maxSum</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
              <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">local_start</span><span class="p">;</span>
              <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">finish</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
  <span class="c1">// at least one non-negative number.</span>
			
  <span class="c1">// When all numbers in the array are negative</span>
      <span class="n">maxSum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">maxSum</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
              <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">finish</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="c1">// Empty subsequence를 허용하면 0을 리턴 (원래 문제)</span>
  <span class="c1">// Empty subsequence를 허용하지 않으면 음수 중 가장 큰 원소를 리턴</span>
          <span class="k">return</span> <span class="n">maxSum</span><span class="p">;</span>
  <span class="p">}</span>
			
			
			
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="so-why-do-we-bother-with-the-time-complexity">So, why do we bother with the time complexity?</h3>

<h1 id="alg-15-maximum-sum-subrectangle-in-2d-array-1">[ALG] 1.5. Maximum Sum Subrectangle in 2D Array (1)</h1>

<h1 id="maximum-sum-subrectangle-in-2d-array">Maximum Sum Subrectangle in 2D Array</h1>

<p>= max sum submatrix</p>

<p>2차원 array가 있을 때 합을 제일 최대로 만들게 하는 subrectangle을 찾아라.</p>

<ul>
  <li>empty subrectangle 허용
    <ul>
      <li>모두 음수면 0</li>
    </ul>
  </li>
  <li>empty subrectangle 비허용
    <ul>
      <li>모두 음수라면 절댓값이 제일 작은 것 선택</li>
    </ul>
  </li>
  <li>행이 m개, 열이 n개 :
    <ul>
      <li>n자승개가 존재한다고 햇는데, order로 subrectangle이 몇 개 존재할 것인가?</li>
      <li></li>
    </ul>
  </li>
  <li>Problem
    <ul>
      <li>Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle is <strong>any contiguous sub-array of size 1x1 or greater</strong> located within the whole array.)</li>
    </ul>
  </li>
  <li>Note
    <ul>
      <li>What is the input size of this problem?
        <ul>
          <li>$(m, n)$</li>
          <li>If $m = n→n$</li>
          <li>problem size를 (n,n) 할수도 있고</li>
        </ul>
      </li>
      <li>How many subrectangles are there in an mxn array?</li>
      <li>For the case of $m = n$,
        <ul>
          <li>Design an $O(n^6)$ algorithm.</li>
          <li>Design an $O(n^5)$ algorithm.</li>
          <li>Design an $O(n^4)$ algorithm.</li>
          <li>
            <p>Design an <em>O</em>(_n_3) algorithm.</p>

            <p>O(n^3)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>각각의 $(i,j,k,l)$에 의해 하나가 정의 :</li>
  <li>How many subrectangles are there in an mxn array?
    <ul>
      <li>
        <p>[1D case] for an m * n_m_∗<em>n</em> rectangle,</p>

        <p>$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1$</p>

        <p>$= (\sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1)(\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} 1)$</p>

        <p>$= { \sum_{k=0}^{m-1}(m-k)}{\sum_{i=0}^{n-1}{(n-i)}}$</p>

        <p>$= \frac {m(m+1)} {2} \frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4)$ if $m=n$</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="a-naïve-approach">A Naïve Approach</h2>

<ul>
  <li>For each subrectangle, find its sum.</li>
  <li>
    <p>[가정] $n=m$</p>

    <p>$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} {(l-k+1)}$</p>

    <p>let $A =\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)}$</p>

    <p>$A = 1<em>n + 2</em>(n-1) +3(n-2) + … + n*1A=1∗n+2∗(n−1)+3(n−2)+…+n∗1 = \sum_{i=1}^{n} {i(n-i+1)} = n \sum_{i=1}^n i - \sum_{i=1}^n i^2 + \sum_{i=1}^n i = \frac{1}{6} n^3$</p>

    <ul>
      <li>so $O(\frac{1}{36} n^6 )$
undefined- Time Complexity : $O(n^6)$</li>
    </ul>
  </li>
  <li>inefficient algorithm</li>
</ul>

<h2 id="mss--summed-area-table">MSS : Summed Area Table</h2>

<ul>
  <li>memory 자체도 resource이기 때문에 항상 많이 쓰는 것이 좋은 건 아니지만, summed area table이라는 memory를 하나 써서 문제를 풀게 된다.</li>
  <li>Table construction: $O(n^2)$
    <ul>
      <li>각 원소는 대응되는 영역의 합이 각 대응되는 위치에 지정한다 : 순서대로 쭉 원소들을 훑으며 계산한다. 이를 계산하면 내가 훑어야 하는 원소의 개수가 n^2만큼 있다. 각각의 원소는 상수 시간에 계산되어야 한다.</li>
      <li>n^2에 대해서 계산하려고 하는데, 각각을 상수 시간 안에 계산하여야 한다.</li>
      <li></li>
    </ul>
  </li>
  <li>Sum comparisons:$O(n^4)$</li>
  <li>
    <p>Time Complexity : $O(n^4)$</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/23.png" alt="23" /></p>

    <ul>
      <li>preprocess를 통해 table의 내용을 채울 것이다.</li>
      <li>$(i,j,k,l)$에 해당하는 것이 $n^4$개만큼 나오는데, 그 영역에 대한 합을 계산해서 사각형의 합 중 제일 큰 것을 선택하면 됨.</li>
      <li>$S(i,j,k,l) = T(l,j) - T(k-1, j) + T(k, j-1) + T (k-1. i-1)$
        <ul>
          <li>constant time : 각 사각형에 대한 계산</li>
          <li>살펴봐야 할 것들은 $n^4$개 존재하니까.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>문제 : 지금까지는 time complexity를 따졌지만 문제는 space complexity
    <ul>
      <li>input data : @n^2 만큼의 자리를 차지함.
        <ul>
          <li>→ 모바일 SW를 개발한다 : input data 말고도 성능이 낮거나 memory size 작거나 access 느린 cpu에 대해서는 안 좋을수 있다. 시스템 부담이 되는 상황 발생 가능</li>
        </ul>
      </li>
      <li>time complexity : n인 문제를 푸는 데 걸리는 시간</li>
      <li>space complexity : 문제 푸는데 걸리는 메모리
        <ul>
          <li>문제 사이즈 n에 대해서 $n^4$</li>
        </ul>
      </li>
      <li></li>
    </ul>
  </li>
</ul>

<h3 id="maximum-sum-subrectangle-kadane-algo-based">Maximum Sum Subrectangle: Kadane Algo.-Based</h3>

<blockquote>
  <p>💡 n^3에 해보자</p>
</blockquote>

<ul>
  <li>분명히 MSS인 rectangle이 존재하는데, i에서 시작해서 j로 끝남 : 그러면 이제 어떤 식으로 문제를 바라볼 것이냐 : $0 \leq i \leq j \leq n-1$이 가능한 pair
    <ul>
      <li>i번째 열에서 j번째로 끝나는 모든 가능한 rectangle을 살펴보자.</li>
      <li>가능한 조건을 만족하는 i,j → n^2만큼 존재함.</li>
      <li>모든 가능한 i, j에 대해서 i행에서 시작하고 j열에서 끝나는 mss를 찾아보자.</li>
      <li>column이 i, j번째에 끝나는 : 합이 제일 큰 것을 찾자. 라고 접근</li>
      <li>만약
        <ul>
          <li>temp array를 만들어서 임의의 주어진 i, j에 대해서 첫 번재 원소는 1 행, 2번째 원소는 2행, … 을 모두 저장해 놓은 값을 저장해 두었다고 하자.</li>
          <li>주어진 i, j에 대해서 행 열이 i에서 시작해서 j로 끝나는 subrectangle 중 제일 큰 것은 어떻게 찾을 수 있을까.</li>
          <li>1차원 sequence에서 합을 제일 크게 하는 mss를 찾으면 된다.</li>
        </ul>
      </li>
    </ul>

    <blockquote>
      <p>💡 모든 가능한 (i,j) pair에 대해서 볼 것이다.<br />
바깥에서 for loop이 돌 때 저만큼 존재한다.<br />
각 행에 있는 것들을 다 더해두면 (temp) → i열에서 시작해서 j로 끝나는 가능한 rectangle을 만든다. 합이 제일 큰 것은 temp가 있기 때문에, linear time에 합이 제일 큰 subsequence를 찾으면 바로 k행부터 l행까지 정의되는 사각형이 Maximum sum이 되더라.</p>
    </blockquote>

    <ul>
      <li>다시 이양기하지만, 조건 만족하는 쌍이 i,j개 존재하니까 linear time에 계산할 수 있으면</li>
      <li>각각을 n에 대해서 계산하면 $n^3$이 나온다.</li>
    </ul>
  </li>
  <li>Idea
    <ul>
      <li>ref. <a href="https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/">geeksforgeeks</a></li>
      <li>MSS(2D)의 해당 열은 어디이건 i에서 j까지 임.</li>
      <li>가능한 모든 (i, j) 조합에 대하여 MSS(1D)를 Kadane 알고리즘을 사용하여 찾음.</li>
      <li>
        <p>그렇게 하기 위하여, …</p>

        <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/24.png" alt="24" /></p>
      </li>
    </ul>
  </li>
  <li>어떤 식으로 구현할지 보여야 구현할 것인데 자꾸 경험을 통해서 몸에 배면 구구단 외우듯이 간다.</li>
  <li>C Implementation
    <ul>
      <li>
        <p>left, right : $n^2$만큼 돈다</p>

        <table>
          <thead>
            <tr>
              <th>1</th>
              <th>2</th>
              <th>-1</th>
              <th>-4</th>
              <th>-20</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>-8</td>
              <td>-3</td>
              <td>4</td>
              <td>2</td>
              <td>1</td>
            </tr>
            <tr>
              <td>3</td>
              <td>8</td>
              <td>10</td>
              <td>1</td>
              <td>3</td>
            </tr>
            <tr>
              <td>-4</td>
              <td>-1</td>
              <td>1</td>
              <td>7</td>
              <td>-6</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<p>undefined
	```c
	// Program to find maximum sum subarray
	// in a given 2D array
	#include <stdio.h>
	#include <iostream>
	#include <string.h>
	using namespace std;
	#define INT_MAX 2147483647
	#define INT_MIN 2147483648
	#define ROW 4
	#define COL 5</string.h></iostream></stdio.h></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Implementation of Kadane's algorithm for
// 1D array. The function returns the maximum
// sum and stores starting and ending indexes
// of the maximum sum subarray at addresses
// pointed by start and finish pointers
// respectively.
int kadane(int *arr, int *start, int *finish, int n)
{
    // initialize sum, maxSum and
    int sum = 0, maxSum = INT_MIN, i;

    // Just some initial value to check
    // for all negative values case
    *finish = -1;

    // local variableint
    local_start = 0;

    for (i = 0; i &lt; n; ++i)
    {
        sum += arr[i];
        if (sum &lt; 0)
        {
            sum = 0;
            local_start = i + 1;
        }
        else if (sum &gt; maxSum)
        {
            maxSum = sum;
            *start = local_start;
            *finish = i;
        }
    }

    // There is at-least one
    // non-negative number
    if (*finish != -1)
        return maxSum;

    // Special Case: When all numbers
    // in arr[] are negative
    maxSum = arr[0];
    *start = *finish = 0;

    // Find the maximum element in array
    for (i = 1; i &lt; n; i++)
    {
        if (arr[i] &gt; maxSum)
        {
            maxSum = arr[i];
            *start = *finish = i;
        }
    }
    return maxSum;
}

// The main function that finds
// maximum sum rectangle in M[][]
void findMaxSum(int M[][COL])
{
    // Variables to store the final output
    int maxSum = INT_MIN,
        finalLeft,
        finalRight,
        finalTop,
        finalBottom;

    int left, right, i;
    int temp[ROW], sum, start, finish;

    // Set the left column
    for (left = 0; left &lt; COL; ++left)
    {
        // Initialize all elements of temp as 0
        memset(temp, 0, sizeof(temp));

        // Set the right column for the left
        // column set by outer loop
        for (right = left; right &lt; COL; ++right)
        {

            // Calculate sum between current left
            // and right for every row 'i'
            for (i = 0; i &lt; ROW; ++i)
                temp[i] += M[i][right];

            // Find the maximum sum subarray in temp[].
            // The kadane() function also sets values
            // of start and finish. So 'sum' is sum of
            // rectangle between (start, left) and
            // (finish, right) which is the maximum sum
            // with boundary columns strictly as left
            // and right.
            sum = kadane(temp, &amp;start, &amp;finish, ROW);

            // Compare sum with maximum sum so far.
            // If sum is more, then update maxSum and// other output values
            if (sum &gt; maxSum)
            {
                maxSum = sum;
                finalLeft = left;
                finalRight = right;
                finalTop = start;
                finalBottom = finish;
            }
        }
    }

    // Print final values
    cout &lt;&lt; "(Top, Left) ("
         &lt;&lt; finalTop &lt;&lt; ", "
         &lt;&lt; finalLeft
         &lt;&lt; ")" &lt;&lt; endl;
    cout &lt;&lt; "(Bottom, Right) ("
         &lt;&lt; finalBottom &lt;&lt; ", "
         &lt;&lt; finalRight &lt;&lt; ")" &lt;&lt; endl;
    cout &lt;&lt; "Max sum is: " &lt;&lt; maxSum &lt;&lt; endl;
}

// Driver Codeint
main()
{
    int M[ROW][COL];

    // Function call
    findMaxSum(M);

    return 0;
}
```
</code></pre></div></div>

<ul>
  <li>
    <p>결과는 아래와 같다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="n">Top</span><span class="p">,</span> <span class="n">Left</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="n">Bottom</span><span class="p">,</span> <span class="n">Right</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="n">Max</span> <span class="n">sum</span> <span class="n">is</span><span class="o">:</span> <span class="mi">29</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="mathematical-induction--proof-of-correctness">Mathematical Induction &amp; Proof of Correctness</h2>

<ul>
  <li>
    <p>Proof by Induction</p>

    <p><img src="/assets/img/2022-09-02-[ALG]-1.-Introduction.md/25.png" alt="25" /></p>
  </li>
  <li>
    <p>Proof of Correctness : MSS (1D)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">int</span> <span class="n">ThisSum</span> <span class="o">=</span> <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
	
      <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="n">MaxSum</span><span class="p">)</span>
          <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ThisSum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
	
  <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>P(j) : for-loop가 j번 수행한 직후에 ThisSum 변수는 ( )값을, MaxSum 변수는 ( )값을 가지고 있다.</li>
    </ul>
  </li>
</ul>

  </div><a class="u-url" href="/ALG-1.-Introduction" hidden></a>
</article>
<script>
  function getTOCNodes(master) {
    var nodes = Array.prototype.slice.call(master.getElementsByTagName("*"), 0);
    var tocNodes = nodes.filter(function (elem) {
      return elem.tagName == "A";
    });
    return tocNodes;
  }
  function getHeaderNodes(master) {
    var nodes = Array.prototype.slice.call(master.getElementsByTagName("*"), 0);
    var headerNodes = nodes.filter(function (elem) {
      return elem.tagName == "H1" || elem.tagName == "H2" || elem.tagName == "H3" || elem.tagName == "H4" || elem.tagName == "H5" || elem.tagName == "H6";
    });
    return headerNodes;
  }

  var title = document.getElementsByClassName("post-title")[0];
  var titleY = window.pageYOffset + title.getBoundingClientRect().top;

  var article = document.getElementsByClassName("post-article")[0];
  var articleY = window.pageYOffset + article.getBoundingClientRect().top;

  var toc = document.getElementsByClassName("toc")[0];

  var headerNodes = getHeaderNodes(article);
  var tocNodes = getTOCNodes(toc);

  var before = undefined;

  document.addEventListener('scroll', function (e) {
    if (window.scrollY >= articleY - 60) {
      toc.style.cssText = "position: fixed; top: 60px;";
    }
    else {
      toc.style.cssText = "";
    }

    var current = headerNodes.filter(function (header) {
      var headerY = window.pageYOffset + header.getBoundingClientRect().top;
      return window.scrollY >= headerY - 60;
    });

    if (current.length > 0) {
      current = current[current.length - 1];

      var currentA = tocNodes.filter(function (tocNode) {
        return tocNode.innerHTML == current.innerHTML;
      })

      currentA = currentA[0];
      if (currentA) {
        if (before == undefined) before = currentA;

        if (before != currentA) {
          before.classList.remove("toc-active");
          before = currentA;
        }

        currentA.classList.add("toc-active");
      }
      else {
        if (before)
          before.classList.remove("toc-active");
      }
    }
    else {
      if (before)
        before.classList.remove("toc-active");
    }

  }, false);
</script>
      </div>
    </main><footer>
  <hr style="margin-left: 15px; color: #000 !important; background-color: #000 !important; opacity: 1 !important; width: 40px; height: .5px !important; margin-bottom: 2rem !important;">
  <div class="row m-0">
    <div class="col-12 col-md-3 col-sm-4 mb-4 mb-sm-0">
      <p>
        <a href="https://github.com/underthelights/underthelights.github.io" style="font-weight: 300">Kyuhwan Shim</a>
        <br>Up-to-date as of <span id="date">loading...</span></p>
      <i class="fas fa-location-dot mr-1"></i> Seoul is <img style="width: auto; height: 23px;" id="weather_icon">
      <span id="weather">Loading...</span>
    </div>
    <div class="col-12 col-md-9 col-sm-8">
      <p>
        <a style="font-weight: 300" href="https://linkedin.com/in/kyuhwan-shim"><i class="fab fa-linkedin" style="margin-right: 10.5px"></i>LinkedIn</a><br>
        <a style="font-weight: 300" href="https://fb.com/s.kyuhwn"><i class="fab fa-facebook" style="margin-right: 8px"></i>Facebook</a><br>
        <a style="font-weight: 300" href="https://www.instagram.com/s.kyuhwn"><i class="fab fa-instagram" style="margin-right: 10.5px"></i>Instagram</a><br>
        <a style="font-weight: 300" href="https://github.com/underthelights"><i class="fab fa-github" style="margin-right: 10.5px"></i>GitHub</a><br>
      </p>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>

<script src="/assets/js/weather.js"></script>
<script src="/assets/js/github_date.js"></script>
</body>

</html>
