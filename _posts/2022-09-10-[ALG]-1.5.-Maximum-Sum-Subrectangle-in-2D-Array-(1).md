---
layout: post
date: 2022-09-10
title: "[ALG] 1.5. Maximum Sum Subrectangle in 2D Array (1)"
tags: [Algorithm, ]
categories: [Notes, ]
---


# Maximum Sum Subrectangle in 2D Array


= max sum submatrix


2차원 array가 있을 때 합을 제일 최대로 만들게 하는 subrectangle을 찾아라.

- empty subrectangle 허용
	- 모두 음수면 0
- empty subrectangle 비허용
	- 모두 음수라면 절댓값이 제일 작은 것 선택
- 행이 m개, 열이 n개 :
	- n자승개가 존재한다고 햇는데, order로 subrectangle이 몇 개 존재할 것인가?
	- 
- Problem
	- Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle is **any contiguous sub-array of size 1x1 or greater** located within the whole array.)
- Note
	- What is the input size of this problem?
		- $(m, n)$
		- If $m = n→n$
		- problem size를 (n,n) 할수도 있고
	- How many subrectangles are there in an mxn array?
	- For the case of $m = n$,
		- Design an $O(n^6)$ algorithm.
		- Design an $O(n^5)$ algorithm.
		- Design an $O(n^4)$ algorithm.
		- Design an _O_(_n_3) algorithm.

			O(n^3)

- 각각의 $(i,j,k,l)$에 의해 하나가 정의 :
- How many subrectangles are there in an mxn array?
	- [1D case] for an m * n_m_∗_n_ rectangle,

		$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1$


		$= (\sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1)(\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} 1)$


		$= { \sum_{k=0}^{m-1}(m-k)}{\sum_{i=0}^{n-1}{(n-i)}}$


		$= \frac {m(m+1)} {2} \frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4)$ if $m=n$


## A Naïve Approach

- For each subrectangle, find its sum.
- [가정] $n=m$

	$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} {(l-k+1)}$


	∑_i_=0_n_−1∑_j_=_in_−1∑_k_=0_m_−1∑_l_=_km_−1(_j_−_i_+1)(_l_−_k_+1)=∑_i_=0_n_−1∑_j_=_in_−1(_j_−_i_+1)∑_k_=0_m_−1∑_l_=_km_−1(_l_−_k_+1)


	let $A =\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)}$


	$A = 1*n + 2*(n-1) +3(n-2) + ... + n*1A=1∗n+2∗(n−1)+3(n−2)+...+n∗1 = \sum_{i=1}^{n} {i(n-i+1)} = n \sum_{i=1}^n i - \sum_{i=1}^n i^2 + \sum_{i=1}^n i = \frac{1}{6} n^3$

	- so $O(\frac{1}{36} n^6 )$
undefined- Time Complexity : $O(n^6)$
- inefficient algorithm

## MSS : Summed Area Table

- memory 자체도 resource이기 때문에 항상 많이 쓰는 것이 좋은 건 아니지만, summed area table이라는 memory를 하나 써서 문제를 풀게 된다.
- Table construction: $O(n^2)$
	- 각 원소는 대응되는 영역의 합이 각 대응되는 위치에 지정한다 : 순서대로 쭉 원소들을 훑으며 계산한다. 이를 계산하면 내가 훑어야 하는 원소의 개수가 n^2만큼 있다. 각각의 원소는 상수 시간에 계산되어야 한다.
	- n^2에 대해서 계산하려고 하는데, 각각을 상수 시간 안에 계산하여야 한다.
	- 
- Sum comparisons:$O(n^4)$
- Time Complexity : $O(n^4)$

	![0](/assets/img/2022-09-10-[ALG]-1.5.-Maximum-Sum-Subrectangle-in-2D-Array-(1).md/0.png)

	- preprocess를 통해 table의 내용을 채울 것이다.
	- $(i,j,k,l)$에 해당하는 것이 $n^4$개만큼 나오는데, 그 영역에 대한 합을 계산해서 사각형의 합 중 제일 큰 것을 선택하면 됨.
	- $S(i,j,k,l) = T(l,j) - T(k-1, j) + T(k, j-1) + T (k-1. i-1)$
		- constant time : 각 사각형에 대한 계산
		- 살펴봐야 할 것들은 $n^4$개 존재하니까.
- 문제 : 지금까지는 time complexity를 따졌지만 문제는 space complexity
	- input data : @n^2 만큼의 자리를 차지함.
		- → 모바일 SW를 개발한다 : input data 말고도 성능이 낮거나 memory size 작거나 access 느린 cpu에 대해서는 안 좋을수 있다. 시스템 부담이 되는 상황 발생 가능
	- time complexity : n인 문제를 푸는 데 걸리는 시간
	- space complexity : 문제 푸는데 걸리는 메모리
		- 문제 사이즈 n에 대해서 $n^4$
	- 

### Maximum Sum Subrectangle: Kadane Algo.-Based


> 💡 n^3에 해보자

- 분명히 MSS인 rectangle이 존재하는데, i에서 시작해서 j로 끝남 : 그러면 이제 어떤 식으로 문제를 바라볼 것이냐 : $0 \leq i \leq j \leq n-1$이 가능한 pair
	- i번째 열에서 j번째로 끝나는 모든 가능한 rectangle을 살펴보자.
	- 가능한 조건을 만족하는 i,j → n^2만큼 존재함.
	- 모든 가능한 i, j에 대해서 i행에서 시작하고 j열에서 끝나는 mss를 찾아보자.
	- column이 i, j번째에 끝나는 : 합이 제일 큰 것을 찾자. 라고 접근
	- 만약
		- temp array를 만들어서 임의의 주어진 i, j에 대해서 첫 번재 원소는 1 행, 2번째 원소는 2행, … 을 모두 저장해 놓은 값을 저장해 두었다고 하자.
		- 주어진 i, j에 대해서 행 열이 i에서 시작해서 j로 끝나는 subrectangle 중 제일 큰 것은 어떻게 찾을 수 있을까.
		- 1차원 sequence에서 합을 제일 크게 하는 mss를 찾으면 된다.

	> 💡 모든 가능한 (i,j) pair에 대해서 볼 것이다.  
	> 바깥에서 for loop이 돌 때 저만큼 존재한다.  
	> 각 행에 있는 것들을 다 더해두면 (temp) → i열에서 시작해서 j로 끝나는 가능한 rectangle을 만든다. 합이 제일 큰 것은 temp가 있기 때문에, linear time에 합이 제일 큰 subsequence를 찾으면 바로 k행부터 l행까지 정의되는 사각형이 Maximum sum이 되더라.

	- 다시 이양기하지만, 조건 만족하는 쌍이 i,j개 존재하니까 linear time에 계산할 수 있으면
	- 각각을 n에 대해서 계산하면 $n^3$이 나온다.
- Idea
	- ref. [geeksforgeeks](https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/)
	- MSS(2D)의 해당 열은 어디이건 i에서 j까지 임.
	- 가능한 모든 (i, j) 조합에 대하여 MSS(1D)를 Kadane 알고리즘을 사용하여 찾음.
	- 그렇게 하기 위하여, ...

		![1](/assets/img/2022-09-10-[ALG]-1.5.-Maximum-Sum-Subrectangle-in-2D-Array-(1).md/1.png)

- 어떤 식으로 구현할지 보여야 구현할 것인데 자꾸 경험을 통해서 몸에 배면 구구단 외우듯이 간다.
- C Implementation
	- left, right : $n^2$만큼 돈다
	- 

	```c
	// Program to find maximum sum subarray
	// in a given 2D array
	#include <stdio.h>
	#include <iostream>
	#include <string.h>
	using namespace std;
	#define INT_MAX 2147483647
	#define INT_MIN 2147483648
	#define ROW 4
	#define COL 5
	
	// Implementation of Kadane's algorithm for
	// 1D array. The function returns the maximum
	// sum and stores starting and ending indexes
	// of the maximum sum subarray at addresses
	// pointed by start and finish pointers
	// respectively.
	int kadane(int *arr, int *start, int *finish, int n)
	{
	    // initialize sum, maxSum and
	    int sum = 0, maxSum = INT_MIN, i;
	
	    // Just some initial value to check
	    // for all negative values case
	    *finish = -1;
	
	    // local variableint
	    local_start = 0;
	
	    for (i = 0; i < n; ++i)
	    {
	        sum += arr[i];
	        if (sum < 0)
	        {
	            sum = 0;
	            local_start = i + 1;
	        }
	        else if (sum > maxSum)
	        {
	            maxSum = sum;
	            *start = local_start;
	            *finish = i;
	        }
	    }
	
	    // There is at-least one
	    // non-negative number
	    if (*finish != -1)
	        return maxSum;
	
	    // Special Case: When all numbers
	    // in arr[] are negative
	    maxSum = arr[0];
	    *start = *finish = 0;
	
	    // Find the maximum element in array
	    for (i = 1; i < n; i++)
	    {
	        if (arr[i] > maxSum)
	        {
	            maxSum = arr[i];
	            *start = *finish = i;
	        }
	    }
	    return maxSum;
	}
	
	// The main function that finds
	// maximum sum rectangle in M[][]
	void findMaxSum(int M[][COL])
	{
	    // Variables to store the final output
	    int maxSum = INT_MIN,
	        finalLeft,
	        finalRight,
	        finalTop,
	        finalBottom;
	
	    int left, right, i;
	    int temp[ROW], sum, start, finish;
	
	    // Set the left column
	    for (left = 0; left < COL; ++left)
	    {
	        // Initialize all elements of temp as 0
	        memset(temp, 0, sizeof(temp));
	
	        // Set the right column for the left
	        // column set by outer loop
	        for (right = left; right < COL; ++right)
	        {
	
	            // Calculate sum between current left
	            // and right for every row 'i'
	            for (i = 0; i < ROW; ++i)
	                temp[i] += M[i][right];
	
	            // Find the maximum sum subarray in temp[].
	            // The kadane() function also sets values
	            // of start and finish. So 'sum' is sum of
	            // rectangle between (start, left) and
	            // (finish, right) which is the maximum sum
	            // with boundary columns strictly as left
	            // and right.
	            sum = kadane(temp, &start, &finish, ROW);
	
	            // Compare sum with maximum sum so far.
	            // If sum is more, then update maxSum and// other output values
	            if (sum > maxSum)
	            {
	                maxSum = sum;
	                finalLeft = left;
	                finalRight = right;
	                finalTop = start;
	                finalBottom = finish;
	            }
	        }
	    }
	
	    // Print final values
	    cout << "(Top, Left) ("
	         << finalTop << ", "
	         << finalLeft
	         << ")" << endl;
	    cout << "(Bottom, Right) ("
	         << finalBottom << ", "
	         << finalRight << ")" << endl;
	    cout << "Max sum is: " << maxSum << endl;
	}
	
	// Driver Codeint
	main()
	{
	    int M[ROW][COL] = {{1, 2, -1, -4, -20},
	                       {-8, -3, 4, 2, 1},
	                       {3, 8, 10, 1, 3},
	                       {-4, -1, 1, 7, -6}};
	
	    // Function call
	    findMaxSum(M);
	
	    return 0;
	}
	```

- 결과는 아래와 같다.

	```c
	(Top, Left) (1, 1)
	(Bottom, Right) (3, 3)
	Max sum is: 29
	
	
	```


## Mathematical Induction & Proof of Correctness

- Proof by Induction

	![2](/assets/img/2022-09-10-[ALG]-1.5.-Maximum-Sum-Subrectangle-in-2D-Array-(1).md/2.png)

- Proof of Correctness : MSS (1D)

	```c
	int ThisSum = MaxSum = 0;
	
	for (j = 0; j < N; j++)
	{
	    ThisSum += A[j];
	
	    if (ThisSum > MaxSum)
	        MaxSum = ThisSum;
	    else if (ThisSum < 0)
	        ThisSum = 0;
	}
	
	return MaxSum;
	```

	- P(j) : for-loop가 j번 수행한 직후에 ThisSum 변수는 ( )값을, MaxSum 변수는 ( )값을 가지고 있다.
