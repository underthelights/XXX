---
layout: post
date: 2022-09-08
title: "[ALG] 1.4. MSS (1)"
tags: [Algorithm, ]
categories: [Notes, ]
---


> 최대 부분 수열의 합 Maximum Subsequence Sum

- 어떠한 알고리즘을 설계하느냐에 따라서 어떻게 결과가 달라지는지.

# Maximum Subsequence Sum (MSS) Problem

- _Ref_. **[M. Weiss,** **Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]**
	- Given $N$ (possiblly negative) $A_0, A_1, ..., A_{N-1} \in \mathbb{Z}$
	- find the maximum value of $\sum_{k=i}^{j} {A_k }$ for $0 \leq i \leq j \leq N-1$
	- for convenience, the max subseuqence sum is 0 if all the integers 're <0
- Example
	- $(-2, 11, -4, 13, -5, -2). → MSS = 20$
	- $(a_1, ..., a_6)$ : 수열의 모든 가능한 부분수열 중 $\Sigma_{k=i}^j {A_k}$ 임의의 i에서 시작해서 j에서 끝나는 것들을 더했는데 그런 것들 중 제일 큰 것을 찾아라.
		- sequence element들은 정수일 때 subsequence를 찾는다.: subsequence의 합이 최대가 되게하는 수열.
		- 주어진 수열의 정수가 모두 음수이면 mss=0 간주
	- length = 0, 1, 2로 시작하거나,,
		- 아무리 빨라도 $n^2$보다 빠르게는 못 만들겠다는 생각이 들 수 있다.
			- n개 data 중 가장 작은 것 뽑기 : 한 번씩 sequential search를 해야 하므로 n
			- n^2개의 경우는 n^2가 될 것 같은데,
			- divide n conquer : $O(N \log N), $ DP : $O(n)$
		- → $n + (n-1) + (n-2) + ... + 2 + 1 = \frac {n(n+1)}{2} = O(n^2)$
	- 이 안에 모든 존재하는 subsequence 중에 합을 가장 크게 하는 subsequence를 찾아라.

		![0](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/0.png)

- Maximum Subarray Problem
- Maximum Positive Sum Subarray Problem
- Max. Sum Subsequence versus Max. Subsequence Sum

# Alg of Maximum Subsequence Sum

- 길이 n인 정수의 수열 $a_0, a_1, ..., a_{n-1}$이 입력으로 주어져 있다.
- 여기서 부분 수열 $[i, j]$ 라는 것은 $ a_i, a_{i+1}, a_{i+2}..., , a_{j}$를 말한다.
- a의 최대값을 구하는 문제이다.
	- (이때 주어진 수열의 정수가 모두 음수이면 최대 부분 수열의 합은 0 이라고 간주한다)
	- 예를 들어 다음과 같은 수열이 주어졌을 때, $+ 31, −41, +59, +26, −53, +58, +97, −93, −23, +84$  최대 부분 수열은 [2,6]이며 수열의 합은 187 이 된다.

	![1](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/1.png)

- 이 문제는 최대 부분 수열의 합을 구하는 것이지만, 앞으로 소개할 알고리즘을 조금만 수정하면 최대 부분 수열도 쉽게 구할 수 있다.
	- empty string : letter char=0, NULL String
	- substring
	- string
	- length

	> Algorithm1 : 모든 경우의 수 찾기 - $O(N^3) $


	> Algorithm2 : Sum구할 때 중복 조금 피하기 - $O(N^2)$ 

	- simple counting
		- $O(n^2)$ : SS 여러 개가 있는데 한 번씩 모두 보자.
		- $i$에서 시작하는 것들 1, 2, … 개를 모두 보자 : $n^2$개를 모두 본 것.

	![2](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/2.png)


	> Algorithm3 : Divide n Conquer - $O(N \log N)$ 

	- Divide n Conquer
		- 경우를 나눈다 : MSS subsequence가 존재하는데 이를 반으로 잘라서 분명히 어딘가 존재한다 → 왼쪽 혹은 오른쪽, 아니면 양다리 걸치던지.
		- 왼쪽 중 제일 큰 것 찾고, 오른쪽 존재 중 제일 큰 것 ㅈ찾고, 양다리 중 제일 큰 것 찾고.
		- 그중에 제일 큰 것을 찾았는데 O(Nlog N)걸리더라

	![3](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/3.png)


	> Algorithm4 : Dynamic Programming - $O(N)$

	- DP
		- 각각의 i에 대해서 i번째 끝나는 애들
		- 분명히 maximum sum을 해주는 것은 하나 존재하는데 첫 번째 원서로 끝나던지, … 몇 번째쯤에 끝날 것이다. n번째에서 끝나는 것들 각각을 보자는 의미이다.

	![4](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/4.png)

	- algorithm을 만들 때, 효율을 신경쓰지 말고 하나하나 따져본다. 고등학교 때 순열과 조합으로 경우의 수를 따지는데, 전공에서 매우 중요한 요소이다.
		- 문제를 어떻게 접근해 해결함에 따라 n^2개가 있음에도 불구하고 훨씬 더 효율적으로 문제를 해결할 수 있다.
	- 이런 수열이 주어졌을 때 분명 답은 존재한다:
	- alg 1, 2
		- 모두 -라면 정답은 0이고 :
			- -임을 확인하는 비용은 linear time
		- 양수가 하나라도 있으면 찾아보아야 한다

	0에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고, —- 1, 2 번째에서 시작하는거 다 따져봐서 합이 제일 큰 것 찾고. n-1 까지 중 제일 작은 거 


# MSS 1 - simple counting

- Strategy
	- Enumerate all possibilities one at a time.
	- No efficiency is considered, resulting in a lot of unnecessary computation!

		```c
		Maxsum = 0 for (i = 0; i < n; i++)
		{
		    for (j = i; j < n; j++)
		    {
		        Thissum = sum(A [i:j])
		            Maxsum = max(Thissum, Maxsum)
		    }
		}
		```

	- 모든 경우의 수를 하나하나 모두 따져보는 방법.

		```c
		int MaxSubsequenceSum(const int A[], int N)
		{
		    int ThisSum, MaxSum, i, j, k;
		    // i = 리스트 왼쪽 끝 인덱스, j = 리스트 오른쪽 끝 인덱스,
		    //  ThisSum = 고려 대상 부분 리스트 합, MaxSum = 문제 최종결론
		    MaxSum = 0;
		    for (i = 0; i < N; i++)
		        for (j = i; j < N; j++)
		        {
		            ThisSum = 0;
		            for (k = i; k <= j; k++)
		                ThisSum += A[k];
		            if (ThisSum > MaxSum)
		                MaxSum = ThisSum;
		        }
		    return MaxSum;
		}
		```

	- Is this for-loop OK for you?
	- Time Complexity : $O(N^3)$
		- 𝑖와 관련된 반복문은 𝑛n번, 𝑗와 관련된 반복문은 최대 𝑛번, Thissum을 구할 때 최대 𝑛개의 요소를 계산해야 하기에
		- $\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$

			```c
			for (i = 0; i < N; i++)
			```

		- $\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$

			```c
			// for (i = 0; i < N; i++)
			    for (j = i; j < N; j++)
			   // {
			     //   ThisSum = 0;
			       // for (k = i; k <= j; k++)
			```

		- $\sum_{k=i}^{j} 1 = j-i+1$

			```c
			//for (i = 0; i < N; i++)
			//    for (j = i; j < N; j++)
			//    {
			//        ThisSum = 0;
			        for (k = i; k <= j; k++)
			```

	- 0번째에서 시작해서 Max 구한 것,…, n번째에서 시작하여 Max 구한 것.
	- 크게 바깥쪽에서 for loop이 돌면서 i번째부터 시작해서 i 하나, 두개, 세개, … 모든 것을 다 봐서 i번째에서 시작하는 것 중 가장 큰 것을 찾으려 한다.
	- for loop은 i, i+1, i - i+2, i - n-1… 까지 더해 봄.

	> 💡 [개선점] 이전에 더한것에다가 하나만 더 더하면 되지 않을까


![5](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/5.png)


# MSS 2

- Strategy

	> 💡 이전 스택에서 하나만 더 더하면 되는 것 아닌가?

	- Get rid of the inefficiency in the innermost for-loop. Algorithm 1보다 중복을 줄이는 방법
	- for loop가 하나 사라지게 됨.

		```c
		Maxsum = 0 for (i = 0; i < n; i++)
		{
		    for (j = i; j < n; j++)
		    {
		        Thissum = sum(A [i:j])
		            Maxsum = max(Thissum, Maxsum)
		    }
		}
		```

		- Notice that $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$

		```c
		int MaxSubsequenceSum(const int A[], int N)
		{
		    int ThisSum, MaxSum, i, j;
		    MaxSum = 0;
		    for (i = 0; i < N; i++)
		    {
		        ThisSum = 0;
		        for (j = i; j < N; j++)
		        {
		            ThisSum += A[j];
		            if (ThisSum > MaxSum)
		                MaxSum = ThisSum;
		        }
		    }
		    return MaxSum;
		```

	- time complexity : $O(N^3) \rightarrow O(N^2)$

![6](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/6.png)


# MSS  3 : Divide n Conquer


![7](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/7.png)

- Divide and Conquer
	- 경우의 수를 따짐 : 전부 다 음수가 아니라면 분명히 하나 존재한다.
	- 0번 원소부터 n-1 원소까지 있는데 이를 반으로 1/2로 뚝 자르고,
		- 홀수 개수면 정확히 나눠지지 않음, 짝수 개수이면 정확히 둘로 나누어짐
	- left segment에 있던지 right segment에 있던지 양다리 걸치던지. 의 세가지 케이스 중 제일 큰 값을 찾는다.
	- → 이 전체에서 mss를 찾고자 하는데, 일단 왼쪽하고 오른쪽 각각에서 MSS 찾고
- 원래 플고자 하는 문제와 problem size만 다르다
	- 전체 subsequence를 반으로 잘라 left- right segment 각각 영역에서의 MSS를  찾고자 함.
	- 결국 같은 문제 : problem size 만 1/2, 1/2된 케이스
	- 전체 문제 사이즈 2인것을 1, 1로 divide하여 각각의 segment에서 conquer하여 찾는다
	- with - ‘Recursion’
		- 자기 자신을 부른다 :
		- 항상 recursive call을 할 때는 problem size를 작게 하여 부른다.
		- 양다리 걸치는 것 중 제일 큰 것을 찾아 비교
		- 각 동네에서 MSS를 찾아 그 중 제일 큰 것을 돌린다.
- Why is Log N
	- [사진]
	- Binary Tree에서 각 depth별로 $1 , 2, 4, 8, ...$
	- $O (N \log N)$
- Strategy
	- Use the **Divide-and-Conquer** strategy.
		- 원 문제를 작은 문제로 나눠 풀고, 그 결과를 합쳐 문제를 해결하는 알고리즘
	- The maximum subsequence sum can be in one of three places.
	- 교재에 탑재되어 있지만 그렇게 좋은 코드가 아닌듯 하다 !
	- leaf node 1개까지 내려왔을 경우 양수이면 그대로 return하고 음수이면 0
	- Divide and Conquer
		- center를 찾아 중앙 지점 : 똑같은 문제 [index left-right] 를 풀지만 [left-center], [center-right]로 원래 풀고자 하는 문제를 divide해서 푼다.
		- recursion의 묘미 : 막아주는 부분 (else return 0)이 있어야 top-down으로 내려갈 수 있는 divide and conquer

		```c
		int MaxSubSum(const int A[], int Left, int Right)
		{
		    int MaxLeftSum, MaxRightSum;
		    int MaxLeftBorderSum, MaxRightBorderSum;
		    int LeftBorderSum, RightBorderSum;
		    int Center, i;
		    //종료조건if (Left == Right){
		    if (A[Left] > 0)
		        return A[Left];
		    else
		        return 0;
		}
		// divide n conquer
		Center = (Left + Right) / 2;
		//왼쪽, 오른쪽, 중간
		MaxLeftSum = MaxSubSum(A, Left, Center);
		MaxRightSum = MaxSubSum(A, Center + 1, Right);
		
		MaxLeftBorderSum = 0;
		LeftBorderSum = 0;
		// 1. left ending 끝으로 하는 mss
		for (i = Center; i >= Left; i--)
		{
		    LeftBorderSum += A[i];
		    if (LeftBorderSum > MaxLeftBorderSum)
		        MaxLeftBorderSum = LeftBorderSum;
		}
		MaxRightBorderSum = 0;
		RightBorderSum = 0;
		
		// 2. right ending 시작으로 하는 mss
		for (i = Center; i <= Right; i++)
		{
		    RightBorderSum += A[i];
		    if (RightBorderSum > MaxRightBorderSum)
		        MaxRightBorderSum = RightBorderSum;
		}
		return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
		// MaxLeftSum - left segment의 sum
		// MaxRighttSum - right segment의 sum
		// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대
		}
		int MaxSubsequenceSum(const int A[], int N)
		{
		    return MaxSubSum(A, 0, N - 1);
		}
		```

		- // 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것
			- 

		![8](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/8.png)


		```c
		int MaxSubSum(const int A[], int Left, int Right)
		{
		    int MaxLeftSum, MaxRightSum;
		    int MaxLeftBorderSum, MaxRightBorderSum;
		    int LeftBorderSum, RightBorderSum;
		    int Center, i;
		    //종료조건if (Left == Right){
		    if (A[Left] > 0)
		        return A[Left];
		    else
		        return 0;
		}
		// divide n conquer
		Center = (Left + Right) / 2;
		//왼쪽, 오른쪽, 중간
		MaxLeftSum = MaxSubSum(A, Left, Center);
		MaxRightSum = MaxSubSum(A, Center + 1, Right);
		
		// 음수가 되는 경우이더라도 양다리가 걸칠 수 있도록 설계할 것
		
		MaxLeftBorderSum = A[i];
		LeftBorderSum = 0;
		// 1. left ending 끝으로 하는 mss
		for (i = Center; i >= Left; i--)
		{
		    LeftBorderSum += A[i];
		    if (LeftBorderSum > MaxLeftBorderSum)
		        MaxLeftBorderSum = LeftBorderSum;
		}
		
		MaxRightBorderSum = 0;
		RightBorderSum = 0;
		
		// 2. right ending 시작으로 하는 mss
		for (i = Center; i <= Right; i++)
		{
		    RightBorderSum += A[i];
		    if (RightBorderSum > MaxRightBorderSum)
		        MaxRightBorderSum = RightBorderSum;
		}
		return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
		// MaxLeftSum - left segment의 sum
		// MaxRighttSum - right segment의 sum
		// MaxLeftBorderSum - 가운데에서 left로 가는 것들 중 최대
		}
		int MaxSubsequenceSum(const int A[], int N)
		{
		    return MaxSubSum(A, 0, N - 1);
		}
		```

- cost : $T(n) = 2T(\frac n 2) + cn$, $T(1) = d$
- why O(N log N)_O_(_NlogN_) ?
	- $T(n) = 2T(\frac n 2) + cn$
	- $T(1) = d$

		$= 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$


		$= 2^2 T [ \frac n {2^2}] + 2cn$


		$= 2^3 T [ \frac n {2^3}] + 3cn =...$


		$= 2^i T [ \frac n {2^i}] + icn$


		$= 2^{\log_2 n} T(1) + \log_2 n \cdot cn$


		$=nT(1) + \log_2 n \cdot cn$


		$= O(n) + O(n \log_2 n) = O(n \log_2 n)$


# MSS  4; Kadane’s algorithm

- i번째 원소로 끝나는 가장 합이 큰 subsequence가 얘라면, 다른 나머지를 분리했을 때 i-1로 끝나는 subsequence이다.

	![9](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/9.png)

	- 아니다 → 모순 증명 : 고등학교 proof by contradiction 귀류법으로
	- i원소로 끝나는 합이 제일 큰 subsequence는 얘인데, 합이 제일 큰 subsequence가 되어야 한다.
	- 합이 제일 큰 부분을 찾는데, 나보다 하나 앞애 있는 i-1까지의 sequence로 바뀐다.
		- recursion이랑 비슷 : 같은 문제룰 푸는데 문제 크기가 달라짐. 이를 어떤 형식으로 해결하느냐에 따라서 달라지게 됨.
	- i번째 끝나는 subsequence중에 여러가지 있을 수 있는데, 그 중 가장 합이 큰 것을 Bi라고 할 때
		- $B[i]$ : the sum of the maximum subsequence that ends at index $i$
		- $B[i] = \max \{ B[i-1] + A[i], 0\}$
- Strategy
	- Use the Dynamic Programming strategy.
	- subsequence sum<0인 경우, 논리적으로 최대값이 될 수 없음에 착안한 전략
	- 만약에 sum이 음수라도 무방하고 1개 이상의 원소로 구성된 Subsequence (subarray)를 구하는 문제라면?

		```c
		int MaxSubsequenceSum(const int A[], int N){
		    int ThisSum, MaxSum, i;
		
		    ThisSum = 0; // j번째 원소르 끝나는 것 중 합이 제일 큰 것
				MaxSum = 0; // 지금까지의 원소르 끝나는 것 중 합이 제일 큰 것
		    for(i = 0; i < N; i++){
		        ThisSum += A[i];
		        if(ThisSum > MaxSum)
		            MaxSum = ThisSum;
		        else if(ThisSum < 0)
		            ThisSum = 0;
					// if (ThisSum<0) ThisSum=0; 
					// else if (ThisSum>MaxSum) MaxSum = ThisSum;
		    }
		    return MaxSum;
		}
		```

	- thissum : j 번째 돌 때 j-1번째 원소로 끝나는 것 중 제일 합이 큰 것.
		- `ThisSum += A[j]`
	- ThisSum → 0, j번째 원소로 끝나는 것 중 가장 큰 거보다 크면 바꿔치기하고..
	- 최소한 모든 원소를 한 번씩은 봐야 하기 때문에 linear보다 더 빠른 alg는 없다.
	- Time Complexity : $O(n)$
		- for i, iteration n times, and $ O(1$) for 1 calculation
	- C Implementation
		- Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks

			```c
			int kadane(int *arr, int *start, int *finish, int n)
			{
			    int sum = 0, maxSum = INT_MIN;
			
			    *finish = -1;
			    int local_start = 0;
			    for (int i = 0; i < n; ++i)
			    {
			        sum += arr[i];
			        if (sum < 0)
			        {
			            sum = 0;
			            local_start = i + 1;
			        }
			        else if (sum > maxSum)
			        {
			            maxSum = sum;
			            *start = local_start;
			            *finish = i;
			        }
			    }
			    if (*finish != -1)
			        return maxSum;
			// at least one non-negative number.
			
			// When all numbers in the array are negative
			    maxSum = arr[0];
			    *start = *finish = 0;
			    for (int i = 1; i < n; i++)
			    {
			        if (arr[i] > maxSum)
			        {
			            maxSum = arr[i];
			            *start = *finish = i;
			        }
			    }
			// Empty subsequence를 허용하면 0을 리턴 (원래 문제)
			// Empty subsequence를 허용하지 않으면 음수 중 가장 큰 원소를 리턴
					return maxSum;
			}
			
			
			
			```


### So, why do we bother with the time complexity?

