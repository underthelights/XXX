---
title: "Additional Binary Tree Operations (Chapter 5.4)"
excerpt: "Chap 5."
slug: "5-4-add-bt-op"

category: "data-structure"
lang: en
use_math: true
tags: ["CS", "data-structure"]
date: 2021-05-04T22:26:09-05:00
draft: false
---
## Additional Binary Tree Operations (Chapter 5.4)

### 5.4.1 Copying Binary Trees

- The function for copying a binary tree can be obtained by slightly modifying the function for postorder traversal.

<script src="https://gist.github.com/underthelights/35b55756d4307cfa7cecb6fc66ca947f.js"></script>


### 5.4.2 Testing For Equality of Binary Trees

- A function for testing whether two binary trees are equal can be obtained by modifying the function for preorder traversal.

<script src="https://gist.github.com/underthelights/e6f6b6bd5048d29740008da23c45a344.js"></script>

### 5.4.3 The Satisfiability Problem

- Consider the formulas constructed by taking variables, $x1, x2, ..., xn$ and operators $∧$ (and), $∨$ (or), and $￢$ (not).

- The variables can hold only one of two possible values, true or false. 

- The expressions are defined by the following rules:

  -  A variable is an expression.

  -  If x and y are expressions, then $￢x, x∧y, x∨y$ are expressions.

  -  Parentheses can be used to alter the normal order of evaluation, which is ￢ before ∧ before ∨.



- The algorithm that solves the satisfiability problem

  -  Try all possible combinations

  -  For example, if we have three variables $(x_1, x_2, x_3)$, we should try:

    $(T,T,T), (T,T,F), (T,F,T), (T,F,F), (F,T,T), (F,T,F), (F,F,T), (F,F,F)$

  - Time required to execute the program: 

    -  g: time needed to substitutue values for variables and evaluate the expression.
  

```pseudocode
for (all 2n possible combinations) { 
	generate the next combination;
	replace the variables by their values;
	evaluate the expression;
  
  if (its value is true) {
    printf(<combination>);
    return;
	} 
}
printf("no satisfiable combination\n");
```



- Evaluating an expression

  -  Represent the expression as a binary tree.

  <img width="413" alt="image-20211002211334509" src="https://user-images.githubusercontent.com/46957634/135752853-7d8a6b1f-094a-41a3-9300-85872b39726c.png">

- Traverse the tree in postorder, evaluating the subtrees until the entire expression is reduced to a single value.

- This corresponds to the postfix evaluation of an arithmetic expression.

- Evaluating an expression

| left_child | data | value | right_child |
| ---------- | ---- | ----- | ----------- |
|            |      |       |             |

- Evaluating an expression

<script src="https://gist.github.com/underthelights/46417fa75f4803f372600d38aebc7af5.js"></script>

#### Exercise [ex037]

- We would like to write a function which builds a tree from an expression.

- You will first need to convert the infix notation to a postfix notation, before generating the tree.
  - For converting infix notation to postfix notation, refer to [ex023] in lecture 09.

- For the 'NOT' operator which takes only one operand, we will decide to put the operand as the right child of the operator. (Just like in the figure below.)

- For convenience when we write the program:

  -  use a, b, c instead of x1, x2, x3. 

  -  use & instead of ∧

  -  use | instead of ∨

  -  use ~ instead of ㄱ

  <img width="413" alt="image-20211002211516177" src="https://user-images.githubusercontent.com/46957634/135752854-3869c5bb-9efb-4e0c-9e10-9693b312af03.png">(a & ~ b) | (~a & c) | ~c



