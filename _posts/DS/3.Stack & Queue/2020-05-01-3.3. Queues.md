---
title: "Queues (Chapter 3.3)"
excerpt: "Chap 3."
slug: "3-3-queues"

category: "data-structure"
lang: en
use_math: true
tags: ["CS", "data-structure"]
date: 2021-03-22T22:26:09-05:00
draft: false
---
## Queues (Chapter 3.3)

### Definition of Queue

- Similar to stack, queue is a specialized type of an ordered list.
- One end is called front.
- The other end is called rear (or back).
- Additions are done at the rear only.
- Removals are made from the front only.

### Queue: analogy 

- Bus stop
  - Elements are removed from the front of the queue.
  - Removing an element from a queue is called "dequeueing". 
  - Elements are removed from the front of the queue.
  - Removing an element from a queue is called "dequeueing".
  - New elements are inserted from the rear (back) of the queue.
  - Inserting a new element into the queue is called "enqueueing".

  
  
- Job scheduling in operating systems
  - non-priority scheduling: jobs are processed in the order they enter the system (FIFO behavior)
  - The operating system maintains a job queue in order to schedule jobs.

### Queue: FIFO behavior

- For a queue, the first element inserted to the queue is removed first.
- This type of behavior is called FIFO (First-In-First-Out).

<img width="426" alt="image-20211003161735276" src="https://user-images.githubusercontent.com/46957634/135751121-c49b2f14-7b45-4ea0-b9a4-5cbde6c17a55.png">

### Queue: Abstract Data Type

<script src="https://gist.github.com/underthelights/4f557a13f93840d19090b0575f65628a.js"></script>

### Queue: implementation

- We can use a one-dimensional array to represent a queue.
- We use two variables, front and rear, to indicate their positions in the array.
  - front points to the previous index of the first element.
  - If the first element is queue[0], then front is -1. Front is initialized to -1.
  - rear points to the index of the last element.
  - Initially, when the queue is empty, rear is initialized to -1.

<script src="https://gist.github.com/underthelights/56e502184ee377ad214f6133df87b6f0.js"></script>

#### Queue: implementation using an array[ex020]

- Adding an element to the queue
  - rear is incremented.
  - Then, the new element is stored at `queue[rear]`.

<script src="https://gist.github.com/underthelights/f8935bd4d64599681424aeddcc2917ec.js"></script>

- Deleting an element from the queue
  - front is incremented.
  - Then, `queue[front]` is returned.

<script src="https://gist.github.com/underthelights/5ae1359242920c51d720de81aabf29fe.js"></script>


- Behavior of the queue implemented from an array
  - Whenever a new element is inserted, rear moves to the right.
  - Whenever an element is deleted, front moves to the right.

<img width="308" alt="image-20211003162024038" src="https://user-images.githubusercontent.com/46957634/135751153-25d7a3ca-1b20-4e9b-a359-edfce2955ad5.png">

- The array has a limited capacity, so rear will eventually move to the last index.

  - rear becomes equal to `MAX_QUEUE_SIZE - 1`.

  - In this case, we need to reorganize the array in order to obtain spaces for newer

    elementse.

  - This is done by calling `queueFull()`;

    - If the queue is truly full, then an error will occur because we cannot insert more elements to the queue.
    - If the queue has available spaces at the left of front, we should move the elements in the queue to the left to get more space for new elements.
    - The worst-case time complexity of queueFull is O(MAX_QUEUE_SIZE). In order to avoid this, a circular array is used.

#### Queue: implementation using a circular array

- Still using a one-dimension array, we can configure the array as a circular array.

<img width="308" alt="image-20211003162109716" src="https://user-images.githubusercontent.com/46957634/135751154-6c8a2913-95f9-4c92-b6ac-7dfe4b985c74.png">

- If the array holds three elements, following are the possible states of the array.

<img width="381" alt="image-20211003162905958" src="https://user-images.githubusercontent.com/46957634/135751165-b5a924c6-0fb6-41b2-9cfd-8568e921c3ef.png">

- Use integer variables front and rear.
  - front is one position counterclockwise from the first element 
  - rear is the position of the last element

<img width="477" alt="image-20211003162946542" src="https://user-images.githubusercontent.com/46957634/135751166-7de4509b-749c-4f68-a070-261620aa0404.png">

- Adding an element
  - Move rear one position clockwise. 
  - Then put the new element into queue[rear].

<img width="477" alt="image-20211003163014525" src="https://user-images.githubusercontent.com/46957634/135751167-d1b08927-f3e8-49a4-87a0-f1b4aed4e148.png">

- Removing an element
  - Move front one position clockwise.
  - Then extract the element from queue[front].

<img width="477" alt="image-20211003163031951" src="https://user-images.githubusercontent.com/46957634/135751169-d2ffea2c-1a6c-43eb-96a5-da914fbe2581.png">

- Moving rear one position clockwise
  - capacity is the number of element spaces in the circular array.

```c
rear++;
if(rear == capacity) rear = 0;
```

<img width="357" alt="image-20211003163055181" src="https://user-images.githubusercontent.com/46957634/135751171-fc6fc56f-ea85-48ba-8372-ef3a5d01d625.png">

- Let us empty the queue. 
  - initial state

<img width="357" alt="image-20211003163110142" src="https://user-images.githubusercontent.com/46957634/135751173-b346f059-7b3b-4d5f-8b72-628002cf432f.png">

- Let us empty the queue.
  - A is removed from the queue.

<img width="357" alt="image-20211003163134909" src="https://user-images.githubusercontent.com/46957634/135751174-c0938a78-0a76-4dda-b23f-5fa1f161cf24.png">

- Let us empty the queue.
  - B is removed from the queue.

<img width="357" alt="image-20211003163142069" src="https://user-images.githubusercontent.com/46957634/135751175-3e40794c-88db-4baf-8542-cdea2b0058c7.png">



- Let us empty the queue.
  - C is removed from the queue. Now the queue is empty.

- When the queue is empty, front == rear.
- When we initialize the circular array, we set front = rear = 0.

<img width="357" alt="image-20211003163201959" src="https://user-images.githubusercontent.com/46957634/135751176-f886ae06-10a1-4525-aec4-4d112b2cbdd2.png">

- This time, let us make the queue full. 
  - initial state

<img width="357" alt="image-20211003163219600" src="https://user-images.githubusercontent.com/46957634/135751177-cbd34121-c1d4-4d15-97b0-23c18f1b7c3c.png">

- This time, let us make the queue full. 
  - D is inserted to the queue.

<img width="357" alt="image-20211003163230177" src="https://user-images.githubusercontent.com/46957634/135751178-a2fcde0e-a837-4568-ae24-f82d3c9bbc82.png">

- This time, let us make the queue full.
  -  E is inserted into the queue.

<img width="357" alt="image-20211003163245171" src="https://user-images.githubusercontent.com/46957634/135751179-e56d86b2-ba41-41bb-a0f3-307b3a8e0c35.png">

- This time, let us make the queue full. 
  - F is inserted into the queue.

- When the queue is full, front == rear.
- We cannot distinguish between a full queue and an empty queue!

<img width="357" alt="image-20211003163308541" src="https://user-images.githubusercontent.com/46957634/135751181-1c7acedc-7f42-4ab1-93db-b68bc236d51d.png">



- Problem when using a circular array
  - If(front==rear), we do not know whether the queue is full or empty.

- Solutions

  - Do not let the queue get full.
    - When the addition of an element will make the queue full, increase the size.

  - Define a Boolean variable last Operation Is AddQ.
    - Following each AddQ set this variable to true.
    - Following each DeleteQ set this variable to false. 
    - Queue is empty iff (front == rear) && !lastOperationIsAddQ 
    - Queue is full iff (front == rear) && lastOperationIsAddQ
  - Define an integer variable size.
    - Following each `AddQ` do size++.
    - Following each `DeleteQ` do size--.
    - Queue is empty iff (size == 0).
    - Queue is full iff (size == arrayLength).

- Adding an element to a queue using a circular array & Deleting an element from a queue using a circular array [ex021] 

<script src="https://gist.github.com/underthelights/64a9f7dac97a99325c267f4eca0aa6e4.js"></script>

- What are the time complexity of addq() and deleteq() when a circular array is used?
